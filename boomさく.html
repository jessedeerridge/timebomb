<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ãƒ†ãƒ³ãƒ—ãƒ¬</title>
<style>
/* ï¼ˆä¸­ç•¥ãªã—ãƒ»ãƒ•ãƒ«ç‰ˆï¼‰ */
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee;}
h1{margin:0;font-size:18px;}
.small{font-size:12px;opacity:.75;}
.join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px;}
.join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
.btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
.btn.primary{background:#111;color:#fff;border-color:#111;}
.btn.ghost{background:transparent;}
.hidden{display:none;}
#lobby{padding:20px;border-top:1px solid #eee;}
.copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}
.seat-pop{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);background:orange;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;}
.seat-pop.hidden{display:none;}
.seat-pop .row{display:flex;gap:8px;align-items:center;}
.seat-pop label{width:84px;font-size:13px;}
.seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
.tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
.tab.disabled::after{content:'âœ•';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
.tab.active{background:#111;color:#fff;border-color:#111;}

.wait-max-players-msg{
  position:fixed;
  left:50%;
  bottom:10px;
  transform:translateX(-50%);
  background:#111;
  color:#fff;
  padding:6px 14px;
  border-radius:999px;
  font-size:13px;
  box-shadow:0 8px 18px rgba(0,0,0,.25);
  z-index:221;
}
.wait-max-players-msg.hidden{
  display:none;
}

/* â˜… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å††é…ç½®ç”¨ */
.player-circle{
  position:relative;
  width:260px;
  height:260px;
margin:40px auto 0; 
  border-radius:50%;
  border:1px dashed #ddd;
  box-sizing:border-box;
}
.player-circle::before{
  content:''; /* ãƒ­ãƒ“ãƒ¼ç”¨ãªã®ã§ä¸­ã®æ–‡å­—ã¯æ¶ˆã™ */
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  font-size:11px;
  opacity:.45;
  pointer-events:none;
}
.player-tag{
  position:absolute;
  transform:translate(-50%,-50%);
  padding:4px 8px;
  border-radius:999px;
  background:#f8f8f8;
  border:1px solid #ddd;
  font-size:12px;
  white-space:nowrap;
}

/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«é¸æŠä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
.player-tag.shuffle3-selected{
  background:orange;   /* â† ã“ã“ã‚’ #111 ã‹ã‚‰ orange ã«å¤‰æ›´ */
  color:#fff;
  border-color:orange; /* â† ã“ã“ã‚‚ #111 ã‹ã‚‰ orange ã«å¤‰æ›´ */
}


/* â˜… æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼ˆãƒãƒ¼ãƒ ã‚¿ã‚°å·¦å³ã«è¡¨ç¤ºï¼‰ */
.player-tag-role-mini{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);
  width:28px;
  height:40px;
  border-radius:4px;
  border:1px solid #000;        /* åŸºæœ¬ã¯é»’ãƒ•ãƒ */
  background:#000;              /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å½±ã‚«ãƒ¼ãƒ‰ï¼ˆçœŸã£é»’ï¼‰ */
  font-size:0;                  /* ä¸­ã®ã€Œå…‰ã€ã€Œå½±ã€æ–‡å­—ã¯è¦‹ã›ãªã„ */
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
  pointer-events:none;
  background-position:center;
  background-size:contain;
  background-repeat:no-repeat;
}

/* å€‹äººçš„å…¬é–‹ï¼ˆpeek-viewï¼‰ã¯ä»Šã¾ã§é€šã‚Šæ ã ã‘å¤‰ãˆã‚‹ */
.player-tag-role-mini.peek-view{
  border-style:dashed;
  border-color:#9ca3af;
}
/* â–¼ æ­£ä½“ã‚«ãƒ¼ãƒ‰å…±é€šï¼šå¤§ãã„ã‚«ãƒ¼ãƒ‰ï¼†ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ã‚’ data-role-type ã§æãåˆ†ã‘ã‚‹ */

/* å…±é€šã§ç”»åƒã‚’çœŸã‚“ä¸­ã«è¡¨ç¤º */
.role-card,
.player-tag-role-mini{
  background-position:center;
  background-size:contain;
  background-repeat:no-repeat;
}

/* å…‰ï¼šé»’ãƒ•ãƒï¼‹ç™½å¡—ã‚Šï¼‹whitehat.png */
.role-card[data-role-type="LIGHT"],
.player-tag-role-mini[data-role-type="LIGHT"]{
  background-color:#fff;
  border-color:#000;
  background-image:url('whitehat.png');
}

/* å½±ï¼šå…¨é¢é»’ï¼‹blackhat.pngï¼ˆLIGHT ä»¥å¤–ã¯å…¨éƒ¨å½±ã¨ã—ã¦æ‰±ã†ï¼‰ */
.role-card:not([data-role-type="LIGHT"]),
.player-tag-role-mini:not([data-role-type="LIGHT"]){
  background-color:#000;
  border-color:#000;
  background-image:url('blackhat.png');
}

/* å½±ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼šå…¨é¢çœŸã£é»’ï¼‹é»’ç¸ */
.player-tag-role-mini[data-role-type="DARK"],
.player-tag-role-mini[data-role-type="SHADOW"]{
  background:#000;
  border-color:#000;
}

/* å…‰ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼šç™½å¡—ã‚Šï¼‹é»’æ·µ */
.player-tag-role-mini[data-role-type="LIGHT"]{
  background:#fff;
  border:1px solid #000;
}

/* ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ã®ä¸­å¤®ã«å¸½å­ã‚¢ã‚¤ã‚³ãƒ³ */
.player-tag-role-mini::before{
  content:'';
  position:absolute;
  inset:4px;
  background-position:center;
  background-repeat:no-repeat;
  background-size:contain;
}

/* å½±ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ã¯ blackhat.png */
.player-tag-role-mini[data-role-type="DARK"]::before,
.player-tag-role-mini[data-role-type="SHADOW"]::before{
  background-image:url('blackhat.png');
}

/* å…‰ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ã¯ whitehat.png */
.player-tag-role-mini[data-role-type="LIGHT"]::before{
  background-image:url('whitehat.png');
}
/* â˜… èƒ½åŠ›ãƒŸãƒ‹ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼ˆæ­£ä½“å…¬é–‹ã‚«ãƒ¼ãƒ‰ã¨åŒã˜æ§˜å¼ãƒ»ã‚µã‚¤ã‚ºï¼‰ */
.player-tag-ability-mini{
  position:absolute;
  top:50%;
  left:50%;
  width:28px;
  height:40px;
  border-radius:4px;
  border:1px solid #ddd;
  background:#fff;
  font-size:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
  pointer-events:auto;
  cursor:pointer;
  overflow:hidden; /* ä¸­ã®ã‚«ãƒ¼ãƒ‰ã‚’ç¸®å°ã—ã¦å…¥ã‚Œã‚‹ */
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ãŒå³å´ã«ã‚ã‚‹ã¨ãï¼šã‚¿ã‚° â†’ èƒ½åŠ› â†’ æ­£ä½“ â†’ ã‚­ãƒ¥ãƒ¼ãƒ– */
.player-tag.side-right .player-tag-ability-mini{
  left:100%;
  transform:translate(8px, -50%);
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ãŒå·¦å´ã«ã‚ã‚‹ã¨ãï¼šã‚­ãƒ¥ãƒ¼ãƒ– â†’ æ­£ä½“ â†’ èƒ½åŠ› â†’ ã‚¿ã‚° */
.player-tag.side-left .player-tag-ability-mini{
  left:0;
  transform:translate(-32px, -50%);
}

/* èƒ½åŠ›ãƒŸãƒ‹ãƒŸãƒ‹ã®ä¸­ã«ã¯ã€é€šå¸¸ã® ability-mini-card ã‚’ç¸®å°ã—ã¦å…¥ã‚Œã‚‹ */
.player-tag-ability-mini .ability-mini-card{
  width:60px;
  height:90px;
  border-radius:8px;
  border:none;
  box-shadow:none;
  padding:6px;
  transform:scale(0.45);
  transform-origin:center center;
  cursor:default;
}

/* ğŸ”¹ ãƒãƒ¼ãƒ ã‚¿ã‚°ãŒå††ã®å³å´ã«ã‚ã‚‹ã¨ã
/* èƒ½åŠ›ãƒŸãƒ‹ã®ã•ã‚‰ã«å¤–å´ã«æ­£ä½“å…¬é–‹ã‚«ãƒ¼ãƒ‰ã‚’ç½®ã */
.player-tag.side-right .player-tag-role-mini{
  left:100%;
  transform:translate(40px, -50%); /* 8pxï¼ˆèƒ½åŠ›ï¼‰ï¼‹ç´„ã‚«ãƒ¼ãƒ‰å¹…ã¶ã‚“ */
}

.player-tag.side-left .player-tag-role-mini{
  left:0;
  transform:translate(-64px, -50%); /* èƒ½åŠ›åˆ†ã ã‘ã•ã‚‰ã«å¤–ã¸ */
}



/* â˜… ãƒãƒ¼ãƒ ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã¾ã‚ã‚Šã®ç‚¹ç·šå††ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼ä¸è¦ãªã‚‰ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã”ã¨å‰Šé™¤ï¼‰ */
.player-tag::before{
  content:'';
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:70px;      /* å††ã®å¤§ãã•ï¼šå¿…è¦ãªã‚‰ã“ã“ã‚’å¤‰ãˆã‚‹ */
  height:70px;     /* å††ã®å¤§ãã•ï¼šå¿…è¦ãªã‚‰ã“ã“ã‚’å¤‰ãˆã‚‹ */
  border-radius:50%;
  border:1px dashed rgba(0,0,0,.25);
  pointer-events:none;
  border:none;            /* â† ã“ã“ã ã‘å¤‰æ›´ï¼ˆã¾ãŸã¯å‰Šé™¤ï¼‰ */
}

.player-tag.me{
font-weight:700;
}

/* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ */
.player-tag .mini-hand{
  position:absolute;
  left:50%;
  top:100%;
  transform:translate(-50%,3px);
  width:60px;
  height:30px;
  pointer-events:none;
}
.player-tag .mini-card{
  position:absolute;
  left:50%;
  top:0;
  width:16px;
  height:22px;
  border-radius:4px;
  border:1px solid #bbb;
  background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
  font-size:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  transform-origin:bottom center;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
}

/* â˜… è‡ªåˆ†ã®æ­£ä½“ã‚’è¦‹ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã€ŒğŸ‘€ã€ã‚¢ã‚¤ã‚³ãƒ³ */
.player-tag .peek-eye{
  position:absolute;
  left:50%;
  bottom:100%;          /* ã‚¿ã‚°ã®ã¡ã‚‡ã†ã©ä¸Š */
  transform:translate(-50%,-4px);
  font-size:16px;
  pointer-events:none;
  z-index:5;
}


/* â˜… ãƒãƒ¼ãƒ ã‚¿ã‚°ã¾ã‚ã‚Šã®èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ï¼ˆå·¦å³ã§ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’å¤‰ãˆã‚‹ï¼‰ */
.attached-cube-row{
  position:absolute;
  top:50%;
  display:flex;
  align-items:center;
  gap:0;
}

/* â–¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼å…¬é–‹å‰ï¼ˆç‹­ã„é…ç½®ï¼ãƒãƒ¼ãƒ ãƒ—ãƒ¬ãƒ¼ãƒˆã®å¤–å´ã«ãšã‚‰ã™ï¼‰ */
.player-tag.side-right .attached-cube-row{
  left:100%;
  /* -20px â†’ +12px ã«ã—ã¦ã€ã‚¿ã‚°ã®å³å¤–ã«é…ç½® */
  transform:translate(25px, -95%);
  gap:4px;
}
.player-tag.side-left .attached-cube-row{
  left:0;
  /* +20px â†’ -12px ã«ã—ã¦ã€ã‚¿ã‚°ã®å·¦å¤–ã«é…ç½® */
  transform:translate(calc(10% - 35px), -95%);
  gap:4px;
}

/* â–¼å…¬é–‹å¾Œ or å€‹äººçš„å…¬é–‹ï¼šæ­£ä½“ã‚«ãƒ¼ãƒ‰ãŒæ¨ªã«ã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’åºƒãã™ã‚‹ */
.player-tag.role-with-card.side-right .attached-cube-row{
  transform:translate(25px, -95%);
}
.player-tag.role-with-card.side-left .attached-cube-row{
  transform:translate(calc(10% - 35px), -95%);
}





.player-tag.side-right .attached-cube{
  margin-left:-54px;  
}


.player-tag.side-left .attached-cube{
  margin-left:-54px;  
}


.attached-cube{
  width:72px;
  height:72px;
  flex:0 0 auto;
  cursor:grab;
  position:relative;
}

.attached-cube svg{
  width:100%;
  height:100%;
  display:block;
}
.attached-cube.dragging{
  cursor:grabbing;
}

/* â˜… æ­£ä½“ã‚«ãƒ¼ãƒ‰å°‚ç”¨ã®è¦‹ãŸç›®ï¼ˆå¤§ãã„ã‚«ãƒ¼ãƒ‰ï¼‰ */
.role-card{
  position:relative;
  overflow:hidden;
}

/* æ­£ä½“ã‚«ãƒ¼ãƒ‰å†…ã®ãƒ†ã‚­ã‚¹ãƒˆã¯éè¡¨ç¤ºï¼ˆã€Œå…‰ã€ã€Œå½±ã€ã®æ–‡å­—ã‚’æ¶ˆã™ï¼‰ */
.role-card .card-timing,
.role-card .card-text{
  display:none;
}

/* å½±ã‚«ãƒ¼ãƒ‰ï¼šå…¨é¢çœŸã£é»’ï¼‹é»’ç¸ */
.role-card[data-role-type="DARK"],
.role-card[data-role-type="SHADOW"]{
  background:#000;
  border-color:#000;
}

/* å…‰ã‚«ãƒ¼ãƒ‰ï¼šç™½å¡—ã‚Šï¼‹é»’æ·µ */
.role-card[data-role-type="LIGHT"]{
  background:#fff;
  border:2px solid #000;
}

/* ä¸­å¤®ã«å¸½å­ã‚¢ã‚¤ã‚³ãƒ³ç”»åƒã‚’é…ç½® */
.role-card::before{
  content:'';
  position:absolute;
  inset:8px;
  background-position:center;
  background-repeat:no-repeat;
  background-size:contain;
}

/* å½±ã‚«ãƒ¼ãƒ‰ç”¨ï¼šblackhat.png */
.role-card[data-role-type="DARK"]::before,
.role-card[data-role-type="SHADOW"]::before{
  background-image:url('blackhat.png');
}

/* å…‰ã‚«ãƒ¼ãƒ‰ç”¨ï¼šwhitehat.png */
.role-card[data-role-type="LIGHT"]::before{
  background-image:url('whitehat.png');
}

.my-hand-wrapper{
  margin-top:16px;
  text-align:center;
}
.my-hand-title{
  font-size:12px;
  opacity:.7;
}

/* â˜… æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼‹æ‰‹æœ­ã‚’æ¨ªä¸¦ã³ã«ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ */
.my-hand-row{
  display:grid;
  /* 3åˆ—ã‚°ãƒªãƒƒãƒ‰ï¼ˆçœŸã‚“ä¸­ã¯æ‰‹æœ­ã®ä¸­å¿ƒç”¨ã®ç©ºãã€ã¿ãŸã„ãªã‚¤ãƒ¡ãƒ¼ã‚¸ï¼‰ */
  grid-template-columns:auto auto auto;
  grid-auto-rows:auto;
  justify-content:center;
  column-gap:8px;
  row-gap:6px;
  margin-top:6px;
}
/* 1æ®µç›®ï¼šæ‰‹æœ­ã¯1ã€œ3åˆ—ã‚’å…¨éƒ¨ä½¿ã£ã¦æ¨ªã«ä¸¦ã¶ */
.my-hand-row #myHand{
  grid-column:1 / 4;  /* 1åˆ—ç›®ã€œ3åˆ—ç›®ã¾ã§ */
}

/* 2æ®µç›®ï¼šå·¦ã«èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ã€å³ã«æ­£ä½“ã‚«ãƒ¼ãƒ‰ */
.my-hand-row #myAbilitySlot{
  grid-column:1;
}

.my-hand-row #myRoleSlot{
  grid-column:3;
}


/* â˜… æ­£ä½“ã‚«ãƒ¼ãƒ‰ç”¨ã‚¹ãƒ­ãƒƒãƒˆï¼ˆã‚µã‚¤ã‚ºã¯ä»–ã‚«ãƒ¼ãƒ‰ã¨åŒã˜ï¼‰ */
.my-role-slot{
  width:60px;
  height:90px;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* æ—¢å­˜ã®æ‰‹æœ­ */
.my-hand{
  display:flex;
  justify-content:center;
  gap:8px;
  min-height:100px;
}


/* å±±æœ­ï¼‹æ¨ã¦æœ­ï¼‹ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ã®æ¨ªä¸¦ã³ */
.deck-row{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  margin:8px auto 0;
}
/* â˜… å±±æœ­ã®å·¦ã«ç½®ãæ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ç”¨ */
.role-center{
  display:flex;
  flex-direction:column;
  align-items:center;
  width:60px;
}
.role-center-slot{
  width:60px;
  height:90px;
  display:flex;
  align-items:center;
  justify-content:center;
}


.deck-pile,
.discard-pile,
.used-pile{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
  width:60px;
}
.deck-pile{
  position:relative;
}
.deck-stack{
  position:relative;
  width:60px;
  height:90px;
}
.deck-card-layer{
  position:absolute;
  left:0;
  top:0;
  width:60px;
  height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background:linear-gradient(135deg,#1f2937,#4b5563);
  box-shadow:0 4px 12px rgba(0,0,0,.22);
  transform:translateY(var(--offset,0px));
}

/* æ¨ã¦æœ­ */
.discard-stack{
  position:relative;
  width:60px;
  height:90px;
}
.discard-card-layer{
  position:absolute;
  left:0;
  top:0;
  transform:translateY(var(--offset,0px));
}

/* â˜… é™¤å¤–æœ­ç½®ãå ´ï¼ˆæ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å³ãƒ»å±±æœ­ã®å·¦ï¼‰ */
.exile-pile{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
  width:60px;
}
.exile-stack{
  position:relative;
  width:60px;
  height:90px;
}
/* â˜… é™¤å¤–æœ­ç½®ãå ´ï¼ˆæ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å³ãƒ»å±±æœ­ã®å·¦ï¼‰ */
.exile-card-layer{
  position:absolute;
  left:0;
  top:0;
  transform:translateY(var(--offset,0px));
}


/* â˜… è‡ªåˆ†ã®ãƒãƒ¼ãƒ ã‚¿ã‚°å°‚ç”¨ã®èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ä½ç½®ï¼ˆã‚¿ã‚°ã®çœŸä¸‹ã«æ¨ªä¸€åˆ—ï¼‰ */
.player-tag.me .attached-cube-row{
  top:50px;              /* ã‚¿ã‚°ã®ä¸‹ç«¯ */
  left:97px;              /* ã‚¿ã‚°ä¸­å¤® */
  gap:4px;               /* ã‚­ãƒ¥ãƒ¼ãƒ–åŒå£«ã®é–“éš” */
}

/* å¿…è¦ãªã‚‰ã€å€‹äººçš„å…¬é–‹ãƒ»æ­£ä½“å…¬é–‹å¾Œã‚‚åŒã˜ä½ç½®ã®ã¾ã¾ã«ã™ã‚‹ */
.player-tag.me.role-with-card .attached-cube-row{
  top:50px;
  left:127px;
}



/* ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ */
.used-cards-area{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  margin:0;
  min-height:90px;
  width:60px;
}
/* ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ï¼‹åå‰ãƒ©ãƒ™ãƒ«ç”¨ã‚³ãƒ³ãƒ†ãƒŠ */
.used-card-wrapper{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
}

/* ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ã®ä¸Šã«å‡ºã™ã€Œå‡ºã—ãŸäººã®ãƒãƒ¼ãƒ ã‚¿ã‚°ã€ */
.used-card-owner{
  font-size:11px;
  padding:2px 8px;
  border-radius:999px;
  background:#111;
  color:#fff;
  white-space:nowrap;
}

/* å„ç¨®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼ˆè¿½ã„å‡ºã—ç¢ºèªï¼‰ */
.dialog-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.35);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:300;
}
.dialog-backdrop.hidden{
  display:none;
}
.dialog-box{
  background:#fff;
  border-radius:12px;
  padding:16px 18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  max-width:320px;
  width:calc(100% - 40px);
}
.dialog-box p{
  margin:0 0 12px;
  font-size:14px;
  line-height:1.6;
}
.dialog-buttons{
  display:flex;
  justify-content:flex-end;
  gap:8px;
}

/* æ‰‹æœ­ä½¿ç”¨ãƒãƒƒãƒ—ï¼ˆã€Œä½¿ã†ã€ãƒœã‚¿ãƒ³ã ã‘ï¼‰ */
.use-card-pop{
  position:fixed;
  padding:0;
  border:none;
  background:transparent;
  box-shadow:none;
  display:block;
  z-index:270;
}
.use-card-pop.hidden{
  display:none;
}
.use-card-pop .btn{
  padding:4px 14px;
  font-size:12px;
}

/* ãƒ›ã‚¹ãƒˆç”¨ è¨­å®šãƒœã‚¿ãƒ³ï¼ˆå³ä¸‹ï¼‰ */
.host-settings-btn{
  position:fixed;
  right:16px;
  bottom:16px;
  width:44px;
  height:44px;
  border-radius:50%;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 8px 20px rgba(0,0,0,.18);
  display:none;
  align-items:center;
  justify-content:center;
  font-size:22px;
  cursor:pointer;
  z-index:230;
}
.host-settings-btn.visible{
  display:flex;
}

/* ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒƒãƒ—ï¼ˆå³ä¸‹ï¼‰ */
.start-pop{
  position:fixed;
  right:16px;
  bottom:72px;
  background:#fff;
  border:1px solid #ddd;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.16);
  padding:10px 12px;
  z-index:240;
  min-width:240px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.start-pop.hidden{
  display:none;
}
.start-pop-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
}
.start-pop-title{
  font-size:14px;
  font-weight:600;
}
.start-pop-main{
  font-size:13px;
  line-height:1.5;
}
.start-pop-actions{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  margin-top:4px;
}

/* ã‚µã‚¤ã‚³ãƒ­ã‚¨ãƒªã‚¢ï¼ˆå††ã®ä¸­ï¼‰ */
.dice-area{
  position:absolute;
  left:50%;
  top:50%;
  width:260px;
  height:260px;
  transform:translate(-50%,-50%);
  border-radius:50%;
  background:transparent;
  border:none;
  box-shadow:none;
  pointer-events:none;
}
.dice{
  position:absolute;
  left:50%;
  top:50%;
  width:46px;
  height:46px;
  border-radius:10px;
  border:1px solid #ddd;
  background:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 4px 12px rgba(0,0,0,.18);
  cursor:grab;
  touch-action:none;
  pointer-events:auto;
  --tx:0px;
  --ty:0px;
  --rot:0deg;
  transform:translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) rotate(var(--rot));
  transition:transform .14s ease-out, box-shadow .14s ease-out;
}
.dice.dragging{
  cursor:grabbing;
  box-shadow:0 8px 20px rgba(0,0,0,.28);
  transition:none;
}
.dice.rolling{
  transition:transform .5s cubic-bezier(.22,.84,.44,1.1);
}
.dice.dice-locked{
  pointer-events:none;
}
.dice-face{
  position:relative;
  width:100%;
  height:100%;
}
.pip{
  position:absolute;
  width:9px;
  height:9px;
  border-radius:50%;
  background:#111;
  opacity:0;
  transition:opacity .12s;
  transform:translate(-50%, -50%);
}
.pip.red{
  background:#dc2626;
}
.pip.pos0{ left:25%; top:25%; }
.pip.pos1{ left:75%; top:25%; }
.pip.pos2{ left:25%; top:50%; }
.pip.pos3{ left:50%; top:50%; }
.pip.pos4{ left:75%; top:50%; }
.pip.pos5{ left:25%; top:75%; }
.pip.pos6{ left:75%; top:75%; }

/* å¤§å¤–ã®å†† */
.player-circle::after{
  content:'';
  position:absolute;
  left:50%;
  top:50%;
  width:500px;
  height:500px;
  transform:translate(-50%,-50%);
  border-radius:50%;
  border:none;
  box-sizing:border-box;
  pointer-events:none;
}

/* ãƒ­ãƒ“ãƒ¼ã®è¦‹ãŸç›®èª¿æ•´ */
.player-circle{border:none;}
.player-circle::before{content:'';}
.my-hand-title{display:none;}
#roomInfoLobby,
#lobby h2,
#lobby p {display:none;}
#lobby.entered {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:flex-start;   /* â˜… center â†’ flex-start ã«å¤‰æ›´ã—ã¦ä¸Šå¯„ã› */
  min-height:calc(100vh - 60px);
  padding-top:16px;             /* â˜… å°‘ã—ã ã‘ä¸Šã«ä½™ç™½ã¤ã‘ã‚‹ï¼ˆãŠå¥½ã¿ã§èª¿æ•´å¯ï¼‰ */
}

/* ã‚µã‚¤ã‚³ãƒ­å‡ºç›®èª¿æ•´ãƒãƒƒãƒ— */
.dice-adjust-pop{
  position:fixed;
  padding:6px 8px;
  border-radius:999px;
  background:#fff;
  border:1px solid #ddd;
  box-shadow:0 8px 18px rgba(0,0,0,.2);
  display:flex;
  gap:4px;
  z-index:260;
}
.dice-adjust-pop.hidden{
  display:none;
}
.dice-adjust-pop button{
  min-width:32px;
  padding:2px 6px;
  border-radius:999px;
  border:1px solid #ddd;
  background:#f8f8f8;
  font-size:12px;
  cursor:pointer;
}

/* å±±æœ­é…å¸ƒãƒãƒƒãƒ— */
.deck-deal-pop{
  position:fixed;
  padding:6px 8px;
  border-radius:8px;
  background:#fff;
  border:1px solid #ddd;
  box-shadow:0 8px 18px rgba(0,0,0,.2);
  z-index:260;
}
.deck-deal-pop.hidden{
  display:none;
}
.deck-deal-pop .btn{
  font-size:12px;
  padding:4px 10px;
}

/* â–·ãƒœã‚¿ãƒ³ï¼ˆã‚¿ãƒ¼ãƒ³é€ã‚Šï¼‰ */
.turn-next-btn{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  width:64px;
  height:64px;
  padding:0;
  border-radius:50%;
  border:1px solid #111;
  background:#111;
  color:#fff;
  font-size:32px;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  box-shadow:0 8px 20px rgba(0,0,0,.3);
  z-index:235;
}
.turn-next-btn.hidden{
  display:none;
}

/* ã€Œâ—‹â—‹ã®ã‚¿ãƒ¼ãƒ³ã€ãƒãƒŠãƒ¼ */
.turn-banner{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-150%, -50%);
  background:#111;
  color:#fff;
  padding:10px 24px;
  border-radius:999px;
  font-size:20px;
  font-weight:700;
  box-shadow:0 10px 24px rgba(0,0,0,.3);
  white-space:nowrap;
  z-index:260;
  transition:transform .6s cubic-bezier(.22,.84,.44,1);
}
.turn-banner.turn-banner-center{
  transform:translate(-50%, -50%);
}
.turn-banner.turn-banner-right{
  transform:translate(150%, -50%);
}

/* â˜… ãƒãƒ¼ãƒ ã‚¿ã‚°é¸æŠç³»ãƒãƒƒãƒ—ï¼ˆæ­£ä½“ã‚’è¦‹ã‚‹ï¼è¦‹ã›ã‚‹ï¼3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼æ¸¡ã™ç›¸æ‰‹é¸æŠï¼‰
   â†’ å…¨ä½“ é»’èƒŒæ™¯ãƒ»ç™½å­—ã«çµ±ä¸€ */
.turn-select-pop{
  position:fixed;
  left:50%;
  bottom:90px;
  transform:translateX(-50%);
  background:rgba(0,0,0,.9);
  color:#fff;
  border:none;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.6);
  padding:10px 14px;
  z-index:290;
  min-width:220px;
  max-width:280px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.turn-select-pop.hidden{
  display:none;
}

.turn-select-header{
  font-size:13px;
  font-weight:600;
  color:#fff;
}

.turn-select-list{
  display:flex;
  flex-direction:column;
  gap:6px;
  max-height:200px;
  overflow-y:auto;
}

/* â˜… ã“ã®ãƒãƒƒãƒ—å†…ã®ãƒœã‚¿ãƒ³ã‚‚é»’èƒŒæ™¯ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ«ã«ä¸Šæ›¸ã */
.turn-select-pop .btn{
  width:100%;
  justify-content:flex-start;
  font-size:13px;
  padding:4px 8px;
  background:transparent;
  border:1px solid rgba(255,255,255,.7);
  color:#fff;
}
.turn-select-pop .btn.primary{
  background:rgba(255,255,255,.16);
  border-color:#fff;
  color:#fff;
}
.turn-select-pop .btn.ghost{
  background:transparent;
  border-color:rgba(255,255,255,.4);
  color:#fff;
}
.turn-select-pop .btn:hover{
  background:rgba(255,255,255,.20);
}


/* â˜… ã€Œã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãã€1æšã‚’æ¸¡ã™ã€ç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
.give2-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:280;
}
.give2-overlay.hidden{
  display:none;
}
.give2-backdrop{
  position:absolute;
  inset:0;
  background:rgba(0,0,0,.35);
}
.give2-panel{
  position:relative;
  background:#fff;
  border-radius:16px;
  padding:14px 18px;
  box-shadow:0 20px 45px rgba(0,0,0,.38);
  display:flex;
  flex-direction:column;
  gap:10px;
  align-items:center;
  min-width:260px;
}
.give2-hint{
  font-size:13px;
  text-align:center;
}
.give2-cards{
  display:flex;
  gap:18px;
}

/* ä¸­å¤®2æšã®ã‚«ãƒ¼ãƒ‰ */
.give2-card{
  cursor:pointer;
  /* ãƒ‰ãƒ©ãƒƒã‚°ã§å¤–ã«é£›ã³å‡ºã—ã¦ã‚‚è¦‹ãˆã‚‹ã‚ˆã†ã« */
  position:relative;

}

/* è‡ªåˆ†ãŒã€Œã»ã—ã„ã‚«ãƒ¼ãƒ‰ã€ã¨ã—ã¦é¸ã‚“ã æ–¹ã‚’è»½ãæµ®ã‹ã›ã‚‹ */
.give2-card.selected{
  /* transform ã¯ JS å´ã§åˆ¶å¾¡ã™ã‚‹ã®ã§ã“ã“ã§ã¯å½±ã ã‘ */
  box-shadow:0 6px 18px rgba(0,0,0,.25);
}

/* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®è¦‹ãŸç›® */
.give2-card.dragging{
  cursor:grabbing;
  box-shadow:0 8px 24px rgba(0,0,0,.35);
}

/* â˜… ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­å¤®ã«æ®‹ã‚Š1æšã‚’ç½®ããŸã‚ã®ã‚³ãƒ³ãƒ†ãƒŠ */
.give2-center-card{
  position:fixed;
  z-index:281;
  transform:translate(-50%,-50%);
}
.give2-overlay,
.give2-panel,
.give2-card{
  touch-action:none;
}


/* â˜…â˜…â˜… ã“ã“ã‹ã‚‰å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ â˜…â˜…â˜… */
.cube-circle{
  position:fixed;
  left:30%;
  top:80px;
  width:20px;
  height:20px;
  border-radius:50%;
  background:transparent; /* å††ã¯ä¸å¯è¦– */
  border:none;
  pointer-events:none;
  z-index:210;
}
.cube-piece{
  position:absolute;
  left:50%;
  top:50%;
  width:72px;
  height:72px;
  --tx:0px;
  --ty:0px;
  transform:translate(calc(-50% + var(--tx)), calc(-50% + var(--ty)));
  cursor:grab;
  touch-action:none;
  pointer-events:auto;
}
.cube-piece.dragging{
  cursor:grabbing;
}
.cube-piece svg{
  width:100%;
  height:100%;
  display:block;
}


/* â˜… æ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ç”¨ã®è£é¢ãƒ‡ã‚¶ã‚¤ãƒ³ */
.center-role-card .card-back{
  width:100%;
  height:100%;
  border-radius:8px;
  background:linear-gradient(135deg,#1f2937,#4b5563);
}


/* â˜… å±±æœ­ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ */
@keyframes deckShuffle {
  0%   { transform: translateX(0) rotate(0deg); }
  20%  { transform: translateX(-8px) rotate(-3deg); }
  40%  { transform: translateX(8px)  rotate(3deg); }
  60%  { transform: translateX(-6px) rotate(-2deg); }
  80%  { transform: translateX(6px)  rotate(2deg); }
  100% { transform: translateX(0) rotate(0deg); }
}

.deck-stack.shuffle-anim{
  animation: deckShuffle 0.6s ease-in-out 0s 2;
  transform-origin:center center;
}

.card-error-bubble{
  position:absolute;
  max-width:260px;
  padding:8px 10px;
  font-size:12px;
  line-height:1.5;
  background:rgba(0,0,0,.9);
  color:#fff;
  border-radius:8px;
  box-shadow:0 8px 20px rgba(0,0,0,.35);
  z-index:300;              /* æ‰‹æœ­ã‚ˆã‚Šå‰é¢ã« */
  transform:translate(-50%,-100%);
  pointer-events:none;
  opacity:0;
  transition:opacity .18s ease-out, transform .18s ease-out;
}

.card-error-bubble.visible{
  opacity:1;
  transform:translate(-50%,-110%);
}

/* â–¼ ãƒãƒ¼ãƒ ã‚¿ã‚°æ¨ªã®è¶…ç¸®å°èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ã ã‘æ–‡å­—ã‚µã‚¤ã‚ºã‚’è£œæ­£ */
.player-tag-ability-mini .ability-name-tag{
  font-size:14px;   /* å…ƒã® 8px ã‚ˆã‚Šå¤§ãã‚ â†’ scale(0.45)ã•ã‚Œã¦ã‚‚èª­ã‚ã‚‹ã‚µã‚¤ã‚ºã« */
}

.player-tag-ability-mini .ability-detail-text{
  font-size:14px;    /* èª¬æ˜æ–‡ã‚‚å°‘ã—å¤§ãã‚ã«ï¼ˆãŠå¥½ã¿ã§èª¿æ•´ï¼‰ */
}


/* â˜… èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å·¦ï¼‰ */
.my-ability-slot{
  width:60px;
  height:90px;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* â˜… ãƒŸãƒ‹èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ï¼ˆè‡ªåˆ†ã®å‰ã«ä¸¦ã¶ç”¨ï¼‰ */
.ability-mini-card{
  width:60px;
  height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 4px 12px rgba(0,0,0,.18);
  box-sizing:border-box;
  padding:6px;
  cursor:pointer;
  display:flex;
  /* â–¼ ã“ã“ã‚’å¤‰æ›´ï¼šä¸­å¤®å¯„ã› â†’ ä¸Šå¯„ã› */
  align-items:flex-start;
  justify-content:flex-start;
}

/* â˜… èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ã®ä¸­èº«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
.ability-face{
  display:flex;
  flex-direction:column;
  align-items:center;
  /* â–¼ è¿½åŠ ï¼šç¸¦æ–¹å‘ã®ä¸Šå¯„ã›ï¼‹ã‚«ãƒ¼ãƒ‰ã„ã£ã±ã„ä½¿ã† */
  justify-content:flex-start;
  gap:4px;
  text-align:center;
  width:100%;
  height:100%;
}

/* â˜… æ‹¡å¤§ã‚«ãƒ¼ãƒ‰ã®èª¬æ˜ãƒ†ã‚­ã‚¹ãƒˆï¼ˆè¡Œé–“ã¤ã‚ã¦ä¸‹å¯„ã›æ°—å‘³ï¼‰ */
.ability-detail-text{
  width:100%;
  font-size:7px;
  line-height:1;     /* â† è¡Œé–“ã‚’è©°ã‚ã‚‹ */
  text-align:left;
  margin-top:auto;      /* â†‘ ä½™ã£ã¦ã„ã‚‹ã‚¹ãƒšãƒ¼ã‚¹ã‚’å…¨éƒ¨ã“ã“ã«æŠ¼ã—ã¤ã‘ã¦ä¸‹å¯„ã› */
}

/* â˜… ç´ºã®ã‚«ãƒ¼ãƒ‰åã‚¿ã‚°ï¼ˆç™½å­—ï¼‰ */
.ability-name-tag{
  padding:2px 8px;
  border-radius:999px;
  background:#1e3a8a; /* é’ã£ã½ã„ç´º */
  color:#fff;
  font-size:8px;
  line-height:1.4;
  white-space:nowrap;
}

/* â˜… å›³å½¢ã‚¨ãƒªã‚¢ï¼ˆãƒŸãƒ‹ï¼æ‹¡å¤§å…±é€šï¼‰ */
.ability-art-mini{
  width:35px;
  height:20px;
  position:relative;
}
.ability-art-large{
  width:80px;
  height:48px;
  position:relative;
}

/* ãƒ•ãƒä»˜ãã®ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰å›³å½¢ï¼ˆå…±é€šï¼‰ */
.ability-icon-card{
  position:absolute;
  border-radius:6px;
  border:1px solid #cbd5f5;
  background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
  box-shadow:0 1px 3px rgba(0,0,0,.18);
}

.ability-art-mini .ability-icon-card{
  width:28px;
  height:36px;
  left:50%;
  top:90%; /* â˜… 80% â†’ 40%ï¼šèƒ½åŠ›åã®ã™ãä¸‹ã‚ãŸã‚Š */
  transform:translate(-50%,-50%);
}

/* ğŸ”¹æ‹¡å¤§ã‚«ãƒ¼ãƒ‰ç”¨ï¼šå°‘ã—å¤§ãã‚ã®ã‚«ãƒ¼ãƒ‰ã‚’ä¸­å¤®ã‚ˆã‚Šå°‘ã—ä¸Šã« */
.ability-art-large .ability-icon-card{
  width:28px;
  height:36px;
  left:50%;
  top:38%; /* â˜… 50% â†’ 38%ï¼šã‚„ã‚„ä¸Šå¯„ã›ã« */
  transform:translate(-50%,-50%);
}
.deck-draw-hint{
  position:absolute;
 bottom:86px;  
  font-size:28px;
  line-height:1;
  text-align:center;
  user-select:none;
 color:#fff;    
  -webkit-text-stroke:1px #000;  /* é»’ã„ãƒ•ãƒï¼ˆChromeç³»OKï¼‰ */
    z-index:50;
}
.deck-draw-label{
  display:block;
  font-size:16px;      /* ï¼‹1ã¯å°‘ã—å°ã•ã‚ */
  line-height:1.1;
  margin-bottom:-2px;  /* â–¼ã¨ã®é–“ã‚’ã¡ã‚‡ã£ã¨ã ã‘è©°ã‚ã‚‹ */
}


/* ãƒŸãƒ‹ãƒ€ã‚¤ã‚¹å›³å½¢ */
.ability-icon-dice{
  position:absolute;
  width:16px;
  height:16px;
  border-radius:4px;
  border:1px solid #aaa;
  background:#fff;
  box-shadow:0 1px 3px rgba(0,0,0,.18);
}
.ability-icon-dice::before,
.ability-icon-dice::after{
  content:'';
  position:absolute;
  width:3px;
  height:3px;
  border-radius:50%;
  background:#111;
}
.ability-icon-dice::before{
  left:4px;top:4px;
}
.ability-icon-dice::after{
  right:4px;bottom:4px;
}
.ability-icon-dice-center{
  position:absolute;
  left:50%;top:50%;
  width:3px;height:3px;
  border-radius:50%;
  background:#111;
  transform:translate(-50%,-50%);
}

/* THEYâ’â’â’ / YOUâ’â†’ ç”¨ã®å°ã•ã„èµ¤å››è§’ */
.ability-square-row{
  display:flex;
  gap:2px;
  justify-content:center;
  font-size:8px;
}
.ability-square{
  width:6px;
  height:8px;
  border-radius:2px;
  border:1px solid #b91c1c;
  background:#fee2e2;
}
/* â˜… èƒ½åŠ›ã‚«ãƒ¼ãƒ‰æ‹¡å¤§ãƒãƒƒãƒ— */
.ability-overlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.45);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:310;
}
.ability-overlay.hidden{
  display:none;
}

/* å†…å´ãƒ©ãƒƒãƒ‘ã¯ãŸã ã®ã‚»ãƒ³ã‚¿ãƒ¼ç”¨ */
.ability-overlay-inner{
  background:transparent;
  border-radius:0;
  padding:0;
  box-shadow:none;
}

/* â˜… æ‹¡å¤§ã‚«ãƒ¼ãƒ‰å…¨ä½“ï¼ˆä¸­ã«ã€Œæ‹¡å¤§ã—ãŸãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼‹èª¬æ˜æ–‡ã€ãŒå…¥ã‚‹ï¼‰ */
.ability-card-large{
  background:#fff;
  border-radius:12px;
  padding:10px 14px 14px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  max-width:220px;

  /* â–¼ ä¸­èº«ã‚’ä¸Šä¸‹ã«æŒ¯ã‚Šåˆ†ã‘ã‚‹ï¼šä¸Šï¼ã‚«ãƒ¼ãƒ‰ã€ä¸‹ï¼ãƒ†ã‚­ã‚¹ãƒˆ */
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:space-between;  /* â† ã“ã‚Œã§ä¸‹å¯„ã› */
  gap:4px;
  min-height:220px;               /* â† å°‘ã—é«˜ã•ã‚’ç¢ºä¿ã—ã¦ä¸‹ã«è½ã¨ã™ */
}



/* â˜… ä¸Šéƒ¨ï¼šãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾ä½¿ã„ã€scaleã§æ‹¡å¤§ã™ã‚‹ãƒ˜ãƒƒãƒ€ãƒ¼ */
.ability-card-large-header{
  width:60px;
  height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 4px 12px rgba(0,0,0,.18);
  box-sizing:border-box;
  padding:6px;
  display:flex;
  align-items:flex-start;
  justify-content:flex-start;
  /* ãƒŸãƒ‹ã¨æ¯”ç‡ãƒ»ä½ç½®ã‚’å®Œå…¨ã«ä¸€è‡´ã•ã›ãŸã¾ã¾æ‹¡å¤§ */
  transform:scale(1.6);
  transform-origin:top center;
}

/* ä¸­èº«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯ãƒŸãƒ‹ã¨åŒã˜ .ability-face ã‚’ãã®ã¾ã¾ä½¿ã† */
.ability-card-large-header .ability-face{
  width:100%;
  height:100%;
}

/* â˜… èª¬æ˜æ–‡ï¼ˆæ‹¡*

/* â˜… æ‹¡å¤§ã‚«ãƒ¼ãƒ‰å†…ã®å›³å½¢ã ã‘ 70% ã«ç¸®å°ï¼†å°‘ã—ä¸‹ã’ã‚‹ */
.ability-card-large-header .ability-art-mini,
.ability-card-large-header .ability-art-large{
  transform: translateY(-2px) scale(0.8);
  transform-origin: top center;
}


/* â˜…â˜…â˜… å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ ã“ã“ã¾ã§ â˜…â˜…â˜… */
</style>
</head>
<body>

<header>
  <h1>ãƒ†ãƒ³ãƒ—ãƒ¬</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">ãƒªãƒ³ã‚¯ã‚³ãƒ”ãƒ¼</button>
  </div>
</header>

<main>
<div class="join-box" id="joinBox">
  <input id="userName" placeholder="åå‰ï¼ˆ4æ–‡å­—ä»¥å†…ï¼‰" maxlength="4" />
  <input id="roomCode" placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ï¼ˆæœªå…¥åŠ›ã§è‡ªå‹•ç”Ÿæˆï¼‰" maxlength="12" />
  <button class="btn primary" id="btnJoin">å…¥å®¤</button>
</div>

<div id="lobby" class="hidden">
  <h2>ãƒ­ãƒ“ãƒ¼</h2>
  <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
  <p>ã“ã“ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚„æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

<!-- å±±æœ­ï¼‹æ¨ã¦æœ­ï¼‹ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ -->
<div class="deck-row">
  <!-- â˜… æ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ç½®ãå ´ï¼ˆå±±æœ­ã®å·¦ï¼‰ -->
  <div class="role-center">
    <div id="roleCenterSlot" class="role-center-slot"></div>
  </div>

  <!-- â˜… é™¤å¤–æœ­ç½®ãå ´ï¼ˆæ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å³ãƒ»å±±æœ­ã®å·¦ï¼‰ -->
  <div class="exile-pile">
    <div id="exileStack" class="exile-stack"></div>
  </div>

<div class="deck-pile">
  <!-- â˜… è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³æ™‚ã«å‡ºã™ã€Œå¼•ã‘ã‚‹ã‚ˆã€ãƒãƒ¼ã‚«ãƒ¼ -->
<div id="deckDrawHint" class="deck-draw-hint hidden">
  <span class="deck-draw-label">ï¼‹1</span>
  â–¼
</div>
  <div id="deckStack" class="deck-stack"></div>
</div>

  <div class="discard-pile">
    <div id="discardStack" class="discard-stack"></div>
  </div>
  <div class="used-pile">
    <div id="usedCardsArea" class="used-cards-area"></div>
  </div>
</div>


<!-- â–¼ã€Œã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãã€ã†ã¡1æšã¯èª°ã‹ã«æ¸¡ã™ã€ç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
<div id="give2Overlay" class="give2-overlay hidden">
  <div class="give2-backdrop"></div>
  <div class="give2-panel">
    <!-- â˜…ã“ã“ã‚’å¤‰æ›´ -->
    <div id="give2Hint" class="give2-hint">
      ã»ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è‡ªåˆ†ã«ã‚ˆã›ã‚‹ã€‚ã‚ã’ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é•·æŠ¼ã—ã™ã‚‹
    </div>
    <div id="give2Cards" class="give2-cards"></div>
  </div>
</div>


  <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å†† -->
  <div id="playerCircle" class="player-circle"></div>

<!-- è‡ªåˆ†ã®æ‰‹æœ­ -->
<div class="my-hand-wrapper">
  <div class="my-hand-title">è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰</div>

  <!-- 1æ®µç›®ï¼šæ‰‹æœ­ï¼ˆä¸­å¤®å¯„ã›ï¼‰ -->
  <div class="my-hand-row my-hand-row-top">
    <div id="myHand" class="my-hand"></div>
  </div>

  <!-- 2æ®µç›®ï¼šæ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼‹èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ï¼ˆä¸­å¤®å¯„ã›ï¼‰ -->
  <div class="my-hand-row my-hand-row-bottom">
    <div id="myAbilitySlot" class="my-ability-slot"></div>
    <div id="myRoleSlot" class="my-role-slot"></div>
  </div>

<!-- â˜… èƒ½åŠ›ã‚«ãƒ¼ãƒ‰æ‹¡å¤§è¡¨ç¤ºãƒãƒƒãƒ— -->
<div id="abilityOverlay" class="ability-overlay hidden">
  <div class="ability-overlay-inner">
    <div id="abilityOverlayCard"></div>
  </div>
</div>


</div>
</div>
</main>

<!-- ç€å¸­ãƒãƒƒãƒ— -->
<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>å¸­ã‚’é¸æŠ</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">è¦³æˆ¦</button>
  </div>
</div>

<!-- â˜… ã“ã“ã‚’è¿½åŠ ï¼šäººæ•°å¾…ã¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ -->
<div id="waitMaxPlayersMessage" class="wait-max-players-msg hidden">
  ãƒ›ã‚¹ãƒˆãŒäººæ•°ã‚’é¸æŠä¸­ã§ã™ã€‚
</div>

<!-- è¿½ã„å‡ºã—ç¢ºèªãƒãƒƒãƒ— -->
<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">æ—¢å­˜ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„å‡ºã—ã¦ã€ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">ã„ã„ãˆ</button>
      <button class="btn primary" id="btnKickYes">ã¯ã„</button>
    </div>
  </div>
</div>

<!-- ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ã‚¨ãƒ©ãƒ¼ãƒãƒ–ãƒ« -->
<div id="cardErrorBubble" class="card-error-bubble hidden">
  æ­£ä½“ã‚’å…¬é–‹ã—ã¦ã„ãªã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ3äººä»¥ä¸Šã„ãªã„ãŸã‚ã€ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ä½¿ãˆã¾ã›ã‚“ã€‚
</div>


<!-- æ‰‹æœ­ä½¿ç”¨ãƒãƒƒãƒ—ï¼ˆã‚¯ãƒªãƒƒã‚¯ä½ç½®ã«ã€Œä½¿ã†ã€ã ã‘ï¼‰ -->
<div id="useCardDialog" class="use-card-pop hidden">
  <button class="btn primary" id="btnUseCardYes">ä½¿ã†</button>
</div>

<!-- ã‚µã‚¤ã‚³ãƒ­å‡ºç›®èª¿æ•´ãƒãƒƒãƒ— -->
<div id="diceAdjustPop" class="dice-adjust-pop hidden">
  <button data-value="1">1</button>
  <button data-value="2">2</button>
  <button data-value="3">3</button>
  <button data-value="4">4</button>
  <button data-value="5">5</button>
  <button data-value="6">6</button>
</div>

<!-- å±±æœ­é…å¸ƒãƒãƒƒãƒ—ï¼ˆé•·æŠ¼ã—ã§è¡¨ç¤ºï¼‰ -->
<div id="deckDealPop" class="deck-deal-pop hidden">
  <button id="btnDeckDeal" class="btn primary">é…ã‚‹</button>
</div>

<!-- â˜… ã€Œ1æšæ¸¡ã™ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠãƒãƒƒãƒ— -->
<div id="give2TargetPop" class="turn-select-pop hidden">
  <div class="turn-select-header">ã‚«ãƒ¼ãƒ‰ã‚’æ¸¡ã™ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é¸æŠ</div>
  <div id="give2TargetList" class="turn-select-list"></div>
</div>
<div id="give2CenterCard" class="give2-center-card hidden"></div>

<!-- ãƒ›ã‚¹ãƒˆè¨­å®šãƒœã‚¿ãƒ³ -->
<button id="hostSettingsBtn" class="host-settings-btn" title="è¨­å®š">âš™</button>

<!-- ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒƒãƒ— -->
<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">Ã—</button>
  </div>
  <div class="start-pop-main">
    æº–å‚™ãŒã§ããŸã‚‰ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚<br>
    æŠ¼ã™ã¨å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚«ãƒ¼ãƒ‰ãŒ5æšãšã¤é…ã‚‰ã‚Œã¾ã™ã€‚
  </div>
  <div class="start-pop-actions">
    <!-- â˜… ã“ã“ã‚’å¤‰æ›´ï¼šãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã‚’è¿½åŠ  -->
    <button id="btnGameReset" class="btn ghost">ãƒªã‚»ãƒƒãƒˆ</button>
    <button id="btnGameStart" class="btn primary">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>
</div>


<!-- â–·ãƒœã‚¿ãƒ³ -->
<button id="turnNextBtn" class="turn-next-btn hidden">â–·</button>

<!-- ã‚¿ãƒ¼ãƒ³ãƒãƒŠãƒ¼ -->
<div id="turnBanner" class="turn-banner hidden"></div>

<!-- â–·é•·æŠ¼ã—ï¼šå‚åŠ è€…ä¸€è¦§ -->
<div id="turnSelectPop" class="turn-select-pop hidden">
  <div class="turn-select-header">ã‚¿ãƒ¼ãƒ³ã«ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é¸æŠ</div>
  <div id="turnSelectList" class="turn-select-list"></div>
</div>
<!-- â˜… æ­£ä½“ã‚’è¦‹ã‚‹ãƒãƒƒãƒ—ï¼ˆä½¿ç”¨è€…ã ã‘ã«è¡¨ç¤ºï¼‰ -->
<div id="peekRolePop" class="turn-select-pop hidden">
  <div class="turn-select-header">æ­£ä½“ã‚’è¦‹ãŸã„äººã‚’é¸ã¶</div>
  <div style="font-size:12px;opacity:.8;">
    ãƒãƒ¼ãƒ ã‚¿ã‚°ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚
  </div>
</div>

<!-- â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ç”¨ ç¢ºèªãƒãƒƒãƒ— -->
<div id="shuffle3ConfirmPop" class="turn-select-pop hidden">
  <div class="turn-select-header">é¸ã°ã‚ŒãŸ3äººã®æ­£ä½“ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã™ã‹ï¼Ÿ</div>
  <div class="turn-select-list">
    <button class="btn ghost" id="btnShuffle3Reset">é¸ã³ç›´ã™</button>
    <button class="btn primary" id="btnShuffle3Confirm">æ±ºå®š</button>
  </div>
</div>


<!-- â˜…â˜…â˜… ç«‹æ–¹ä½“SVGãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå„ã‚­ãƒ¥ãƒ¼ãƒ–ã§è¤‡è£½ã—ã¦ä½¿ç”¨ï¼‰ â˜…â˜…â˜… -->
<template id="cubeTemplate">
  <svg viewBox="0 0 400 320">
    <defs>
      <!-- å‰é¢ -->
      <radialGradient id="g_front" cx="50%" cy="50%" r="70%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.35"/>
        <stop offset="70%" stop-color="#b00020" stop-opacity="0.70"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.85"/>
      </radialGradient>
      <!-- å³å´é¢ -->
      <radialGradient id="g_side" cx="40%" cy="40%" r="90%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.22"/>
        <stop offset="60%" stop-color="#b00020" stop-opacity="0.55"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.75"/>
      </radialGradient>
      <!-- ä¸Šé¢ -->
      <radialGradient id="g_top" cx="60%" cy="60%" r="90%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.15"/>
        <stop offset="60%" stop-color="#b00020" stop-opacity="0.43"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.68"/>
      </radialGradient>
      <!-- èƒŒé¢ç”¨ï¼šå‰ã‚ˆã‚Šè–„ã„ -->
      <radialGradient id="g_back" cx="50%" cy="50%" r="70%">
        <stop offset="0%" stop-color="#d02030" stop-opacity="0.10"/>
        <stop offset="70%" stop-color="#b00020" stop-opacity="0.30"/>
        <stop offset="100%" stop-color="#600010" stop-opacity="0.50"/>
      </radialGradient>
      <!-- ç·šã‚’ã¼ã‹ã™ -->
      <filter id="blurEdges">
        <feGaussianBlur in="SourceGraphic" stdDeviation="1.0" result="blur" />
        <feComposite in="blur" in2="SourceGraphic" operator="in" />
      </filter>

      <!-- â˜… å˜ç‹¬ãƒ—ãƒ¬ãƒ¼ãƒˆæŠ½å‡ºç”¨ãƒã‚¹ã‚¯ç¾¤ -->
      <!-- ãƒ‘ã‚¹å®šç¾©ï¼ˆä½¿ã„å›ã™ç”¨ï¼‰ -->
      <g id="shape_back">
        <path d=" M178,100 L242,100 Q250,100 250,108 L250,172 Q250,180 242,180 L178,180 Q170,180 170,172 L170,108 Q170,100 178,100 Z "/>
      </g>
      <g id="shape_left">
        <path d=" M136.4,125.2 L163.6,104.8 Q170,100 170,108 L170,172 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 130,202 L130,138 Q130,130 136.4,125.2 Z "/>
      </g>
      <g id="shape_bottom">
        <path d=" M138,210 L202,210 Q210,210 216.4,205.2 L243.6,184.8 Q250,180 242,180 L178,180 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 138,210 Z "/>
      </g>
      <g id="shape_front">
        <path d=" M138,130 L202,130 Q210,130 210,138 L210,202 Q210,210 202,210 L138,210 Q130,210 130,202 L130,138 Q130,130 138,130 Z "/>
      </g>
      <g id="shape_right">
        <path d=" M216.4,125.2 L243.6,104.8 Q250,100 250,108 L250,172 Q250,180 243.6,184.8 L216.4,205.2 Q210,210 210,202 L210,138 Q210,130 216.4,125.2 Z "/>
      </g>
      <g id="shape_top">
        <path d=" M138,130 L202,130 Q210,130 216.4,125.2 L243.6,104.8 Q250,100 242,100 L178,100 Q170,100 163.6,104.8 L136.4,125.2 Q130,130 138,130 Z "/>
      </g>

      <!-- å…±é€š: å…¨é¢é»’èƒŒæ™¯ -->
      <rect id="mask_bg" x="0" y="0" width="400" height="320" fill="black"/>

      <!-- front å˜ç‹¬ -->
      <mask id="m_frontOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_front" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- right å˜ç‹¬ -->
      <mask id="m_rightOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_right" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- top å˜ç‹¬ -->
      <mask id="m_topOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_top" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
      </mask>
      <!-- left å˜ç‹¬ -->
      <mask id="m_leftOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_left" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- back å˜ç‹¬ -->
      <mask id="m_backOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_back" fill="white"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_bottom" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
      <!-- bottom å˜ç‹¬ -->
      <mask id="m_bottomOnly" maskUnits="userSpaceOnUse">
        <use href="#mask_bg" />
        <use href="#shape_bottom" fill="white"/>
        <use href="#shape_back" fill="black"/>
        <use href="#shape_left" fill="black"/>
        <use href="#shape_front" fill="black"/>
        <use href="#shape_right" fill="black"/>
        <use href="#shape_top" fill="black"/>
      </mask>
    </defs>

    <!-- èƒŒé¢ -->
    <path d=" M178,100 L242,100 Q250,100 250,108 L250,172 Q250,180 242,180 L178,180 Q170,180 170,172 L170,108 Q170,100 178,100 Z " fill="url(#g_back)" />
    <!-- å·¦å´é¢ -->
    <path d=" M136.4,125.2 L163.6,104.8 Q170,100 170,108 L170,172 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 130,202 L130,138 Q130,130 136.4,125.2 Z " fill="url(#g_back)" />
    <!-- åº•é¢ -->
    <path d=" M138,210 L202,210 Q210,210 216.4,205.2 L243.6,184.8 Q250,180 242,180 L178,180 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 138,210 Z " fill="url(#g_back)" />
    <!-- å‰é¢ -->
    <path d=" M138,130 L202,130 Q210,130 210,138 L210,202 Q210,210 202,210 L138,210 Q130,210 130,202 L130,138 Q130,130 138,130 Z " fill="url(#g_front)" />
    <!-- å³å´é¢ -->
    <path d=" M216.4,125.2 L243.6,104.8 Q250,100 250,108 L250,172 Q250,180 243.6,184.8 L216.4,205.2 Q210,210 210,202 L210,138 Q210,130 216.4,125.2 Z " fill="url(#g_side)" />
    <!-- ä¸Šé¢ -->
    <path d=" M138,130 L202,130 Q210,130 216.4,125.2 L243.6,104.8 Q250,100 242,100 L178,100 Q170,100 163.6,104.8 L136.4,125.2 Q130,130 138,130 Z " fill="url(#g_top)" />

    <!-- å†…éƒ¨ç·š -->
    <g stroke="#700010" stroke-linejoin="round" filter="url(#blurEdges)">
      <line x1="170" y1="100" x2="170" y2="180" stroke-width="1.4" stroke-opacity="0.30"/>
      <line x1="170" y1="100" x2="250" y2="100" stroke-width="1.4" stroke-opacity="0.30"/>
      <line x1="170" y1="180" x2="250" y2="180" stroke-width="1.4" stroke-opacity="0.30"/>
    </g>

    <!-- å˜ç‹¬ãƒ—ãƒ¬ãƒ¼ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
    <g fill="#600010" fill-opacity="0.35">
      <path d=" M138,130 L202,130 Q210,130 210,138 L210,202 Q210,210 202,210 L138,210 Q130,210 130,202 L130,138 Q130,130 138,130 Z " mask="url(#m_frontOnly)"/>
      <path d=" M216.4,125.2 L243.6,104.8 Q250,100 250,108 L250,172 Q250,180 243.6,184.8 L216.4,205.2 Q210,210 210,202 L210,138 Q210,130 216.4,125.2 Z " mask="url(#m_rightOnly)"/>
      <path d=" M138,130 L202,130 Q210,130 216.4,125.2 L243.6,104.8 Q250,100 242,100 L178,100 Q170,100 163.6,104.8 L136.4,125.2 Q130,130 138,130 Z " mask="url(#m_topOnly)"/>
      <path d=" M136.4,125.2 L163.6,104.8 Q170,100 170,108 L170,172 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 130,202 L130,138 Q130,130 136.4,125.2 Z " mask="url(#m_leftOnly)"/>
      <path d=" M178,100 L242,100 Q250,100 250,108 L250,172 Q250,180 242,180 L178,180 Q170,180 170,172 L170,108 Q170,100 178,100 Z " mask="url(#m_backOnly)"/>
      <path d=" M138,210 L202,210 Q210,210 216.4,205.2 L243.6,184.8 Q250,180 242,180 L178,180 Q170,180 163.6,184.8 L136.4,205.2 Q130,210 138,210 Z " mask="url(#m_bottomOnly)"/>
    </g>
  </svg>
</template>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* â˜… ã‚«ãƒ¼ãƒ‰å®šç¾©ï¼ˆå„2æšãšã¤ï¼‰ */
const CARD_DEFS = [
  // â‘  ã„ã¤ã§ã‚‚ä½¿ãˆã‚‹
  { id:'ANY_SKIP_NEXT',        timing:'ã„ã¤ã§ã‚‚', text:'1äººæ‰‹ç•ªã‚’é£›ã°ã™' },
  { id:'ANY_SKIP_TO_PLAYER',   timing:'ã„ã¤ã§ã‚‚', text:'å¥½ããªäººã¾ã§æ‰‹ç•ªã‚’é£›ã°ã™' },
  { id:'ANY_DICE_MINUS2',      timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’-2ã™ã‚‹(1,2ã«ä½¿ãˆãªã„)' },
  { id:'ANY_DICE_MINUS1',      timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’-1ã™ã‚‹' },
  { id:'ANY_DICE_PLUS1',       timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’+1ã™ã‚‹' },
  { id:'ANY_DICE_PLUS2',       timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’+2ã™ã‚‹(5,6ã«ä½¿ãˆãªã„)' },
  { id:'ANY_ADD_DICE1_START',  timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’1ã¤å¢—ã‚„ã™' },
  { id:'ANY_ADD_DICE2_START',  timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’2ã¤å¢—ã‚„ã™' },
  { id:'ANY_HEAL1',            timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’1å›å¾©ã™ã‚‹' },
  { id:'ANY_SET_DICE_ANY',     timing:'ã„ã¤ã§ã‚‚', text:'ä»»æ„ã®ãƒ€ã‚¤ã‚¹ç›®1ã¤ã‚’ä»»æ„ã®ç›®ã«å¤‰ãˆã‚‹' },
  { id:'ANY_REROLL_1_OR_2',    timing:'ã„ã¤ã§ã‚‚', text:'ãƒ€ã‚¤ã‚¹ã‚’1ï½2å€‹ãµã‚ŠãªãŠã™' },
  { id:'ANY_EXPLOSION_PLUS1',  timing:'ã„ã¤ã§ã‚‚', text:'çˆ†ç™ºæ™‚ã«å…¨ã¦ã®çˆ†ç™ºãƒ€ãƒ¡ãƒ¼ã‚¸+1' },
  { id:'ANY_BOTH_NEIGHBOR_B1', timing:'ã„ã¤ã§ã‚‚', text:'èª°ã‹ãŒçˆ†ç™ºã—ãŸæ™‚ã€ä¸¡éš£ã‚‚çˆ†ç™ºã™ã‚‹' },
  { id:'ANY_SELF_EXPLOSION_B1',timing:'ã„ã¤ã§ã‚‚', text:'è‡ªåˆ†ãŒçˆ†ç™ºã—ãŸæ™‚ã€ã‚‚ã†ä¸€äººé¸ã‚“ã§çˆ†ç™º' },
  { id:'ANY_RESET_DICE_8',     timing:'ã„ã¤ã§ã‚‚', text:'ãƒ€ã‚¤ã‚¹ã®æ•°ã‚’8ã¤ã«ã‚‚ã©ã™' },
  { id:'ANY_START_DICE_MINUS1',timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’1ã¤é™¤ã' },
  { id:'ANY_START_DICE_MINUS2',timing:'ã„ã¤ã§ã‚‚', text:'æŒ¯ã‚‹å‰ã«ãƒ€ã‚¤ã‚¹ã‚’2ã¤é™¤ã' },

  // â‘¡ è‡ªåˆ†ã®ç•ªã§ä½¿ãˆã‚‹
  { id:'TURN_DRAW2',                 timing:'æ‰‹ç•ªã§', text:'ã‚«ãƒ¼ãƒ‰ã‚’2æšã²ã' },
  { id:'TURN_PEEK_ROLE',             timing:'æ‰‹ç•ªã§', text:'ä»»æ„ã®1äººã‚’é¸ã³ã€æ­£ä½“ã‚’è¦‹ã‚‹' },
  { id:'TURN_SHOW_ROLE_HEAL1_EXILE', timing:'æ‰‹ç•ªã§', text:'1äººã«æ­£ä½“ã‚’è¦‹ã›ã¦1å›å¾©ï¼Š' },
  { id:'TURN_DRAW2_KEEP_GIVE1',      timing:'æ‰‹ç•ªã§', text:'ã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãã€ã†ã¡1æšã¯èª°ã‹ã«æ¸¡ã™' },
  { id:'TURN_SHUFFLE3_ROLES_EXILE',  timing:'æ‰‹ç•ªã§', text:'3äººé¸ã³ã€æ­£ä½“ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼Š' },
  { id:'TURN_SELF_HEAL1_ALL_DRAW1',  timing:'æ‰‹ç•ªã§', text:'1å›å¾©ã—ãŸå¾Œã€å…¨å“¡ã‚«ãƒ¼ãƒ‰ã‚’1æšã²ã' },
  { id:'TURN_SHOW_ROLES_MUTUAL_EXILE',timing:'æ‰‹ç•ªã§', text:'æ­£ä½“ã‚’è¦‹ã›ã‚ã†ï¼Š' }
];



// å„ã‚«ãƒ¼ãƒ‰2æšãšã¤ã®å±±æœ­
const CARD_POOL = CARD_DEFS.flatMap(def => [def.id, def.id]);

// å±±æœ­åˆè¨ˆæšæ•°ï¼ˆãƒ‡ãƒƒã‚­è¡¨ç¤ºç”¨ï¼‰
const DECK_TOTAL = CARD_POOL.length;
const SHUFFLE_THRESHOLD = 10;   // ã“ã®æšæ•°ä»¥ä¸‹ã«ãªã£ãŸã‚‰æ¨ã¦æœ­ã‚’å±±æœ­ã«æˆ»ã™

// ã‚«ãƒ¼ãƒ‰å®šç¾©å–å¾—
function getCardDef(cardId){
  return CARD_DEFS.find(c => c.id === cardId) || null;
}

// ã‚«ãƒ¼ãƒ‰ã®è¦‹ãŸç›®ï¼ˆçœŸã‚“ä¸­ã¡ã‚‡ã£ã¨ä¸‹ã®ãƒ©ãƒ™ãƒ«ï¼‹ãã®ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆï¼‰
function createCardFace(cardId){
  const def = getCardDef(cardId);
  const wrap = document.createElement('div');
  wrap.className = 'card-face';

  if(def){
    const timing = document.createElement('div');
    timing.className = 'card-timing';
    timing.textContent = def.timing;

    const body = document.createElement('div');
    body.className = 'card-text';
    body.textContent = def.text;

    wrap.appendChild(timing);
    wrap.appendChild(body);
  }else{
    wrap.textContent = cardId ?? '';
  }
  return wrap;
}

const state = {

  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  usedCards: [],
  discardPile: [],
  exilePile: [],   
  currentTurnSeat: null,
ã€€currentTurnPlayerId: null, 
  bureaucratUsedThisTurn: false, 
  roles: {},
  centerRole: null,
  roleOpenMap: {},
  chefRoles: {}, 
  /* â˜… è¿½åŠ ï¼šã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãã€1æšã‚’èª°ã‹ã«æ¸¡ã™ãƒ•ãƒ­ãƒ¼ */
  give2Flow: null,       // { active, ownerId, cardIds:[id1,id2], usedMeta:{value,ownerId,usedAt} }

  /* â˜… è¿½åŠ ï¼šæ­£ä½“ã‚’è¦‹ã‚‹ï¼ˆå€‹äººçš„å…¬é–‹ï¼‰ç”¨ */
  peekRoleGlobal: null,  // { active, ownerId, usedMeta, createdAt }
  peekRoleView: {},      // { [viewerId]: { targetId, usedMeta, viewerId, createdAt } }
  shuffle3Global: null, 

};

let firstTurnPeekStarted = false;          // è‡ªåˆ†å´ã§ã€Œåˆå›ã®æ­£ä½“ç¢ºèªãƒ¢ãƒ¼ãƒ‰ã€ã«å…¥ã£ãŸã‹
const firstPeekTargets   = {};             // { playerId: true } ã“ã®ç«¯æœ«ã ã‘ã§è¦‹ãˆã¦ã„ã‚‹æ­£ä½“

const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');
const waitMaxPlayersMessage = document.getElementById('waitMaxPlayersMessage');


const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
/* â˜… è¿½åŠ ï¼šè‡ªåˆ†ã®æ­£ä½“ã‚«ãƒ¼ãƒ‰ç½®ãå ´ */
const myRoleSlot = document.getElementById('myRoleSlot');
/* â˜… è¿½åŠ ï¼šè‡ªåˆ†ã®èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ç½®ãå ´ */
const myAbilitySlot = document.getElementById('myAbilitySlot');
/* â˜… è¿½åŠ ï¼šèƒ½åŠ›æ‹¡å¤§ãƒãƒƒãƒ— */
const abilityOverlay = document.getElementById('abilityOverlay');
const abilityOverlayCard = document.getElementById('abilityOverlayCard');
/* â˜… è¿½åŠ ï¼šæ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ç½®ãå ´ */
const roleCenterSlot = document.getElementById('roleCenterSlot');

const usedCardsArea = document.getElementById('usedCardsArea');
const deckStackEl = document.getElementById('deckStack');
const deckDrawHint = document.getElementById('deckDrawHint');  
const discardStackEl = document.getElementById('discardStack');
const exileStackEl = document.getElementById('exileStack');  
/* â˜… è¿½åŠ ï¼š2æšå¼•ã„ã¦1æšæ¸¡ã™ç”¨ */
const give2Overlay = document.getElementById('give2Overlay');
const give2CardsEl = document.getElementById('give2Cards');
const give2TargetPop = document.getElementById('give2TargetPop');
const give2TargetList = document.getElementById('give2TargetList');
const give2HintEl    = document.getElementById('give2Hint'); // â˜…è¿½åŠ 
const give2CenterCard = document.getElementById('give2CenterCard'); // â˜…è¿½åŠ 

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');
// â˜… ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ã‚¨ãƒ©ãƒ¼ãƒãƒ–ãƒ«
const cardErrorBubble = document.getElementById('cardErrorBubble');
let cardErrorTimer = null;

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnGameReset = document.getElementById('btnGameReset');


const useCardDialog = document.getElementById('useCardDialog');
const btnUseCardYes = document.getElementById('btnUseCardYes');

const diceAdjustPop = document.getElementById('diceAdjustPop');

const turnNextBtn = document.getElementById('turnNextBtn');
const turnBanner = document.getElementById('turnBanner');

const turnSelectPop = document.getElementById('turnSelectPop');
const turnSelectList = document.getElementById('turnSelectList');
const peekRolePop = document.getElementById('peekRolePop');
/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ç¢ºèªãƒãƒƒãƒ— */
const shuffle3ConfirmPop = document.getElementById('shuffle3ConfirmPop');
const btnShuffle3Reset = document.getElementById('btnShuffle3Reset');
const btnShuffle3Confirm = document.getElementById('btnShuffle3Confirm');
/* â˜… å±±æœ­é…å¸ƒãƒãƒƒãƒ— */
const deckDealPop = document.getElementById('deckDealPop');
const btnDeckDeal = document.getElementById('btnDeckDeal');

/* â˜…â˜…â˜… ã‚·ã‚§ãƒ•èƒ½åŠ›ã‚«ãƒ¼ãƒ‰å®šç¾© â˜…â˜…â˜… */
const CHEF_DEFS = [
  {
    id:'CHEF_BUREAUCRAT',
    name:'ãƒˆãƒ¬ãƒ¼',
    shortLabel:'ã‚«ãƒ¼ãƒ‰ï¼‹1',
    detail:'æ‰‹ç•ªã®æœ€åˆã®ãƒ€ã‚¤ã‚¹ã‚’æŒ¯ã‚‹å‰ã«ä¸€æšã‚«ãƒ¼ãƒ‰ã‚’ã²ãã€‚',
    artType:'CARD_PLUS1'
  },
  {
    id:'CHEF_HUNTER',
    name:'ã‚ªãƒ¼ãƒ–ãƒ³ãƒ¬ãƒ³ã‚¸',
    shortLabel:'THEYâ’â’â’ / YOUâ’â†’',
    detail:'èª°ã‹ãŒ3ã‚¢ãƒãƒƒã‚’è² ã£ãŸæ™‚ã€1å›å¾©ã™ã‚‹ã€‚',
    artType:'THEY_YOU'
  },
  {
    id:'CHEF_WARRIOR',
    name:'ãƒšãƒƒãƒ‘ãƒ¼',
    shortLabel:'Â±1 å¼·åŒ–',
    detail:'ã‚ãªãŸãŒãƒ€ã‚¤ã‚¹ç›®ã‚’å¢—æ¸›ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ã†æ™‚ã€ã•ã‚‰ã«Â±1ã—ã¦ã‚‚ã‚ˆã„ã€‚',
    artType:'CARD_DICE_PM1'
  },
  {
    id:'CHEF_PRO',
    name:'ãƒ¡ã‚¸ãƒ£ãƒ¼ã‚«ãƒƒãƒ—',
    shortLabel:'x8â†’4/5/6',
    detail:'èª°ã‹ãŒå¤±æ•—ã—ãŸæ™‚ã€ãƒ€ã‚¤ã‚¹ã‚’8ã¤ã§ã¯ãªãã€4/5/6ã¤ã«ã—ã¦ã‚‚ã‚ˆã„ã€‚',
    artType:'DICE_8_TO_4_5_6'
  },
  {
    id:'CHEF_STUDENT',
    name:'ãƒˆãƒ³ã‚°',
    shortLabel:'again 1',
    detail:'å…¨ã¦ã®ãƒ€ã‚¤ã‚¹ã‚’æŒ¯ã£ãŸå¾Œã€ä¸€ã¤ã ã‘æŒ¯ã‚Šç›´ã—ã¦ã‚‚ã‚ˆã„ã€‚',
    artType:'DICE_AGAIN_ONE'
  },
  {
    id:'CHEF_MAD',
    name:'ãƒ•ãƒ©ã‚¤è¿”ã—',
    shortLabel:'all again',
    detail:'å…¨ã¦ã®ãƒ€ã‚¤ã‚¹ã‚’æŒ¯ã£ãŸå¾Œã€å…¨ã¦æŒ¯ã‚Šç›´ã—ã¦ã‚‚ã‚ˆã„ã€‚',
    artType:'DICE_AGAIN_ALL'
  },
  {
    id:'CHEF_RICH',
    name:'ãƒŸãƒˆãƒ³',
    shortLabel:'5ãƒ»5ãƒ»5â†’â’',
    detail:'å…¨ã¦ã®ãƒ€ã‚¤ã‚¹ç›®ãŒåŒã˜å ´åˆã€1ã‚¢ãƒãƒƒã ã‘è² ãˆã°ã‚ˆã„ã€‚',
    artType:'DICE_555'
  }
];

function getChefDef(chefId){
  return CHEF_DEFS.find(c => c.id === chefId) || null;
}
// â˜… è¿½åŠ ï¼šCHEF_FORTUNEï¼ˆã‚´ãƒ¼ã‚°ãƒ«ï¼‰ã‚’æŒã£ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€è¦§ã‚’å–å¾—
function getFortuneOwners(){
  if(!state.chefRoles) return [];
  return Object.entries(state.chefRoles)
    .filter(([, chefId]) => chefId === 'CHEF_FORTUNE')
    .map(([playerId]) => playerId);
}

/* â˜… ãƒŸãƒ‹ç”¨å›³å½¢ */
function createChefArtMini(def){
  const wrap = document.createElement('div');
  wrap.className = 'ability-art-mini';

  switch(def.artType){
    case 'CARD_PLUS1':{
      const card = document.createElement('div');
      card.className = 'ability-icon-card';
      const txt = document.createElement('div');
      txt.style.position = 'absolute';
      txt.style.right = '-14px';
      txt.style.top = '11px';
      txt.style.fontSize = '10px';
      txt.textContent = '+1';
      card.appendChild(txt);
      wrap.appendChild(card);
      break;
    }
    case 'EYE':{
      const span = document.createElement('div');
      span.style.fontSize = '18px';
      span.textContent = 'ğŸ‘€';
      span.style.position = 'absolute';
      span.style.left = '50%';
      span.style.top = '50%';
      span.style.transform = 'translate(-50%,-50%)';
      wrap.appendChild(span);
      break;
    }
    case 'THEY_YOU': {
      // ä¸Šï¼šOTHER â’â’â’ï¼ˆèµ¤å­—ï¼‰
      const top = document.createElement('div');
      top.style.fontSize = '10px';
      top.style.color = '#e02424'; // èµ¤å­—
      top.style.lineHeight = '1.0';   // â˜… è¡Œé–“ã¤ã‚ã‚‹
      top.style.marginBottom = '2px'; // â˜… ã¤ã„ã§ã«ä¸‹ã‚‚å°‘ã—è©°ã‚ã‚‹
      top.innerHTML = 'ã ã‚Œã‹<br>â’â’â†â’';
      top.style.right = '10px';

      // â†“ çœŸã‚“ä¸­ã¯ã‚‚ã†ä½¿ã‚ãªã„ã®ã§ rowSquares ã¯å‰Šé™¤

      // ä¸‹ï¼šã‚ãªãŸâ’ï¼ˆè–„ã„ã‚°ãƒ¬ãƒ¼ï¼‰â‡¢â’ï¼ˆèµ¤ï¼‰
      const bottom = document.createElement('div');
      bottom.style.fontSize = '10px';
      bottom.innerHTML =
        'ã‚ãªãŸ<br>' +
        '<span style="color:#cccccc;">â’</span>' + // è–„ã„ã‚°ãƒ¬ãƒ¼
        'â‡¢' +
        '<span style="color:#e02424;">â’</span>';  // èµ¤
      bottom.style.lineHeight = '1.0';   // è¡Œé–“ã¤ã‚ã‚‹
      bottom.style.marginTop = '4px';

      wrap.appendChild(top);
      wrap.appendChild(bottom);
      break;
    }

case 'CARD_DICE_PM1':{
  // ä¸­å¤®ã«ç½®ãã‚°ãƒ«ãƒ¼ãƒ—
  const group = document.createElement('div');
  group.style.position = 'absolute';
  group.style.left = '50%';
  group.style.top = '180%';
  group.style.transform = 'translate(-50%, -50%)';

  // å°ã•ã‚ã‚«ãƒ¼ãƒ‰
  const card = document.createElement('div');
  card.className = 'ability-icon-card small';
  card.style.position = 'relative'; // ä¸­ã«çµ¶å¯¾é…ç½®ã™ã‚‹ãŸã‚

  // ã‚«ãƒ¼ãƒ‰ã®ä¸­ã«ãƒ€ã‚¤ã‚¹ã‚’ä¸­å¤®
  const dice = document.createElement('div');
  dice.className = 'ability-icon-dice';
  dice.style.position = 'absolute';
  dice.style.left = '50%';
  dice.style.top = '45%';                 // å°‘ã—ä¸Šã«å¯„ã›ã‚‹ï¼ˆÂ±1 ã‚’ä¸‹ã«ç½®ãã‚¹ãƒšãƒ¼ã‚¹ç”¨ï¼‰
  dice.style.transform = 'translate(-50%, -50%)';

  const center = document.createElement('div');
  center.className = 'ability-icon-dice-center';
  dice.appendChild(center);

  // Â±1 ãƒ†ã‚­ã‚¹ãƒˆï¼ˆãƒ€ã‚¤ã‚¹ã®çœŸä¸‹ãƒ»ä¸­å¤®ï¼‰
  const pm = document.createElement('div');
  pm.textContent = 'Â±1';
  pm.style.position = 'absolute';
  pm.style.left = '50%';
  pm.style.bottom = '2px';               // ã‚«ãƒ¼ãƒ‰ä¸‹ã‹ã‚‰å°‘ã—ä¸Š
  pm.style.transform = 'translateX(-50%)';
  pm.style.fontSize = '9px';
  pm.style.lineHeight = '1';

 const pmRight = document.createElement('div');

  pmRight.textContent = 'Â±1';
  pmRight.style.position = 'absolute';
  pmRight.style.right = '-13px';     // ã‚«ãƒ¼ãƒ‰ã®å¤–ã«å°‘ã—ã¯ã¿å‡ºã™æ„Ÿã˜
  pmRight.style.top = '83%';        // ç¸¦ä¸­å¤®
  pmRight.style.transform = 'translateY(-50%)';
  pmRight.style.fontSize = '9px';
  card.appendChild(dice);
  card.appendChild(pm);
  group.appendChild(card);
  card.appendChild(pmRight);   // å³

  wrap.appendChild(group);
  break;
}


    case 'DICE_8_TO_4_5_6':{
      // ãƒ€ã‚¤ã‚¹æœ¬ä½“
      const dice = document.createElement('div');
      dice.className = 'ability-icon-dice';
      dice.style.left = '4px';
      dice.style.top  = '4px';
      const center = document.createElement('div');
      center.className = 'ability-icon-dice-center';
      dice.appendChild(center);
      wrap.appendChild(dice);

      // ãƒ€ã‚¤ã‚¹ã®å³ã«ã€Œx8ã€
      const x8 = document.createElement('div');
      x8.style.position  = 'absolute';
      x8.style.left      = '24px';
      x8.style.top       = '10px';
      x8.style.fontSize  = '8px';
      x8.textContent     = 'x8';
      wrap.appendChild(x8);

      // ãƒ€ã‚¤ã‚¹ã®çœŸä¸‹ã¡ã‚‡ã£ã¨å³ã«ã€Œâ†’4/5/6ã€
      const arrow = document.createElement('div');
      arrow.style.position = 'absolute';
      arrow.style.left     = '14px';
      arrow.style.top      = '22px';   // ãƒ€ã‚¤ã‚¹ã®å°‘ã—ä¸‹ã‚ãŸã‚Š
      arrow.style.fontSize = '8px';
      arrow.textContent    = 'â¡x4/5/6';
      wrap.appendChild(arrow);

      break;
    }

    case 'DICE_AGAIN_ONE':{
  // ä¸Šï¼šæ™®é€šã®ãƒŸãƒ‹ãƒ€ã‚¤ã‚¹ 3 å€‹
  // ä¸‹ï¼šâ†’â’â’ï¼ˆâ’ã ã‘èµ¤ï¼‰ã¨ã„ã†ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
  wrap.style.display = 'flex';
  wrap.style.flexDirection = 'column';
  wrap.style.alignItems = 'center';
  wrap.style.justifyContent = 'center';

  // ãƒ€ã‚¤ã‚¹3å€‹ã‚’æ¨ªä¸€åˆ—ã«ä¸¦ã¹ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ
  const row = document.createElement('div');
  row.style.display = 'flex';
  row.style.gap = '1px';
  row.style.marginBottom = '0';
  row.style.marginTop = '17px';

  for (let i = 0; i < 3; i++) {
    const dice = document.createElement('div');
    dice.className = 'ability-icon-dice';

    dice.style.position = 'relative';
    dice.style.left = '0';
    dice.style.top  = '0';

    const center = document.createElement('div');
    center.className = 'ability-icon-dice-center';
    dice.appendChild(center);

    row.appendChild(dice);
  }

  wrap.appendChild(row);

  const bottom = document.createElement('div');
  bottom.style.position = 'relative';        // 
  bottom.style.display  = 'inline-block';    // ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚ºã«ãƒ•ã‚£ãƒƒãƒˆ
  bottom.style.fontSize = '12px';
  bottom.style.marginTop = '0';

  bottom.style.left = '14px';
  bottom.textContent = 'again';

  // âœ•
  const cross = document.createElement('div');
  cross.textContent = 'ã€‡';
  cross.style.position = 'absolute';
  // â˜… ã“ã®ã‚ãŸã‚Šã¯å¥½ãã«èª¿æ•´ã—ã¦OK
  cross.style.top  = '-28px';   // ãƒã‚¹ã‚¿ãƒ¼ãŒã€ŒçœŸä¸Šã€ã«æ¥ã‚‹ã‚ˆã†ã«å¾®èª¿æ•´
  cross.style.left = '6px';
cross.style.fontFamily = 'system-ui, -apple-system, "Segoe UI", sans-serif';
cross.style.fontWeight = '400';   // å¤ªã‚
cross.style.fontSize   = '27px';  // å°‘ã—å¤§ãã‚

  bottom.appendChild(cross);
  wrap.appendChild(bottom);

  break;
}

    case 'DICE_AGAIN_ALL':{
  // ä¸Šï¼šæ™®é€šã®ãƒŸãƒ‹ãƒ€ã‚¤ã‚¹ 3 å€‹
  // ä¸‹ï¼šâ†’â’â’ï¼ˆâ’ã ã‘èµ¤ï¼‰ã¨ã„ã†ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
  wrap.style.display = 'flex';
  wrap.style.flexDirection = 'column';
  wrap.style.alignItems = 'center';
  wrap.style.justifyContent = 'center';

  // ãƒ€ã‚¤ã‚¹3å€‹ã‚’æ¨ªä¸€åˆ—ã«ä¸¦ã¹ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ
  const row = document.createElement('div');
  row.style.display = 'flex';
  row.style.gap = '1px';
  row.style.marginBottom = '0';
  row.style.marginTop = '17px';

  for (let i = 0; i < 3; i++) {
    const dice = document.createElement('div');
    dice.className = 'ability-icon-dice';

    dice.style.position = 'relative';
    dice.style.left = '0';
    dice.style.top  = '0';

    const center = document.createElement('div');
    center.className = 'ability-icon-dice-center';
    dice.appendChild(center);

    row.appendChild(dice);
  }

  wrap.appendChild(row);

  const bottom = document.createElement('div');
  bottom.style.position = 'relative';        // 
  bottom.style.display  = 'inline-block';    // ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚ºã«ãƒ•ã‚£ãƒƒãƒˆ
  bottom.style.fontSize = '10px';
  bottom.style.marginTop = '0';
  bottom.style.whiteSpace = 'nowrap';   // â˜… ã“ã“ã‚’è¿½åŠ ï¼šå¿…ãš1è¡Œã«

  bottom.style.left = '0px';
  bottom.textContent = 'all again';

  wrap.appendChild(bottom);

  break;
}
case 'DICE_555': {
  // ä¸Šï¼šæ™®é€šã®ãƒŸãƒ‹ãƒ€ã‚¤ã‚¹ 3 å€‹
  // ä¸‹ï¼šâ†’â’â’ï¼ˆâ’ã ã‘èµ¤ï¼‰ã¨ã„ã†ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
  wrap.style.display = 'flex';
  wrap.style.flexDirection = 'column';
  wrap.style.alignItems = 'center';
  wrap.style.justifyContent = 'center';

  // ãƒ€ã‚¤ã‚¹3å€‹ã‚’æ¨ªä¸€åˆ—ã«ä¸¦ã¹ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ
  const row = document.createElement('div');
  row.style.display = 'flex';
  row.style.gap = '1px';
  row.style.marginBottom = '0';
  row.style.marginTop = '17px';

  for (let i = 0; i < 3; i++) {
    const dice = document.createElement('div');
    dice.className = 'ability-icon-dice';

    dice.style.position = 'relative';
    dice.style.left = '0';
    dice.style.top  = '0';

    const center = document.createElement('div');
    center.className = 'ability-icon-dice-center';
    dice.appendChild(center);

    row.appendChild(dice);
  }

  wrap.appendChild(row);

  // â–¼ ä¸‹ã«ã€Œâ†’â’â’ã€ï¼‹ ãã®ä¸Šã« âœ• ã‚’é‡ã­ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ
  const bottom = document.createElement('div');
  bottom.style.position = 'relative';        // âœ• ã®åŸºæº–
  bottom.style.display  = 'inline-block';    // ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚ºã«ãƒ•ã‚£ãƒƒãƒˆ
  bottom.style.fontSize = '16px';
  bottom.style.marginTop = '0';

  // ã€Œâ†’â’â’ã€ â’ã ã‘èµ¤è‰²
  bottom.innerHTML = 'â‡ <span style="color:#e02424;">â’â’</span>';

  // âœ•
  const cross = document.createElement('div');
  cross.textContent = 'âœ•';
  cross.style.position = 'absolute';
  // â˜… ã“ã®ã‚ãŸã‚Šã¯å¥½ãã«èª¿æ•´ã—ã¦OK
  cross.style.top  = '-1px';   // ãƒã‚¹ã‚¿ãƒ¼ãŒã€ŒçœŸä¸Šã€ã«æ¥ã‚‹ã‚ˆã†ã«å¾®èª¿æ•´
  cross.style.left = '28px';
cross.style.fontFamily = 'system-ui, -apple-system, "Segoe UI", sans-serif';
cross.style.fontWeight = '900';   // å¤ªã‚
cross.style.fontSize   = '18px';  // å°‘ã—å¤§ãã‚

  bottom.appendChild(cross);
  wrap.appendChild(bottom);

  break;
}


  }

  return wrap;
}

/* æ‹¡å¤§ç”¨ï¼šå›³å½¢ã ã‘å°‘ã—å¤§ããã™ã‚‹ */
function createChefArtLarge(def){
  const el = createChefArtMini(def);
  el.classList.remove('ability-art-mini');
  el.classList.add('ability-art-large');
  return el;
}

/* ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ã®ä¸­èº«ï¼ˆåå‰ã‚¿ã‚°ï¼‹å›³å½¢ï¼‰ */
function createChefMiniFace(chefId){
  const def = getChefDef(chefId);
  if(!def){
    const empty = document.createElement('div');
    empty.textContent = '';
    return empty;
  }

  const wrap = document.createElement('div');
  wrap.className = 'ability-face';

  const nameTag = document.createElement('div');
  nameTag.className = 'ability-name-tag';
  nameTag.textContent = def.name;

  const art = createChefArtMini(def);

  wrap.appendChild(nameTag);
  wrap.appendChild(art);
  return wrap;
}



/* â˜… ç«‹æ–¹ä½“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå‚ç…§ */
const cubeTemplate = document.getElementById('cubeTemplate');
let lastShuffleAtHandled = 0;   // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ã®äºŒé‡å†ç”Ÿé˜²æ­¢ç”¨

let pendingSeatIndexToSteal = null;
let pendingPlayerNameToSteal = null;
let pendingSeatPlayerIdToSteal = null;

let isRenderingSeatTabs = false;
let latestPlayers = [];

let pendingUseCardIndex = null;
let pendingUseCardValue = null;

let isMovingUsedCardToDiscard = false;
let isUseCardProcessing = false;  // â˜…ã€Œä½¿ã†ã€å‡¦ç†ã®äºŒé‡å®Ÿè¡Œé˜²æ­¢ãƒ•ãƒ©ã‚°
let isMovingUsedCardToExile = false;  // â˜… è¿½åŠ ï¼šé™¤å¤–ç§»å‹•ã®äºŒé‡å®Ÿè¡Œé˜²æ­¢

let diceArea = null;
let draggingDie = null;
let dragPointerId = null;
let dragStartX = 0;
let dragStartY = 0;
let startTx = 0;
let startTy = 0;
let triggeredDiceThisDrag = null;
let allDiceRolledThisDrag = false;

let longPressTimer = null;
let longPressTriggered = false;
const LONG_PRESS_MS = 400;
const LONG_PRESS_MOVE_TOL = 6;

/* ã€Œ2æšã²ã1æšæ¸¡ã™ã€ç”¨ é•·æŠ¼ã—ãƒ»é¸æŠç®¡ç† */
let give2PointerId = null;
let give2LongPressTimer = null;
let give2LongPressTriggered = false;
let give2DownX = 0;
let give2DownY = 0;
let give2ActiveCardEl = null;
let give2KeepIndex = null;  // ã€Œã»ã—ã„ã‚«ãƒ¼ãƒ‰ã€ã¨ã—ã¦é¸æŠä¸­ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
let give2Dragging = false;

/* â˜… ãƒãƒƒãƒ—ã®ä¸‹æ ã‚ˆã‚Š20pxä¸‹ã§é›¢ã—ãŸã‹ã©ã†ã‹åˆ¤å®š */
function isDropForKeepByPanel(e){
  const panel = document.querySelector('.give2-panel');
  if(!panel) return false;
  const rect = panel.getBoundingClientRect();
  const y = e.clientY;

  // ã€Œãƒãƒƒãƒ—å¤– ï¼† ãƒãƒƒãƒ—ã®ä¸‹ ï¼† ä¸‹æ ã‚ˆã‚Š20pxä¸‹ã€ â‡’ y ãŒ bottom+20 ä»¥ä¸Š
  return y >= rect.bottom + 20;
}

/* â˜… æ®‹ã‚Š1æšã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­å¤®ï¼ˆplayerCircle ã®çœŸã‚“ä¸­ï¼‰ã«å‡ºã™ */
function showGive2CenterCard(cardId){
  if(!give2CenterCard || !playerCircle) return;

  give2CenterCard.classList.remove('hidden');
  give2CenterCard.innerHTML = '';

  const inner = document.createElement('div');
  inner.className = 'my-card';
  inner.appendChild(createCardFace(cardId));
  give2CenterCard.appendChild(inner);

  const circleRect = playerCircle.getBoundingClientRect();
  const cx = circleRect.left + circleRect.width / 2;
  const cy = circleRect.top  + circleRect.height / 2;

  give2CenterCard.style.left = cx + 'px';
  give2CenterCard.style.top  = cy + 'px';
}


function clearGive2LongPressTimer(){
  if(give2LongPressTimer){
    clearTimeout(give2LongPressTimer);
    give2LongPressTimer = null;
  }
}

/* ç¾åœ¨ã® give2Flow ã‹ã‚‰ cardIndex â†’ cardId ã‚’å–å¾— */
function getGive2CardIdByIndex(idx){
  const flow = state.give2Flow;
  if(!flow || !flow.cardIds || !Array.isArray(flow.cardIds)) return null;
  return flow.cardIds[idx] || null;
}

/* ã€Œã»ã—ã„ã‚«ãƒ¼ãƒ‰ã€ã‚’UIä¸Šã§ãƒãƒ¼ã‚¯ã™ã‚‹ã ã‘ï¼ˆãƒ­ã‚¸ãƒƒã‚¯çš„ã«ã¯ã©ã¡ã‚‰ã‚’é¸ã‚“ã§ã‚‚OKï¼‰ */
function markGive2KeepIndex(idx){
  give2KeepIndex = idx;
  if(!give2CardsEl) return;
  const cards = give2CardsEl.querySelectorAll('.give2-card');
  cards.forEach((c,i)=>{
    if(i === idx) c.classList.add('selected');
    else c.classList.remove('selected');
  });
}

/* â˜… è¿½åŠ ï¼šè‡ªåˆ†ã®æ‰‹æœ­(myHand)ã®è¿‘ãã«æ¥ã¦ã„ã‚‹ã‹åˆ¤å®š */
function isNearMyHandForGive2(card){
  if(!myHandEl) return false;
  const handRect = myHandEl.getBoundingClientRect();
  const cardRect = card.getBoundingClientRect();

  const cx = cardRect.left + cardRect.width / 2;
  const cy = cardRect.top  + cardRect.height / 2;
  const margin = 40; // ã©ã®ãã‚‰ã„ã€Œè¿‘ãã€ã¾ã§è¨±å®¹ã™ã‚‹ã‹

  return (
    cx >= handRect.left  - margin &&
    cx <= handRect.right + margin &&
    cy >= handRect.top   - margin &&
    cy <= handRect.bottom+ margin
  );
}

/* â˜… è¿½åŠ ï¼šãƒãƒƒãƒ—ã®ã‚«ãƒ¼ãƒ‰ã‚’è‡ªåˆ†ã®æ‰‹æœ­æ–¹å‘ã¸ã‚¹ãƒŠãƒƒãƒ—ã•ã›ã‚‹ */
function snapGive2CardToHand(card){
  if(!myHandEl) return;

  const handRect = myHandEl.getBoundingClientRect();
  const startCx = parseFloat(card.dataset.startCx || '0');
  const startCy = parseFloat(card.dataset.startCy || '0');

  // æ‰‹æœ­ã‚¨ãƒªã‚¢ã®å°‘ã—ä¸Šã‚ãŸã‚Šã‚’ç›®æ¨™ä½ç½®ã«ã™ã‚‹
  const targetX = handRect.left + handRect.width / 2;
  const targetY = handRect.top  - 20;

  const dx = targetX - startCx;
  const dy = targetY - startCy;

  card.style.transition = 'transform .25s ease-out';
  card.style.transform  = `translate(${dx}px, ${dy}px)`;
}

/* å±±æœ­é•·æŠ¼ã—ç”¨ */
let deckPressTimer = null;
let deckPressTriggered = false;
let deckPointerId = null;
let deckDownX = 0;
let deckDownY = 0;

let turnBtnLongPressTimer = null;
let turnBtnLongPressTriggered = false;
let turnBtnPointerId = null;
let turnBtnDownX = 0;
let turnBtnDownY = 0;
let suppressTurnClick = false;
let shuffle3SelectedIds = [];

const INNER_RADIUS = 110 - 24;
const OUTER_RADIUS = 250;

const DICE_CONTACT_DIST = 55;
const DICE_COLLIDE_DIST = 63;

let diceLocked = false;
let turnBannerRunning = false;
let turnClickLockedUntil = 0;
let lastGameStarted = null; 

let lastTurnPlayerId = null;
let lastTurnSeatIndex = null;
/* â˜…â˜…â˜… å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ã®å®šæ•°ãƒ»å¤‰æ•° â˜…â˜…â˜… */
const CUBE_INNER_RADIUS = 80;
const CUBE_COLLIDE_DIST = 30;

// â˜… è¿½åŠ ï¼šã‚­ãƒ¥ãƒ¼ãƒ–ãŒå††ã®ä¸­ã‹ã©ã†ã‹åˆ¤å®š
function isInsideCubeRadius(x, y){
  return Math.hypot(x, y) <= CUBE_INNER_RADIUS;
}

let cubeArea = null;
let draggingCube = null;
let cubePointerId = null;
let cubeStartX = 0;
let cubeStartY = 0;
let cubeStartTx = 0;
let cubeStartTy = 0;
/* â˜… è¿½åŠ ï¼šä»Šå›ã®ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸€åº¦ã§ã‚‚å††ã®å¤–ã«å‡ºãŸã‹ã©ã†ã‹ */
let cubeDragWasOutside = false;

/* DBã‹ã‚‰ã®æœ€æ–°ã‚­ãƒ¥ãƒ¼ãƒ–çŠ¶æ…‹ã‚’ä¿æŒï¼ˆãƒãƒ¼ãƒ ã‚¿ã‚°å´ã§ã‚‚ä½¿ã†ï¼‰ */
let latestCubeData = {};

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ã«ä¸¦ã‚“ã§ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã®ãƒ‰ãƒ©ãƒƒã‚°ç”¨ */
let attachedDragCube = null;
let attachedDragPointerId = null;
let attachedDragStartX = 0;
let attachedDragStartY = 0;
let attachedDragSeatIndex = null;
let attachedDragCubeId = null;
/* â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜… */

function clearLongPressTimer(){
  if(longPressTimer){
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
}
function clearTurnBtnLongPressTimer(){
  if(turnBtnLongPressTimer){
    clearTimeout(turnBtnLongPressTimer);
    turnBtnLongPressTimer = null;
  }
}
/* å±±æœ­é•·æŠ¼ã—ã‚¿ã‚¤ãƒãƒ¼è§£é™¤ */
function clearDeckPressTimer(){
  if (deckPressTimer){
    clearTimeout(deckPressTimer);
    deckPressTimer = null;
  }
}

function canTriggerContactRoll(){
  return !(state.usedCards && state.usedCards.length > 0);
}

function setDiceLocked(flag){
  diceLocked = flag;
  if(diceArea){
    const diceEls = diceArea.querySelectorAll('.dice');
    diceEls.forEach(d => {
      if(flag) d.classList.add('dice-locked');
      else d.classList.remove('dice-locked');
    });
  }
}

function updateDeckDrawHint(){
  if (!deckDrawHint) return;

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éè¡¨ç¤º
  deckDrawHint.classList.add('hidden');

  // ã‚²ãƒ¼ãƒ é–‹å§‹å‰ / è¦³æˆ¦ä¸­ã¯å‡ºã•ãªã„
  if (!lastGameStarted) return;
  if (state.seatedTable == null) return;

  // ã‚·ã‚§ãƒ•èƒ½åŠ›ã€Œãƒˆãƒ¬ãƒ¼ã€ã‚’æŒã£ã¦ã„ãªã„ãªã‚‰å‡ºã•ãªã„
  if (!hasMyChefAbility('CHEF_BUREAUCRAT')) return;

  // ä»Šã‚¿ãƒ¼ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ãªã‘ã‚Œã°å‡ºã•ãªã„
  if (!state.currentTurnPlayerId || state.currentTurnPlayerId !== state.userId) return;

  // ã“ã®ã‚¿ãƒ¼ãƒ³ã§æ—¢ã«ãƒˆãƒ¬ãƒ¼ã‚’ä½¿ã£ã¦ã„ãŸã‚‰å‡ºã•ãªã„
  if (state.bureaucratUsedThisTurn) return;

  // æ‰‹æœ­ãŒ5æšä»¥ä¸Šãªã‚‰å‡ºã•ãªã„ï¼ˆ4æšä»¥ä¸‹ã®ã¿ï¼‰
  if (getMyHandCount() > 4) return;

  // èª°ã‹ãŒã‚«ãƒ¼ãƒ‰ä½¿ç”¨ä¸­ï¼ˆusedCards ã«æ®‹ã£ã¦ã„ã‚‹ï¼‰ãªã‚‰å‡ºã•ãªã„
  if (state.usedCards && state.usedCards.length > 0) return;

  // ã™ã¹ã¦ OK ã®ã¨ãã ã‘è¡¨ç¤º
  deckDrawHint.classList.remove('hidden');
}

/* â˜… æœ€åˆã«ãƒ€ã‚¤ã‚¹ã«è§¦ã£ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã€Œæœ€åˆã®æ‰‹ç•ªã€ã«ç¢ºå®šã•ã›ã‚‹ */
function maybeSetFirstTurnByDice(){
  if (!state.roomCode) return;
  if (state.seatedTable == null) return; // å¸­ã«åº§ã£ã¦ã„ãªã„è¦³æˆ¦è€…ã¯å¯¾è±¡å¤–

  const tsRef = ref(db, `rooms/${state.roomCode}/turnState`);

  get(tsRef).then(snap => {
    const cur = snap.val();
    // ã™ã§ã«èª°ã‹ã®ã‚¿ãƒ¼ãƒ³ãŒæ±ºã¾ã£ã¦ã„ã‚‹ãªã‚‰ä¸Šæ›¸ãã—ãªã„
    if (cur && cur.playerId) return;

    const seatIndex  = state.seatedTable;
    const playerName = state.userName || 'åç„¡ã—';

    // â˜… æœ€åˆã ã‘ isFirstTurn, firstPeekDone=false ã‚’ä»˜ã‘ã¦æ›¸ãè¾¼ã‚€
    set(tsRef, {
      seatIndex,
      playerId:   state.userId,
      playerName,
      isFirstTurn:  true,
      firstPeekDone:false,
      updatedAt:   Date.now()
    });
  }).catch(()=>{ /* å¤±æ•—æ™‚ã¯ä½•ã‚‚ã—ãªã„ */ });
}

/* â˜… é…åˆ—ã‚·ãƒ£ãƒƒãƒ•ãƒ« */
function shuffleArray(arr){
  const a = [...arr];
  for(let i = a.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* â˜…â˜… ã‚·ã‚§ãƒ•èƒ½åŠ›ã‚’æ¯å›ã‚¬ãƒã§ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¦é…ã‚‹ â˜…â˜… */
async function assignChefAbilitiesForCurrentPlayers(){
  if(!state.roomCode) return;

  // ä»Šãã®éƒ¨å±‹ã«åº§ã£ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€è¦§ã‚’å–å¾—
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const players = Object.entries(tables)
    .filter(([, t]) => t && t.playerId)
    .map(([seatIndex, t]) => ({
      seatIndex: Number(seatIndex),
      playerId:  t.playerId
    }));

  if(!players.length) return;

  // â‘  å¸­é †ã«ä¾å­˜ã—ãªã„ã‚ˆã†ã«ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—ã‚’ä¸€åº¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«
  const shuffledPlayers = shuffleArray(players);

  // â‘¡ èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ä¸€è¦§ã‚‚ã‚·ãƒ£ãƒƒãƒ•ãƒ«
  const shuffledChefIds = shuffleArray(CHEF_DEFS.map(d => d.id));

  // â‘¢ ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ¸ˆã¿ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å¯¾ã—ã¦ã€ä¸Šã‹ã‚‰é †ã«èƒ½åŠ›ã‚’å‰²ã‚Šå½“ã¦
  const chefMap = {};
  shuffledPlayers.forEach((p, i) => {
    const chefId = shuffledChefIds[i % shuffledChefIds.length];
    chefMap[p.playerId] = chefId;
  });

  // â‘£ DB ã«åæ˜ ï¼ˆå¤ã„å‰²ã‚Šå½“ã¦ã‚‚ä¸Šæ›¸ãï¼‰
  await update(ref(db, `rooms/${state.roomCode}`), {
    chefRoles: chefMap,
    chefAssignedAt: Date.now()  // ãŠã¾ã‘ã§ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚‚æ®‹ã—ã¦ãŠãã¨ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„
  });
}

/* â˜… è‡ªåˆ†ãŒæŒ‡å®šã®ã‚·ã‚§ãƒ•èƒ½åŠ›ã‚’æŒã£ã¦ã„ã‚‹ã‹ */
function hasMyChefAbility(chefId){
  return !!(state.chefRoles && state.chefRoles[state.userId] === chefId);
}

/* â˜… è‡ªåˆ†ã®æ‰‹æœ­æšæ•° */
function getMyHandCount(){
  const h = state.hands && state.hands[state.userId];
  if(!h || !Array.isArray(h.cards)) return 0;
  return h.cards.length;
}

/* â˜… å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ã„ã¦ playerId ã®æ‰‹æœ­ã«åŠ ãˆã‚‹ */
async function drawOneCardForPlayer(playerId){
  if(!state.roomCode || !playerId) return false;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const snap    = await get(roomRef);
  const room    = snap.val() || {};

  const hands       = room.hands       || {};
  const usedCards   = room.usedCards   || [];
  const discardPile = room.discardPile || [];
  const exilePile   = room.exilePile   || [];
  const give2Flow   = room.give2Flow   || null;

  const inHands = Object.values(hands).flatMap(h =>
    (h && Array.isArray(h.cards)) ? h.cards : []
  );
  const inUsed     = usedCards.map(c => c && c.value).filter(Boolean);
  const inDiscard  = discardPile.map(c => c && c.value).filter(Boolean);
  const inExile    = exilePile.map(c => c && c.value).filter(Boolean);
  const inGive2    =
    (give2Flow && Array.isArray(give2Flow.cardIds)) ? give2Flow.cardIds : [];

  const taken = [...inHands, ...inUsed, ...inDiscard, ...inExile, ...inGive2];

  // å…¨ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã‹ã‚‰ã€Œå ´ã«å‡ºã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã€ã‚’å¼•ã„ãŸæ®‹ã‚ŠãŒå±±æœ­
  const deck = [...CARD_POOL];
  taken.forEach(val => {
    const idx = deck.indexOf(val);
    if(idx !== -1) deck.splice(idx, 1);
  });

  if(deck.length === 0){
    // å±±æœ­ãŒç©ºãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆãƒ›ã‚¹ãƒˆã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ©Ÿèƒ½ã«ä»»ã›ã‚‹ï¼‰
    return false;
  }

  const index  = Math.floor(Math.random() * deck.length);
  const cardId = deck[index];

  const oldHand = (hands[playerId] && Array.isArray(hands[playerId].cards))
    ? hands[playerId].cards
    : [];
  const newHand = [...oldHand, cardId];

  await update(roomRef, {
    [`hands/${playerId}/cards`]: newHand
  });

  return true;
}
/* â˜… CHEF_BUREAUCRATï¼ˆãƒˆãƒ¬ãƒ¼ï¼‰ï¼šæ¡ä»¶ã‚’æº€ãŸã™ã¨å±±æœ­ã‚¯ãƒªãƒƒã‚¯ã§1ãƒ‰ãƒ­ãƒ¼ */
/* â˜… CHEF_BUREAUCRATï¼ˆãƒˆãƒ¬ãƒ¼ï¼‰ï¼šæ¡ä»¶ã‚’æº€ãŸã™ã¨å±±æœ­ã‚¯ãƒªãƒƒã‚¯ã§1ãƒ‰ãƒ­ãƒ¼ */
async function handleDeckTapForDraw(){
  // éƒ¨å±‹ãªã— or ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã¯ä½•ã‚‚ã—ãªã„
  if(!state.roomCode || !lastGameStarted) return false;

  // è¦³æˆ¦ä¸­ã¯ä¸å¯
  if(state.seatedTable == null) return false;

  // èƒ½åŠ›ã‚’æŒã£ã¦ã„ãªã„ãªã‚‰ä¸å¯
  if(!hasMyChefAbility('CHEF_BUREAUCRAT')) return false;

  // ã€Œæœ€æ–°ã®ã‚¿ãƒ¼ãƒ³è¨˜éŒ²ãŒè‡ªåˆ†ã€ã§ãªã‘ã‚Œã°ä¸å¯
  if(!state.currentTurnPlayerId || state.currentTurnPlayerId !== state.userId){
    return false;
  }

  // æ‰‹æœ­ãŒ4æšã‚ˆã‚Šå¤šã„ã¨ä¸å¯
  if(getMyHandCount() > 4){
    return false;
  }

  // DBä¸Šã® turnState ã‚’ã‚‚ã†ä¸€åº¦ç¢ºèªï¼ˆç«¶åˆãƒ»ãƒ©ã‚°å¯¾ç­–ï¼‰
  const tsRef  = ref(db, `rooms/${state.roomCode}/turnState`);
  const tsSnap = await get(tsRef);
  const ts     = tsSnap.val();

  if(!ts || ts.playerId !== state.userId){
    return false;
  }

  // ã“ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã§ã«èƒ½åŠ›ã‚’ä½¿ã£ã¦ã„ãŸã‚‰ä¸å¯
  if(ts.bureaucratUsed){
    return false;
  }

  // â˜… è¿½åŠ ï¼šèª°ã‹ãŒã‚«ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ä¸­ãªã‚‰ï¼ˆusedCards ãŒæ®‹ã£ã¦ã„ã‚‹ï¼‰å¼•ã‘ãªã„
  const usedSnap = await get(ref(db, `rooms/${state.roomCode}/usedCards`));
  const usedArr  = usedSnap.val() || [];
  if(Array.isArray(usedArr) && usedArr.length > 0){
    return false;
  }

  // å®Ÿéš›ã«1æšãƒ‰ãƒ­ãƒ¼
  const ok = await drawOneCardForPlayer(state.userId);
  if(!ok) return false;

  // ã“ã®ã‚¿ãƒ¼ãƒ³ã§ä½¿ç”¨æ¸ˆã¿ã«ã™ã‚‹
  await update(tsRef, {
    bureaucratUsed: true,
    bureaucratUsedAt: Date.now()
  });

  // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚æ›´æ–°ã—ã¦çŸ¢å°ã‚’å³æ¶ˆã™
  state.bureaucratUsedThisTurn = true;
  updateDeckDrawHint();

  return true;
}


function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? 'ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : '';
  const infoText = `ãƒ«ãƒ¼ãƒ : ${state.roomCode}, åå‰: ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
    if (turnNextBtn) turnNextBtn.classList.remove('hidden');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
    if (turnNextBtn) turnNextBtn.classList.add('hidden');
  }
}

function renderDeckStatus(){
  if (!deckStackEl) return;

  const handsCount = Object.values(state.hands || {}).reduce((sum, hand) => {
    if (hand && Array.isArray(hand.cards)) {
      return sum + hand.cards.length;
    }
    return sum;
  }, 0);

  const usedCount    = state.usedCards   ? state.usedCards.length   : 0;
  const discardCount = state.discardPile ? state.discardPile.length : 0;
  const exileCount   = state.exilePile   ? state.exilePile.length   : 0; // â˜… è¿½åŠ 

  let remain = DECK_TOTAL - handsCount - usedCount - discardCount - exileCount;
  if (remain < 0) remain = 0;

  deckStackEl.innerHTML = '';

  let layers = 0;
  if (remain > 0) {
    const maxLayers = 8;
    const step = DECK_TOTAL / maxLayers;
    layers = Math.ceil(remain / step);
    if (layers < 1) layers = 1;
    if (layers > maxLayers) layers = maxLayers;
  }

  for (let i = 0; i < layers; i++) {
    const card = document.createElement('div');
    card.className = 'deck-card-layer';
    card.style.setProperty('--offset', `${-i * 2}px`);
    card.style.zIndex = String(10 + i);
    deckStackEl.appendChild(card);
  }
}


/* â˜… æ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼ˆå¥‡æ•°äººæ•°ã®ã¨ãï¼‰ã®è¡¨ç¤º */
function renderCenterRoleCard(){
  if(!roleCenterSlot) return;
  roleCenterSlot.innerHTML = '';

  // å¶æ•°äººæ•°ã®ã¨ãã¯ä½•ã‚‚ç½®ã‹ãªã„
  if(!state.centerRole) return;

  // ã ã‚Œã‹ä¸€äººã§ã‚‚æ­£ä½“å…¬é–‹ã—ã¦ã„ã‚‹ã‹
  const anyOpened = state.roleOpenMap && Object.values(state.roleOpenMap).some(v => v && v.opened);

  // å¸¸ã«ã€Œæ¬ ã‘ã‚«ãƒ¼ãƒ‰ã®ã‚¹ãƒ­ãƒƒãƒˆã€ã«ã‚«ãƒ¼ãƒ‰ã¯ç½®ã
  const card = document.createElement('div');
  card.className = 'my-card role-card center-role-card';

  if(!anyOpened){
    // â˜… ã¾ã èª°ã‚‚å…¬é–‹ã—ã¦ã„ãªã„é–“ã¯ã€Œè£å‘ãã€
    const back = document.createElement('div');
    back.className = 'card-back';
    card.appendChild(back);
  }else{
    // â˜… ã ã‚Œã‹ãŒå…¬é–‹ã—ãŸã‚‰ã€ã“ã®æ¬ ã‘ã‚«ãƒ¼ãƒ‰ã‚‚è¡¨å‘ãã§å…¬é–‹
    const face  = document.createElement('div');
    face.className = 'card-face';

    const body = document.createElement('div');
    body.className = 'card-text';
    body.textContent = (state.centerRole === 'LIGHT') ? 'å…‰' : 'å½±';

    face.appendChild(body);
    card.appendChild(face);
  }

  roleCenterSlot.appendChild(card);
}



function renderDiscardPile(){
  if (!discardStackEl) return;
  discardStackEl.innerHTML = '';

  const cards = state.discardPile || [];
  const count = cards.length;
  if (!count) return;

  const maxLayers = 8;
  const layers = Math.min(maxLayers, count);

  for (let i = 0; i < layers - 1; i++) {
    const card = document.createElement('div');
    card.className = 'discard-card-layer';
    card.style.setProperty('--offset', `${-i * 2}px`);
    card.style.zIndex = String(10 + i);
    discardStackEl.appendChild(card);
  }

  const top = cards[count - 1];
  const topIndex = layers - 1 >= 0 ? layers - 1 : 0;
  const topCard = document.createElement('div');
  topCard.className = 'discard-card-layer';
  topCard.style.setProperty('--offset', `${-topIndex * 2}px`);
  topCard.style.zIndex = String(10 + topIndex);

  if (top && top.value != null){
    topCard.appendChild(createCardFace(top.value));
  }
  discardStackEl.appendChild(topCard);
}

function renderExilePile(){
  if(!exileStackEl) return;
  exileStackEl.innerHTML = '';

  const cards = state.exilePile || [];
  const count = cards.length;
  if(!count) return;

  const maxLayers = 8;
  const layers = Math.min(maxLayers, count);

  for (let i = 0; i < layers; i++) {
    const card = document.createElement('div');
    card.className = 'exile-card-layer';
    card.style.setProperty('--offset', `${-i * 2}px`);
    card.style.zIndex = String(10 + i);

    // ä¸€ç•ªä¸Šã®ã‚«ãƒ¼ãƒ‰ã ã‘ä¸­èº«ã‚’è¡¨ç¤º
    if (i === layers - 1) {
      const top = cards[count - 1];
      if (top && top.value){
        card.innerHTML = '';
        card.appendChild(createCardFace(top.value));
      }
    }
    exileStackEl.appendChild(card);
  }
}

function subscribeExilePile(){
  if (!state.roomCode) return;
  const exRef = ref(db, `rooms/${state.roomCode}/exilePile`);
  onValue(exRef, snap => {
    const arr = snap.val() || [];
    state.exilePile = Array.isArray(arr) ? arr : [];
    renderExilePile();
    renderDeckStatus();
  });
}


function subscribeHostState(){
  if (!state.roomCode) return;
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
  });
}

function subscribeGive2Flow(){
  if(!state.roomCode) return;
  const fRef = ref(db, `rooms/${state.roomCode}/give2Flow`);
  onValue(fRef, snap => {
    const data = snap.val() || null;
    state.give2Flow = data;
    renderGive2Overlay();
  });
}


function subscribeHands(){
  if (!state.roomCode) return;
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  updateDeckDrawHint();   
  });
}

function subscribeChefRoles(){
  if(!state.roomCode) return;
  const cRef = ref(db, `rooms/${state.roomCode}/chefRoles`);
  onValue(cRef, snap => {
    state.chefRoles = snap.val() || {};
    // è‡ªåˆ†ã®å‰ã®èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ï¼ˆå·¦ã‚¹ãƒ­ãƒƒãƒˆï¼‰
    renderMyAbilityCard();
    // å…¨å“¡åˆ†ã®ãƒãƒ¼ãƒ ã‚¿ã‚°ã¾ã‚ã‚Šã®èƒ½åŠ›ãƒŸãƒ‹ãƒŸãƒ‹ã‚’æ›´æ–°
    if (latestPlayers.length){
      renderPlayerCircle(latestPlayers);
    }
  updateDeckDrawHint();  
  });
}



function subscribeUsedCards(){
  if (!state.roomCode) return;
  const usedRef = ref(db, `rooms/${state.roomCode}/usedCards`);
  onValue(usedRef, snap => {
    const arr = snap.val() || [];
    state.usedCards = Array.isArray(arr) ? arr : [];
    renderUsedCards();
 updateDeckDrawHint(); 
  });
}

function subscribeDiscardPile(){
  if (!state.roomCode) return;
  const discRef = ref(db, `rooms/${state.roomCode}/discardPile`);
  onValue(discRef, snap => {
    const arr = snap.val() || [];
    state.discardPile = Array.isArray(arr) ? arr : [];
    renderDiscardPile();
    renderDeckStatus();
  });
}
function playDeckShuffleAnimation(){
  if (!deckStackEl) return;
  deckStackEl.classList.add('shuffle-anim');
  setTimeout(() => {
    deckStackEl.classList.remove('shuffle-anim');
  }, 1300); // ã‚¢ãƒ‹ãƒ¡çµ‚äº†å¾Œã«ã‚¯ãƒ©ã‚¹ã‚’å¤–ã™
}

function subscribeShuffleAnim(){
  if (!state.roomCode) return;
  const sRef = ref(db, `rooms/${state.roomCode}/shuffleInfo/lastShuffleAt`);

  onValue(sRef, snap => {
    const v = snap.val();
    if (typeof v !== 'number') return;
    if (v === 0 || v === lastShuffleAtHandled) return;

    lastShuffleAtHandled = v;
    playDeckShuffleAnimation();
  });
}

function subscribeGameStarted(){
  if (!state.roomCode) return;
  const gameRef = ref(db, `rooms/${state.roomCode}/gameStarted`);
  onValue(gameRef, snap => {
    const v = !!snap.val();

    if (v) {
      // ã‚²ãƒ¼ãƒ ãŒã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€çŠ¶æ…‹ã«ãªã£ãŸã¨ãã ã‘å‘¼ã°ã‚Œã‚‹
      ensureDiceArea();
      ensureCubeArea();

      // â˜… å‰ã®ã‚²ãƒ¼ãƒ ã®ã€Œæœ€åˆã®ãƒ€ã‚¤ã‚¹ã‚¿ãƒƒãƒã§è¦—ã„ãŸæ­£ä½“ã€ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‹ã‚‰å…¨æ¶ˆå»
      for (const key in firstPeekTargets) {
        delete firstPeekTargets[key];
      }

      // â˜… ä¸‡ä¸€ã€æ­£ä½“ã‚’è¦‹ã‚‹ãƒãƒƒãƒ—ãŒé–‹ã„ã¦ã„ãŸã‚‰é–‰ã˜ã¦ãŠã
      if (peekRolePop) {
        peekRolePop.classList.add('hidden');
      }
    }

    // ãƒ•ãƒ©ã‚°æ›´æ–°
    lastGameStarted = v;
    updateDeckDrawHint();

    // â˜… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å††ã‚’æãç›´ã—ã¦ã€ã•ã£ãæ¶ˆã—ãŸè¦—ãæƒ…å ±ã‚’åæ˜ ã•ã›ã‚‹
    if (latestPlayers.length) {
      renderPlayerCircle(latestPlayers);
    }
  });
}



function subscribeTurnState(){
  if(!state.roomCode) return;
  const tRef = ref(db, `rooms/${state.roomCode}/turnState`);

  onValue(tRef, snap => {
    const v = snap.val();

    // â˜… ã“ã“ã‚’ã€ŒãŸã  returnã€ã§ã¯ãªãã€ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã‚ˆã†ã«å¤‰æ›´
    if(!v || !v.playerName){
      state.currentTurnSeat = null;
      state.currentTurnPlayerId = null;
      state.bureaucratUsedThisTurn = false;

      // â˜… å‰ã‚²ãƒ¼ãƒ ã®æƒ…å ±ã‚’ã‚¯ãƒªã‚¢
      lastTurnSeatIndex = null;
      lastTurnPlayerId  = null;

      updateDeckDrawHint();
      return;
    }

    const newSeatIndex = (v.seatIndex ?? null);
    const newPlayerId  = (v.playerId  ?? null);

    // â˜… ã€Œã‚¿ãƒ¼ãƒ³ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¤‰ã‚ã£ãŸã‹ï¼Ÿã€ã‚’åˆ¤å®š
    const turnChanged =
      (newSeatIndex !== lastTurnSeatIndex) ||
      (newPlayerId  !== lastTurnPlayerId);

    // state ã‚’æ›´æ–°
    state.currentTurnSeat      = newSeatIndex;
    state.currentTurnPlayerId  = newPlayerId;
    state.bureaucratUsedThisTurn = !!v.bureaucratUsed;
    updateDeckDrawHint();

    // â˜… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¤‰ã‚ã£ãŸã¨ãã ã‘ãƒãƒŠãƒ¼ã‚’æµã™
    if (turnChanged){
      playTurnBanner(v.playerName);
      lastTurnSeatIndex = newSeatIndex;
      lastTurnPlayerId  = newPlayerId;
    }

    // â˜… æœ€åˆã®ã‚¿ãƒ¼ãƒ³ & æ­£ä½“ç¢ºèªã¾ã  & è‡ªåˆ†ã®å¸­ã®ã¨ãã ã‘ firstTurnPeek ã‚’èµ·å‹•
    if(
      v.isFirstTurn &&
      !v.firstPeekDone &&
      state.seatedTable != null &&
      state.seatedTable === state.currentTurnSeat
    ){
      startFirstTurnPeek();
    }
  });
}


/* â˜… åˆå›ã‚¿ãƒ¼ãƒ³ã®äººã ã‘ã«ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ã€ãƒãƒƒãƒ—ã‚’å‡ºã™ */
function startFirstTurnPeek(){
  if (firstTurnPeekStarted) return; // äºŒé‡èµ·å‹•é˜²æ­¢
  firstTurnPeekStarted = true;

  if (!peekRolePop) return;
  // æ—¢å­˜ã®ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ãƒãƒƒãƒ—ã€ã‚’ãã®ã¾ã¾åˆ©ç”¨
  peekRolePop.classList.remove('hidden');
}

/* â˜… è‡ªåˆ†ã®èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ï¼ˆå·¦ã‚¹ãƒ­ãƒƒãƒˆï¼‰ã‚’æç”» */
function renderMyAbilityCard(){
  renderMyPanelsInOrder();
}

/* â˜… æ‹¡å¤§ãƒãƒƒãƒ—è¡¨ç¤ºï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚’æ‹¡å¤§ã‚«ãƒ¼ãƒ‰å†…ã®ä¸‹éƒ¨ã«æ›¸ãè¾¼ã‚€ï¼‰ */
function showAbilityOverlay(chefId){
  if(!abilityOverlay || !abilityOverlayCard) return;
  const def = getChefDef(chefId);
  if(!def) return;

  abilityOverlay.classList.remove('hidden');
  abilityOverlayCard.innerHTML = '';

  // æ‹¡å¤§ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰æœ¬ä½“ï¼ˆãƒŸãƒ‹ã¨åŒã˜æ¯”ç‡ã§scaleï¼‰
  const header = document.createElement('div');
  header.className = 'ability-mini-card ability-card-large-header';

  // ãƒŸãƒ‹ã¨åŒã˜ä¸­èº«ï¼ˆåå‰ã‚¿ã‚°ï¼‹å›³å½¢ï¼‰
  const face = createChefMiniFace(chefId);

  // â˜… ã‚«ãƒ¼ãƒ‰å†…ã®ä¸‹éƒ¨ã«å…¥ã‚Œã‚‹èª¬æ˜ãƒ†ã‚­ã‚¹ãƒˆ
  const detail = document.createElement('div');
  detail.className = 'ability-detail-text';
  detail.textContent = def.detail;

  // ability-face ã®æœ«å°¾ã«èª¬æ˜ã‚’è¿½åŠ  â†’ ã€Œã‚«ãƒ¼ãƒ‰å†…ã®ä¸‹éƒ¨ã€ã«è¡¨ç¤ºã•ã‚Œã‚‹
  face.appendChild(detail);

  header.appendChild(face);

  // abilityOverlayCard ã«ã¯ã€ã“ã®æ‹¡å¤§ã‚«ãƒ¼ãƒ‰1æšã ã‘ã‚’å…¥ã‚Œã‚‹
  abilityOverlayCard.appendChild(header);
}

/* â˜… èƒ½åŠ›æ‹¡å¤§ãƒãƒƒãƒ—ï¼šå¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ */
if (abilityOverlay){
  abilityOverlay.addEventListener('click', (e)=>{
    // èƒŒæ™¯ï¼ˆé»’ã„ã¨ã“ã‚ï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã ã‘é–‰ã˜ã‚‹
    if (e.target === abilityOverlay){
      abilityOverlay.classList.add('hidden');
    }
  });
}

/* ã‚«ãƒ¼ãƒ‰éƒ¨åˆ†ã®ã‚¯ãƒªãƒƒã‚¯ã¯é–‰ã˜ãªã„ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ­¢ã‚ã‚‹ */
if (abilityOverlayCard){
  abilityOverlayCard.addEventListener('click', (e)=>{
    e.stopPropagation();
  });
}


function renderMyRoleCard(){
  renderMyPanelsInOrder();
}
/* â˜… è‡ªåˆ†ã®å¸­ã«ä»˜ã„ã¦ã„ã‚‹èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ã®æ•°ã‚’æ•°ãˆã‚‹ */
function countCubesOnMySeat(){
  if(state.seatedTable == null) return 0;
  let count = 0;
  Object.values(latestCubeData || {}).forEach(c => {
    if(!c) return;
    if(c.attachedSeat === state.seatedTable) count++;
  });
  return count;
}

async function onMyRoleCardClick(){
  if(!state.roomCode) return;

  // ã™ã§ã«è‡ªåˆ†ã¯å…¬é–‹æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
  if (state.roleOpenMap && state.roleOpenMap[state.userId] && state.roleOpenMap[state.userId].opened) {
    return;
  }

  const cubeCount = countCubesOnMySeat();
  // â˜… èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ãŒ3ã¤æœªæº€ãªã‚‰ä½•ã‚‚èµ·ã“ã•ãªã„ï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãªã—ï¼‰
  if (cubeCount < 3){
    return;
  }

  // â˜… è‡ªåˆ†å°‚ç”¨ã®ãƒ•ãƒ©ã‚°ã‚’æ›¸ãè¾¼ã‚€
  const openRef = ref(db, `rooms/${state.roomCode}/rolesOpen/${state.userId}`);
  await set(openRef, {
    opened: true,
    openedAt: Date.now()
  });
}



function renderMyHand(){
  renderMyPanelsInOrder();
}

function renderUsedCards(){
  usedCardsArea.innerHTML = '';

  const arr = state.usedCards || [];
  let cardToShow = null;

  if (arr.length) {
    const lastUsed = arr[arr.length - 1];

    const disc = state.discardPile || [];
    const topDiscard = disc.length ? disc[disc.length - 1] : null;

    if (
      topDiscard &&
      lastUsed &&
      topDiscard.value === lastUsed.value &&
      topDiscard.ownerId === lastUsed.ownerId &&
      topDiscard.usedAt === lastUsed.usedAt
    ) {
      cardToShow = null;
    } else {
      cardToShow = lastUsed;
    }
  }

  if (cardToShow) {
    // â˜… ãƒ©ãƒƒãƒ‘ï¼ˆåå‰ãƒ©ãƒ™ãƒ«ï¼‹ã‚«ãƒ¼ãƒ‰æœ¬ä½“ï¼‰
    const wrap = document.createElement('div');
    wrap.className = 'used-card-wrapper';

    // å‡ºã—ãŸäººã®åå‰ã‚’å–å¾—
    const ownerName = getPlayerNameById(cardToShow.ownerId);
    if (ownerName) {
      const ownerTag = document.createElement('div');
      ownerTag.className = 'used-card-owner';
      ownerTag.textContent = ownerName;
      wrap.appendChild(ownerTag);
    }

    const card = document.createElement('div');
    card.className = 'used-card';
    card.appendChild(createCardFace(cardToShow.value));
    card.addEventListener('dblclick', onUsedCardDblClick);

    wrap.appendChild(card);
    usedCardsArea.appendChild(wrap);
  }


  renderDeckStatus();
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length){
    renderPlayerCircle(latestPlayers);
  }
  renderDeckStatus();
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl){
  inputCode.value = roomFromUrl;
}

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || 'åç„¡ã—';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  if (state.seatedTable === null) {
    seatPop.classList.remove('hidden');
  } else {
    seatPop.classList.add('hidden');
  }
  subscribePlayers();
  subscribeHostState();
  subscribeHands();
  subscribeGameStarted();
  subscribeDice();
  subscribeUsedCards();
  subscribeDiscardPile();
  subscribeExilePile();  
  subscribeTurnState();
  subscribeCubes();
  subscribeShuffleAnim();
  subscribeRoles();
  subscribeRoleOpen();
  subscribeGive2Flow();
  subscribePeekRoleGlobal();
  subscribeShuffle3Global(); 
  subscribePeekRoleView();
  subscribeRoles();
  subscribeRoleOpen();
  subscribeChefRoles();
  renderDeckStatus();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'ã‚³ãƒ”ãƒ¼å®Œäº†';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='ãƒªãƒ³ã‚¯ã‚³ãƒ”ãƒ¼';
    },1500);
  } catch {
    prompt('ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„', url);
  }
});

/* å±±æœ­ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆé•·æŠ¼ã—ã§é…ã‚‹ãƒãƒƒãƒ—è¡¨ç¤ºï¼‰ */
if (deckStackEl){
  deckStackEl.addEventListener('pointerdown', onDeckPointerDown);
  deckStackEl.addEventListener('pointermove', onDeckPointerMove);
  deckStackEl.addEventListener('pointerup', onDeckPointerUp);
  deckStackEl.addEventListener('pointercancel', onDeckPointerUp);
}


function renderGive2Overlay(){
  if(!give2Overlay || !give2CardsEl){
    return;
  }
  const flow = state.give2Flow;
  if(!flow || !flow.active){
    give2Overlay.classList.add('hidden');
    clearGive2LongPressTimer();
    give2PointerId = null;
    give2ActiveCardEl = null;
    give2KeepIndex = null;

    // â˜… ã“ã“ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒãƒƒãƒ—ã¨ä¸­å¤®ã‚«ãƒ¼ãƒ‰ã‚‚æ¶ˆã—ã¦ãŠã
    hideGive2TargetPop();
    if(give2CenterCard){
      give2CenterCard.classList.add('hidden');
      give2CenterCard.innerHTML = '';
    }

    // ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ãƒãƒƒãƒ—ã‚‚å¿µã®ãŸã‚é–‰ã˜ã‚‹
    closeUseCardDialog?.();
    // ãƒ•ãƒ­ãƒ¼çµ‚äº†æ™‚ã¯ãƒ€ã‚¤ã‚¹ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ï¼ˆä»–ã®ãƒ­ãƒƒã‚¯ã¯ãã‚Œãã‚Œã®å‡¦ç†ã§åˆ¶å¾¡ï¼‰
    setDiceLocked(false);
    return;
  }

  const isOwner = (flow.ownerId === state.userId);
  const cardIds = flow.cardIds || [];

  if (give2HintEl){
    if (isOwner){
      // ä½¿ç”¨è€…æœ¬äººã«ã¯ã€æ“ä½œèª¬æ˜ã‚’è¡¨ç¤º
      give2HintEl.textContent = 'ã»ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’è‡ªåˆ†ã«ã‚ˆã›ã‚‹ã€‚ã‚ã’ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é•·æŠ¼ã—ã™ã‚‹';
    } else {
      // ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã¯ã€Œ(ä½¿ç”¨è€…)ãŒé¸æŠä¸­ã€ã¨ã ã‘è¡¨ç¤º
      const ownerName = getPlayerNameById(flow.ownerId) || 'èª°ã‹';
      give2HintEl.textContent = `ã€Œ${ownerName}ã€ãŒé¸æŠä¸­`;
    }
  }

  // å‡¦ç†ä¸­ã¯ãƒ€ã‚¤ã‚¹ã‚’å®Œå…¨ãƒ­ãƒƒã‚¯
  setDiceLocked(true);

  give2Overlay.classList.remove('hidden');
  give2CardsEl.innerHTML = '';
  give2KeepIndex = null;

  cardIds.forEach((cid, idx)=>{
    const card = document.createElement('div');
    card.className = 'my-card give2-card';
    card.dataset.cardIndex = String(idx);

    if(isOwner){
      // è‡ªåˆ†ã ã‘ã‚«ãƒ¼ãƒ‰ã®ä¸­èº«ãŒè¦‹ãˆã‚‹
      card.appendChild(createCardFace(cid));
      setupGive2CardInteractions(card);
    }else{
      // ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã¯è£é¢ã ã‘
      const back = document.createElement('div');
      back.className = 'card-back';
      card.appendChild(back);
    }

    give2CardsEl.appendChild(card);
  });
}

/* â˜… è‡ªåˆ†ã®ã€Œèƒ½åŠ›ï¼æ­£ä½“ï¼æ‰‹æœ­ã€ã‚’ã¾ã¨ã‚ã¦é †ç•ªåˆ¶å¾¡ã—ã¦æç”»ã™ã‚‹ä¸­æ¢é–¢æ•° */
function renderMyPanelsInOrder(){
  if (!myAbilitySlot || !myRoleSlot || !myHandEl) return;

  // ã„ã£ãŸã‚“å…¨éƒ¨ç©ºã«ã™ã‚‹
  myAbilitySlot.innerHTML = '';
  myRoleSlot.innerHTML = '';
  myHandEl.innerHTML    = '';

  const myId = state.userId;
  const chefId  = state.chefRoles && state.chefRoles[myId];
  const myRole  = state.roles     && state.roles[myId];
  const handObj = state.hands     && state.hands[myId];
  const handArr = handObj && Array.isArray(handObj.cards) ? handObj.cards : [];

  const hasAbility = !!chefId;
  const hasRole    = !!myRole;
  const hasHand    = handArr.length > 0;

  /* â‘  èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ï¼ˆã‚ã‚‹ãªã‚‰å¿…ãšæœ€åˆã«æãï¼‰ */
  if (hasAbility){
    const abilityCard = document.createElement('div');
    abilityCard.className = 'ability-mini-card';
    abilityCard.appendChild(createChefMiniFace(chefId));
    abilityCard.addEventListener('click', () => {
      showAbilityOverlay(chefId);
    });
    myAbilitySlot.appendChild(abilityCard);
  }

  /* â‘¡ æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼š
        - èƒ½åŠ›ãŒã¾ã é…ã‚‰ã‚Œã¦ã„ãªã„ãªã‚‰ã€æ­£ä½“ã‚‚ã¾ã æã‹ãªã„
        - èƒ½åŠ›ï¼‹æ­£ä½“ãŒãã‚ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ä¸€æ°—ã«å‡ºã™ */
  if (hasAbility && hasRole){
    const card = document.createElement('div');
    card.className = 'my-card role-card';

    // â˜… CSS ã§è¦‹ãŸç›®ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ãŸã‚ã®ç¨®åˆ¥
    card.dataset.roleType = myRole.type;   // 'LIGHT' / 'DARK' ãªã©

    // ä¸­èº«ï¼ˆãƒ†ã‚­ã‚¹ãƒˆï¼‰ã¯ã„ã£ãŸã‚“ãƒ€ãƒŸãƒ¼ã§OKï¼ˆCSSå´ã§éè¡¨ç¤ºã«ã™ã‚‹ï¼‰
    const face = document.createElement('div');
    face.className = 'card-face';

    const body = document.createElement('div');
    body.className = 'card-text';
    // â˜… ãƒ†ã‚­ã‚¹ãƒˆã¯å…¥ã‚Œãªã„ï¼å…¥ã‚Œã¦ã‚‚ CSS ã§ display:none
    body.textContent = ''; 

    face.appendChild(body);
    card.appendChild(face);

    // ã‚¯ãƒªãƒƒã‚¯ã§æ­£ä½“å…¬é–‹ï¼ˆå¾“æ¥ã©ãŠã‚Šï¼‰
    card.addEventListener('click', onMyRoleCardClick);

    myRoleSlot.appendChild(card);
  }

  /* â‘¢ æ‰‹æœ­ï¼š
        - èƒ½åŠ›ï¼‹æ­£ä½“ãŒãã‚ã†ã¾ã§æã‹ãªã„
        - 3ã¤ãã‚ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§åˆã‚ã¦æ‰‹æœ­ã‚’æç”» */
  if (hasAbility && hasRole && hasHand){
    handArr.forEach((cardId, idx) => {
      const card = document.createElement('div');
      card.className = 'my-card';
      card.dataset.index = String(idx);
      card.dataset.value = String(cardId);
      card.appendChild(createCardFace(cardId));
      card.addEventListener('click', onMyCardClick);
      myHandEl.appendChild(card);
    });
  }
}



function setupGive2CardInteractions(card){
  // pointerdownï¼šãƒ‰ãƒ©ãƒƒã‚° or é•·æŠ¼ã—ã®é–‹å§‹
card.addEventListener('pointerdown', (e)=>{
  const flow = state.give2Flow;
  if(!flow || !flow.active) return;
  if(flow.ownerId !== state.userId) return; // ä½¿ç”¨è€…æœ¬äººã ã‘æ“ä½œå¯

  // â˜… ã™ã§ã«ã€Œã»ã—ã„ã‚«ãƒ¼ãƒ‰ã€ãŒæ±ºã¾ã£ã¦ã„ãŸã‚‰ã€ã‚‚ã†è§¦ã‚‰ã›ãªã„
  if(give2KeepIndex != null) return;

  give2PointerId = e.pointerId;    give2DownX = e.clientX;
    give2DownY = e.clientY;
    give2ActiveCardEl = card;
    give2LongPressTriggered = false;
    give2Dragging = false;

    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ç‚¹ã®ã‚«ãƒ¼ãƒ‰ä¸­å¿ƒåº§æ¨™ã‚’è¨˜éŒ²ï¼ˆã‚¹ãƒŠãƒƒãƒ—è¨ˆç®—ç”¨ï¼‰
    const r0 = card.getBoundingClientRect();
    card.dataset.startCx = String(r0.left + r0.width  / 2);
    card.dataset.startCy = String(r0.top  + r0.height / 2);

    card.style.transition = 'none';

    clearGive2LongPressTimer();
give2LongPressTimer = setTimeout(()=>{
  // ã™ã§ã«ãƒ•ãƒ­ãƒ¼çµ‚äº† or ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„
  if(!state.give2Flow || !state.give2Flow.active) return;
  if(give2Dragging) return;

  give2LongPressTriggered = true;
  const idx = Number(card.dataset.cardIndex || '-1');
  const cardId = getGive2CardIdByIndex(idx);
  if(cardId){
    // â˜… é•·æŠ¼ã—ã—ãŸã€Œãã®ã‚«ãƒ¼ãƒ‰ã€ã®ä¸Šã«ãƒãƒƒãƒ—ã‚’å‡ºã™
    showGive2TargetPop(cardId, card);
  }
}, LONG_PRESS_MS);


    card.classList.add('dragging');
    card.setPointerCapture(give2PointerId);
  });

  // pointermoveï¼šãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ä½ç½®æ›´æ–°ï¼‹é•·æŠ¼ã—ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  card.addEventListener('pointermove', (e)=>{
    if(give2PointerId == null || e.pointerId !== give2PointerId) return;

    const dx = e.clientX - give2DownX;
    const dy = e.clientY - give2DownY;

    // ä¸€å®šä»¥ä¸Šå‹•ã„ãŸã‚‰ã€Œãƒ‰ãƒ©ãƒƒã‚°ã€ã¨ã¿ãªã—ã€é•·æŠ¼ã—ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    if(!give2Dragging &&
       (Math.abs(dx) > LONG_PRESS_MOVE_TOL || Math.abs(dy) > LONG_PRESS_MOVE_TOL)){
      give2Dragging = true;
      clearGive2LongPressTimer();
    }

    if(give2Dragging){
      card.style.transform = `translate(${dx}px, ${dy}px)`;
    }
  });

  const endPointer = (e)=>{
    if(give2PointerId == null || e.pointerId !== give2PointerId) return;

    clearGive2LongPressTimer();
    try{ card.releasePointerCapture(give2PointerId); }catch{}

    const wasLong     = give2LongPressTriggered;
    const wasDragging = give2Dragging;

    give2PointerId = null;
    give2ActiveCardEl = null;
    give2LongPressTriggered = false;
    give2Dragging = false;

    card.classList.remove('dragging');

    // é•·æŠ¼ã—ã ã£ãŸå ´åˆï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠãƒãƒƒãƒ—ã‚’å‡ºã—ã¦ã„ã‚‹ã ã‘ãªã®ã§ä½ç½®ã¯å…ƒã«æˆ»ã™
    if(wasLong){
      card.style.transition = 'transform .2s ease-out';
      card.style.transform  = '';
      return;
    }

    // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ã®å‡¦ç†
  if(wasDragging){
    // â˜… ãƒãƒƒãƒ—ã®ä¸‹ï¼‹ä¸‹æ ã‚ˆã‚Š20pxä¸‹ã§é›¢ã—ãŸã‚‰ã€Œè‡ªåˆ†ã®æ‰‹æœ­ã«ã™ã‚‹ã€
    if(isDropForKeepByPanel(e)){
      // è¦‹ãŸç›®ä¸Šï¼šæ‰‹æœ­æ–¹å‘ã«ã‚¹ãƒŠãƒƒãƒ—
      snapGive2CardToHand(card);

      const idx = Number(card.dataset.cardIndex || '-1');
      if(idx >= 0){
        // ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’ã€Œã»ã—ã„ã‚«ãƒ¼ãƒ‰ã€ã¨ã—ã¦ç¢ºå®š
        markGive2KeepIndex(idx);

        // æ®‹ã‚Š1æšã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­å¤®ã«å‡ºã—ã¦ã€ãã®ä¸Šã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠãƒãƒƒãƒ—
        const otherIdx = (idx === 0 ? 1 : 0);
        const otherId  = getGive2CardIdByIndex(otherIdx);

        if(otherId){
          showGive2CenterCard(otherId);
          // â˜… ãƒ†ãƒ¼ãƒ–ãƒ«ä¸­å¤®ã®ã‚«ãƒ¼ãƒ‰ã®ä¸Šã«ãƒãƒƒãƒ—ã‚’å‡ºã™
          showGive2TargetPop(otherId, give2CenterCard);
        }
      }

      // ä½¿ç”¨è€…æœ¬äººã®ç”»é¢ã§ã¯ãƒãƒƒãƒ—æœ¬ä½“ã¯é–‰ã˜ã¦ãŠã
      give2Overlay.classList.add('hidden');
    }else{
      // æ¡ä»¶ã‚’æº€ãŸã•ãªã‘ã‚Œã°å…ƒã®ä½ç½®ã«æˆ»ã™
      card.style.transition = 'transform .2s ease-out';
      card.style.transform  = '';
    }
    return;
  }


  };

  card.addEventListener('pointerup', endPointer);
  card.addEventListener('pointercancel', endPointer);
}

function hideGive2TargetPop(){
  if(!give2TargetPop) return;
  give2TargetPop.classList.add('hidden');

  // â˜… ä½ç½®æŒ‡å®šã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæ¬¡å›ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã«æˆ»ã›ã‚‹ã‚ˆã†ã«ï¼‰
  give2TargetPop.style.left = '';
  give2TargetPop.style.top = '';
  give2TargetPop.style.bottom = '';
  give2TargetPop.style.transform = '';
}

// â˜… anchorEl ã‚’è¿½åŠ ï¼šãã®ã‚«ãƒ¼ãƒ‰ã®ä¸Šã‚ãŸã‚Šã«ãƒãƒƒãƒ—ã‚’å‡ºã™
// â˜… å¤‰æ›´å¾Œï¼šasync åŒ–ã—ã¦ã€å€™è£œ0äººã®ã¨ãã¯æ¨ã¦æœ­ã«é€ã‚‹
async function showGive2TargetPop(cardId, anchorEl){
  if(!give2TargetPop || !give2TargetList) return;
  const flow = state.give2Flow;
  if(!flow || !flow.active) return;
  if(flow.ownerId !== state.userId) return;

  give2TargetList.innerHTML = '';

  // å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šæ‰‹æœ­4æšä»¥ä¸‹ï¼†èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–2å€‹ä»¥ä¸‹
  const candidates = [];

  latestPlayers.forEach(p=>{
    if(p.id === state.userId) return;  // è‡ªåˆ†ä»¥å¤–

    const handData = state.hands[p.id];
    const cards = (handData && Array.isArray(handData.cards)) ? handData.cards : [];
    if(cards.length > 4) return;

    // ã“ã®å¸­ã«ã¤ã„ã¦ã„ã‚‹èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–æ•°ã‚’æ•°ãˆã‚‹
    let cubeCount = 0;
    Object.values(latestCubeData || {}).forEach(c=>{
      if(!c) return;
      if(c.attachedSeat === p.seatIndex) cubeCount++;
    });
    if(cubeCount > 2) return;

    candidates.push(p);
  });

  // â˜… æ¸¡ã›ã‚‹ç›¸æ‰‹ãŒ1äººã‚‚ã„ãªã„å ´åˆ â†’ ãã®ã‚«ãƒ¼ãƒ‰ã‚’æ¨ã¦æœ­ã¸
  if(!candidates.length){
    await finishGive2Flow(null, cardId, { discardIfNoTarget: true });
    hideGive2TargetPop();   // å¿µã®ãŸã‚ãƒãƒƒãƒ—ã‚‚é–‰ã˜ã‚‹
    return;
  }

  // ã“ã“ã‹ã‚‰å…ˆã¯ã€Œå°‘ãªãã¨ã‚‚1äººã¯æ¸¡ã›ã‚‹ç›¸æ‰‹ãŒã„ã‚‹ã€å ´åˆ
  candidates.forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'btn';
    // â˜…ã“ã“ã‚’å¤‰æ›´ï¼šå¸­ç•ªå·ã‚’è¡¨ç¤ºã›ãšã€åå‰ã ã‘ã«ã™ã‚‹
    btn.textContent = p.name;
    btn.onclick = async ()=>{
      await finishGive2Flow(p.id, cardId);
      hideGive2TargetPop();
    };
    give2TargetList.appendChild(btn);
  });


  give2TargetPop.classList.remove('hidden');

  // â˜… ä½ç½®æ±ºã‚
  if(anchorEl){
    // ã‚«ãƒ¼ãƒ‰ã®ä¸Šã«ãƒãƒƒãƒ—ã‚’å‡ºã™
    const r = anchorEl.getBoundingClientRect();
    const popRect = give2TargetPop.getBoundingClientRect();

    const left = r.left + r.width / 2 - popRect.width / 2;
    const top  = r.top  - popRect.height - 8;

    give2TargetPop.style.left = left + 'px';
    give2TargetPop.style.top  = top  + 'px';
    give2TargetPop.style.bottom = 'auto';
    give2TargetPop.style.transform = 'none';
  }else{
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šç”»é¢ä¸‹ä¸­å¤®
    give2TargetPop.style.left = '50%';
    give2TargetPop.style.top  = 'auto';
    give2TargetPop.style.bottom = '90px';
    give2TargetPop.style.transform = 'translateX(-50%)';
  }
}




// â˜… å¤‰æ›´å¾Œï¼šæ¸¡ã™ç›¸æ‰‹ãªã—ã®å ´åˆã¯æ¨ã¦æœ­ã«é€ã‚Œã‚‹ã‚ˆã†ã«æ‹¡å¼µ
async function finishGive2Flow(targetPlayerId, giveCardId, options = {}){
  if(!state.roomCode) return;
  const flow = state.give2Flow;
  if(!flow || !flow.active) return;
  if(flow.ownerId !== state.userId) return;
  if(!giveCardId) return;

  const { discardIfNoTarget = false } = options;

  const ownerId = state.userId;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};
  const hands = roomData.hands || {};

  const ownerHandData = hands[ownerId] || { cards: [] };
  const ownerCards = Array.isArray(ownerHandData.cards) ? [...ownerHandData.cards] : [];

  // ã‚ªãƒ¼ãƒŠãƒ¼ã®æ‰‹æœ­ã‹ã‚‰ã€ŒgiveCardIdã€ã‚’1æšã ã‘æŠœã
  const idx = ownerCards.indexOf(giveCardId);
  if(idx >= 0){
    ownerCards.splice(idx, 1);
  }

  const updates = {};
  updates[`hands/${ownerId}/cards`] = ownerCards;
  updates[`give2Flow`] = null;    // ãƒ•ãƒ­ãƒ¼çµ‚äº†

  if (targetPlayerId){
    // â–¼ é€šå¸¸ï¼šèª°ã‹ã«æ¸¡ã™
    const targetHandData = hands[targetPlayerId] || { cards: [] };
    const targetCards = Array.isArray(targetHandData.cards) ? [...targetHandData.cards] : [];
    targetCards.push(giveCardId);
    updates[`hands/${targetPlayerId}/cards`] = targetCards;
  } else if (discardIfNoTarget){
    // â–¼ æ¸¡ã™ç›¸æ‰‹ãŒã„ãªã„ â†’ æ¨ã¦æœ­ã¸
    let discArr = Array.isArray(roomData.discardPile) ? [...roomData.discardPile] : [];
    discArr.push({
      value:  giveCardId,
      ownerId: ownerId,
      usedAt: Date.now()
    });
    updates[`discardPile`] = discArr;
  }

  await update(roomRef, updates);

  // ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ã‚’1ç§’å¾Œã«æ¨ã¦æœ­ã¸ï¼ˆã€Œã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãã€1æšã‚’æ¸¡ã™ã€è‡ªä½“ã®å‡¦ç†ï¼‰
  const usedMeta = flow.usedMeta;
  if(
    usedMeta &&
    usedMeta.value   === 'TURN_DRAW2_KEEP_GIVE1' &&
    usedMeta.ownerId === ownerId
  ){
    setTimeout(()=>{
      autoMoveUsedCardToDiscard(usedMeta);
    }, 1000);
  }
}



async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;
  try{
    seatTabs.innerHTML = '';
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const hasMaxPlayers = !!roomData.maxPlayers;
    const maxPlayers = roomData.maxPlayers || 8;

    /* â˜… éãƒ›ã‚¹ãƒˆ & äººæ•°æœªé¸æŠ â†’ å¸­ãƒãƒƒãƒ—å‡ºã•ãšãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã ã‘ */
    if (!state.isHost && !hasMaxPlayers){
      seatPop.classList.add('hidden');
      if (waitMaxPlayersMessage) {
        waitMaxPlayersMessage.classList.remove('hidden');
      }
      return;
    }

    /* â˜… ã“ã“ã¾ã§æ¥ãŸã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯æ¶ˆã—ã¦OK */
    if (waitMaxPlayersMessage){
      waitMaxPlayersMessage.classList.add('hidden');
    }

    if(state.isHost && !hasMaxPlayers){
      // â˜… ãƒ›ã‚¹ãƒˆã¯äººæ•°é¸æŠç”»é¢ã‚’å‡ºã™
      seatLabel.textContent = 'äººæ•°ã‚’é¸æŠ';
      for(let i=2;i<=8;i++){
        const tab = document.createElement('div');
        tab.className='tab';
        tab.textContent=i;
        tab.onclick = async () => {
          await update(roomRef,{maxPlayers:i});
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef,{playerId:state.userId,playerName:state.userName});
          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
    }else{
      // â˜… maxPlayers æ±ºå®šå¾Œï¼šé€šå¸¸ã®å¸­é¸æŠ
      seatLabel.textContent = 'å¸­ã‚’é¸æŠ';
      const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
      const tables = tablesSnap.val() || {};
      for(let i=1;i<=maxPlayers;i++){
        const tab = document.createElement('div');
        tab.className='tab';
        tab.textContent=i;
        const t = tables[i];
        if(t && t.playerId) tab.classList.add('disabled');
        tab.onclick = async () => {
          if(tab.classList.contains('disabled')) return;
          const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
          await set(tRef,{playerId:state.userId,playerName:state.userName});
          tab.classList.add('disabled');
          state.seatedTable = i;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
    }
  }finally{
    isRenderingSeatTabs=false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex,t]) => (t && t.playerId ? {
        id:t.playerId,
        name:t.playerName||'åç„¡ã—',
        seatIndex:Number(seatIndex)
      }:null))
      .filter(Boolean)
      .sort((a,b)=>a.seatIndex-b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p=>p.id===state.userId);
    if(mySeat && state.seatedTable===null){
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p=>p.id===state.userId);
    if(!meStillSeated && state.seatedTable!==null){
      state.seatedTable = null;
      await renderSeatTabs();
      seatPop.classList.remove('hidden');
    }
    if (state.seatedTable === null){
      // ãƒ†ãƒ¼ãƒ–ãƒ«ã«èª°ã‚‚ã„ãªã„ â†’ ãƒ›ã‚¹ãƒˆãŒäººæ•°é¸æŠå‰
      if (players.length === 0){
        await renderSeatTabs();         // éãƒ›ã‚¹ãƒˆãªã‚‰ã€Œãƒ›ã‚¹ãƒˆãŒäººæ•°ã‚’é¸æŠä¸­ã§ã™ã€‚ã€è¡¨ç¤º
      }else{
        // ã‚‚ã†èª°ã‹ã¯ç€å¸­ã—ã¦ã„ã‚‹ â†’ å¸­é¸æŠãƒãƒƒãƒ—ã‚’å‡ºã™
        await renderSeatTabs();
        seatPop.classList.remove('hidden');
      }
    }
    renderPlayerCircle(players);
  });
}

// â˜… ownerId ã‹ã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’å–å¾—ï¼ˆtables ã®æƒ…å ±ã‚’ä½¿ç”¨ï¼‰
function getPlayerNameById(playerId){
  if (!playerId) return '';
  const p = latestPlayers.find(pl => pl.id === playerId);
  return p ? p.name : '';
}


function renderPlayerCircle(players){
  if(!playerCircle) return;

  const diceEl = diceArea;
  playerCircle.innerHTML = '';
  if (diceEl) playerCircle.appendChild(diceEl);

  if(!players.length) return;
  const peekTargetsMap = buildPeekTargetsMap();

  // â˜… è¿½åŠ ï¼šã‚´ãƒ¼ã‚°ãƒ«æŒã¡ä¸€è¦§
  const fortuneOwners = getFortuneOwners();
  const iAmFortune = fortuneOwners.includes(state.userId);

  const n = players.length;
  const radius = 45;
  const step = (2*Math.PI)/n;
  const anchorAngle = Math.PI/2;
  const meIndex = players.findIndex(p=>p.id===state.userId);

  const myRoleOpened =
    !!(state.roleOpenMap &&
       state.roleOpenMap[state.userId] &&
       state.roleOpenMap[state.userId].opened);

  players.forEach((p,idx)=>{
    const k = (meIndex===-1)?idx: (idx-meIndex+n)%n;
    const angle = anchorAngle + step*k;
    const x = 50 + radius*Math.cos(angle);
    const y = 50 + radius*Math.sin(angle);

const tag = document.createElement('div');

const sideClass = (x < 50) ? 'side-left' : 'side-right';
tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '') + ' ' + sideClass;

// â˜… å…¬é–‹æ¸ˆã¿ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å…¨å“¡ role-opened
if (state.roleOpenMap && state.roleOpenMap[p.id] && state.roleOpenMap[p.id].opened) {
  tag.classList.add('role-opened');
}


    tag.dataset.seatIndex = String(p.seatIndex);
    tag.dataset.playerId = p.id;


    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top  = `${y}%`;

    tag.addEventListener('click', () => {
      onPlayerTagClickForFirstPeek(tag);
    });
    const hasLocalPeek = !!firstPeekTargets[p.id];
    if (hasLocalPeek) {
      const roleInfo = state.roles && state.roles[p.id];
      if (roleInfo && roleInfo.type) {
        const mini = document.createElement('div');
        mini.className = 'player-tag-role-mini peek-view';
        mini.textContent = (roleInfo.type === 'LIGHT') ? 'å…‰' : 'å½±';
        tag.appendChild(mini);
      }
    }
// â˜… èƒ½åŠ›ãƒŸãƒ‹ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼ˆå¸¸ã«å…¬é–‹ï¼‰
const chefIdForPlayer = state.chefRoles && state.chefRoles[p.id];
if (chefIdForPlayer){
  const abilityMini = document.createElement('div');
  abilityMini.className = 'player-tag-ability-mini';

  // ä¸­èº«ã¯ãƒŸãƒ‹èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ã¨åŒã˜ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ãã®ã¾ã¾ä½¿ç”¨
  const innerCard = document.createElement('div');
  innerCard.className = 'ability-mini-card';
// ä¾‹ï¼šCHEF_BUREAUCRAT ã ã‘è¶…ç¸®å°æ–‡å­—ã«ã—ãŸã„å ´åˆ
if (chefIdForPlayer === 'CHEF_BUREAUCRAT') {
  innerCard.classList.add('tiny-text');
}


  innerCard.appendChild(createChefMiniFace(chefIdForPlayer));

  abilityMini.appendChild(innerCard);

  // â˜… è¿½åŠ ï¼šãƒŸãƒ‹ç¸®å°èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã§æ‹¡å¤§
  abilityMini.addEventListener('click', (ev) => {
    ev.stopPropagation();               // ãƒãƒ¼ãƒ ã‚¿ã‚°ã‚¯ãƒªãƒƒã‚¯ï¼ˆå¸­å¥ªã„ï¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠï¼‰ã‚’ç™ºç«ã•ã›ãªã„
    showAbilityOverlay(chefIdForPlayer);
  });

  tag.appendChild(abilityMini);
}



    // â˜… è‡ªåˆ†ã®æ­£ä½“ãŒå…¬é–‹ã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã€èª°ãŒè¦‹ã¦ã„ã¦ã‚‚ ğŸ‘€ ã¯å‡ºã•ãªã„
    let isPeekingMyRole = false;
    if (!myRoleOpened && state.peekRoleView && state.userId){
      for (const [viewerId, info] of Object.entries(state.peekRoleView)){
        if (!info) continue;
        // roleOwnerId === è‡ªåˆ† â†’ ãã® viewerId ã¯ã€Œè‡ªåˆ†ã®æ­£ä½“ã€ã‚’è¦‹ã¦ã„ã‚‹
        if (info.roleOwnerId === state.userId && viewerId === p.id){
          isPeekingMyRole = true;
          break;
        }
      }
    }
    if (isPeekingMyRole){
      const eye = document.createElement('div');
      eye.className = 'peek-eye';
      eye.textContent = 'ğŸ‘€';
      tag.appendChild(eye);
    }

    // â˜… å…¬é–‹çŠ¶æ…‹ã¨ã€Œè‡ªåˆ†ã ã‘è¦‹ãˆã¦ã„ã‚‹ã‹ã€ã‚’åˆ¤å®š
    const isOpened = !!(state.roleOpenMap &&
                        state.roleOpenMap[p.id] &&
                        state.roleOpenMap[p.id].opened);

const myPeekEntry =
  state.peekRoleView &&
  state.peekRoleView[state.userId] || null;

const myPeekRoleOwnerId =
  myPeekEntry && myPeekEntry.roleOwnerId || null;

const isPeekTarget =
  myPeekRoleOwnerId && myPeekRoleOwnerId === p.id;// â˜… æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼ˆé€šå¸¸å…¬é–‹ or å€‹äººçš„å…¬é–‹ï¼‰ãŒãƒãƒ¼ãƒ ã‚¿ã‚°æ¨ªã«ã‚ã‚‹å ´åˆã¯ã€èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ãšã‚‰ã™ã‚¯ãƒ©ã‚¹ã‚’ä»˜ã‘ã‚‹
if (isOpened || isPeekTarget) {
  tag.classList.add('role-with-card');
}
    /* â˜… æ­£ä½“ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯
       1) å…¬é–‹æ¸ˆã¿ â†’ å…¨å“¡ã«é€šå¸¸æ ã§è¦‹ãˆã‚‹
       2) æœªå…¬é–‹ + è‡ªåˆ†ã®ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ã€ã§é¸ã‚“ã ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ â†’ è‡ªåˆ†ã ã‘ç‚¹ç·šæ ã§è¦‹ãˆã‚‹
    */
    if (state.roles && state.roles[p.id] && (isOpened || isPeekTarget)) {
      const r = state.roles[p.id];

      const mini = document.createElement('div');
      mini.className = 'player-tag-role-mini' + (isOpened ? '' : ' peek-view');

      const face  = document.createElement('div');
      face.className = 'card-face';

      const body = document.createElement('div');
      body.className = 'card-text';
      body.textContent = (r.type === 'LIGHT') ? 'å…‰' : 'å½±';

      face.appendChild(body);
      mini.appendChild(face);

      tag.appendChild(mini);
    }




    tag.onclick = () => {

  if(state.shuffle3Global && state.shuffle3Global.active &&
     state.shuffle3Global.ownerId === state.userId){
    // è‡ªåˆ†è‡ªèº«ã‚’å«ã‚ã¦ä»»æ„ã®3äººã§OKãªã‚‰ã€åˆ¶é™ãªã—
    toggleShuffle3Selection(p.id);
    return;
  }

      // â˜… ã¾ãšã€ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ã€ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ä¸­ãªã‚‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠã¨ã—ã¦æ‰±ã†
      if (state.peekRoleGlobal && state.peekRoleGlobal.active &&
          state.peekRoleGlobal.ownerId === state.userId){
        // è‡ªåˆ†è‡ªèº«ã¯é¸ã¹ãªã„
        if (p.id === state.userId) return;
        handlePeekTargetSelect(p.id);
        return;
      }

      // â˜… ã“ã“ã‹ã‚‰å…ˆã¯å¾“æ¥ã©ãŠã‚Šã€Œå¸­ã‚’å¥ªã†ã€å‡¦ç†
      if(p.id===state.userId) return;
      if(!state.roomCode) return;
      if(state.seatedTable!==null) return;
      pendingSeatIndexToSteal = p.seatIndex;
      pendingPlayerNameToSteal = p.name;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `ã€Œ${p.name}ã€ã‚’è¿½ã„å‡ºã—ã¦ã€ã“ã®å¸­ã«ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ`;
      kickDialog.classList.remove('hidden');
    };

    const handData = state.hands[p.id];
    if(p.id!==state.userId && handData && Array.isArray(handData.cards) && handData.cards.length){
      const miniHand = document.createElement('div');
      miniHand.className='mini-hand';
      const count = handData.cards.length;
      const spread = 70;
      const base = (count>1)?(-spread/2):0;
      handData.cards.forEach((v,idx2)=>{
        const card = document.createElement('div');
        card.className='mini-card';
        card.textContent='';
        const angleDeg = (count>1)? base + (spread/(count-1))*idx2 : 0;
        card.style.transform=`translate(-50%,0) rotate(${angleDeg}deg)`;
        card.style.zIndex=String(10+idx2);
        miniHand.appendChild(card);
      });
      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  });

  renderAttachedCubesForAllPlayers();
}

kickDialog.addEventListener('click',(e)=>{
  if(e.target===kickDialog){
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal=null;
    pendingPlayerNameToSteal=null;
    pendingSeatPlayerIdToSteal=null;
  }
});
btnKickNo.addEventListener('click',(e)=>{
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal=null;
  pendingPlayerNameToSteal=null;
  pendingSeatPlayerIdToSteal=null;
});

btnKickYes.addEventListener('click', async () => {
  if (!state.roomCode) return;
  if (pendingSeatIndexToSteal == null) return;
  if (!pendingSeatPlayerIdToSteal) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const snap = await get(roomRef);
  const room = snap.val() || {};

  const oldId = pendingSeatPlayerIdToSteal; // å¥ªã‚ã‚Œã‚‹å´
  const newId = state.userId;               // å¥ªã†å´ï¼ˆè‡ªåˆ†ï¼‰
  const seatIndex = pendingSeatIndexToSteal;

  const updates = {};

  // 1) å¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’æ›¸ãæ›ãˆï¼ˆã“ã“ã¯å…ƒã€…ã‚„ã£ã¦ã„ãŸã¯ãšï¼‰
  updates[`tables/${seatIndex}/playerId`]   = newId;
  updates[`tables/${seatIndex}/playerName`] = state.userName || 'åç„¡ã—';

  // 2) æ‰‹æœ­ã‚’ä¸¸ã”ã¨ç§»ã™ï¼šhands/oldId â†’ hands/newId
  if (room.hands && room.hands[oldId]) {
    updates[`hands/${newId}`] = room.hands[oldId];
    updates[`hands/${oldId}`] = null;
  }

  // 3) æ­£ä½“ã‚«ãƒ¼ãƒ‰ã‚’ç§»ã™ï¼šroles/oldId â†’ roles/newId
  if (room.roles && room.roles[oldId]) {
    updates[`roles/${newId}`] = room.roles[oldId];
    updates[`roles/${oldId}`] = null;
  }

  // 4) æ­£ä½“å…¬é–‹çŠ¶æ…‹ã‚‚ä»˜ã‘æ›¿ãˆï¼šrolesOpen/oldId â†’ rolesOpen/newId
  if (room.rolesOpen && room.rolesOpen[oldId]) {
    updates[`rolesOpen/${newId}`] = room.rolesOpen[oldId];
    updates[`rolesOpen/${oldId}`] = null;
  }

  // 5) èƒ½åŠ›ã‚«ãƒ¼ãƒ‰ï¼ˆã‚·ã‚§ãƒ•èƒ½åŠ›ï¼‰ã‚‚ç§»ã™ï¼šchefRoles/oldId â†’ chefRoles/newId
  if (room.chefRoles && room.chefRoles[oldId]) {
    updates[`chefRoles/${newId}`] = room.chefRoles[oldId];
    updates[`chefRoles/${oldId}`] = null;
  }

  // ã¾ã¨ã‚ã¦DBæ›´æ–°
  await update(roomRef, updates);

  // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚æ›´æ–°
  state.seatedTable = seatIndex;

  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãªã©å¾Œå‡¦ç†
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
  pendingPlayerNameToSteal = null;
  kickDialog.classList.add('hidden');
});


// â˜… ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ã‚¨ãƒ©ãƒ¼ï¼ˆã‚«ãƒ¼ãƒ‰ã®ä¸Šã«å°ã•ãè¡¨ç¤ºï¼‰
function showCardError(message, anchorEl){
  if(!cardErrorBubble){
    alert(message);  // ä¿é™º
    return;
  }
  cardErrorBubble.textContent = message;

  let x = window.innerWidth / 2;
  let y = window.innerHeight / 2;

  if(anchorEl){
    const r = anchorEl.getBoundingClientRect();
    x = r.left + r.width / 2;
    y = r.top;                  // ã‚«ãƒ¼ãƒ‰ã®ä¸Šè¾º
  }

  cardErrorBubble.style.left = `${x}px`;
  cardErrorBubble.style.top  = `${y}px`;

  cardErrorBubble.classList.remove('hidden');
  // å†æç”»ã‚’æŒŸã‚“ã§ã‹ã‚‰ visible ã‚’ä»˜ã‘ã‚‹
  void cardErrorBubble.offsetWidth;
  cardErrorBubble.classList.add('visible');

  // 2ç§’å¾Œã«è‡ªå‹•ã§æ¶ˆãˆã‚‹
  if(cardErrorTimer) clearTimeout(cardErrorTimer);
  cardErrorTimer = setTimeout(()=>{
    cardErrorBubble.classList.remove('visible');
    cardErrorTimer = setTimeout(()=>{
      cardErrorBubble.classList.add('hidden');
      cardErrorTimer = null;
    }, 200);
  }, 2000);
}

/* â˜… ãƒãƒ¼ãƒ ã‚¿ã‚°ã‚¯ãƒªãƒƒã‚¯æ™‚ï¼šåˆå›ã‚¿ãƒ¼ãƒ³ã®ã€Œ1äººã ã‘æ­£ä½“ã‚’è¦‹ã‚‹ã€å‡¦ç† */
// â˜… åˆå›ã‚¹ã‚¿ãƒ¼ãƒˆåŠ¹æœã§ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ã€æ™‚ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
async function onPlayerTagClickForFirstPeek(tag){
  // ã“ã®ãƒ¢ãƒ¼ãƒ‰ã˜ã‚ƒãªã„ã¨ãã¯ä½•ã‚‚ã—ãªã„
  if (!firstTurnPeekStarted) return;
  if (!state.roomCode) return;

  const targetId = tag.dataset.playerId;
  // è‡ªåˆ†è‡ªèº«ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã—ãªã„
  if (!targetId || targetId === state.userId) return;

  // â‘  ãƒ­ãƒ¼ã‚«ãƒ«è¨˜éŒ²ï¼ˆè‡ªåˆ†ã®ç”»é¢ã ã‘ã§è¦‹ãˆã‚‹ã€Œå°ã•ãªæ­£ä½“ã‚«ãƒ¼ãƒ‰ã€ç”¨ï¼‰
  firstPeekTargets[targetId] = true;
  // ä¸€åº¦è¦‹çµ‚ã‚ã£ãŸã®ã§ã€ã“ã®ãƒ¢ãƒ¼ãƒ‰ã¯çµ‚äº†
  firstTurnPeekStarted = false;

  // â‘¡ ğŸ‘€ã‚¢ã‚¤ã‚³ãƒ³ç”¨ã«
  //    ã€ŒviewerIdï¼ˆè‡ªåˆ†ï¼‰ãŒ targetId ã®æ­£ä½“ã‚’è¦‹ãŸã€ã¨ DB ã«ä¿å­˜
  const viewerId = state.userId;
  const viewRef  = ref(db, `rooms/${state.roomCode}/peekRoleView/${viewerId}`);
  await set(viewRef, {
    roleOwnerId: targetId,    // èª°ã®æ­£ä½“ã‚’è¦‹ãŸã‹
    viewerId: viewerId,       // è¦‹ã¦ã„ã‚‹äººã¯è‡ªåˆ†
    createdAt: Date.now(),
    reason: 'FIRST_TURN'      // ã©ã®åŠ¹æœã‹ï¼ˆãŠå¥½ã¿ã§ï¼‰
  });

  // â‘¢ turnState ã® firstPeekDone ã‚’ true ã«ã—ã¦
  //    ã€Œåˆå›ã®æ­£ä½“ç¢ºèªãŒçµ‚ã‚ã£ãŸã€ã“ã¨ã‚’å…±æœ‰
  const tsRef  = ref(db, `rooms/${state.roomCode}/turnState`);
  const tsSnap = await get(tsRef);
  const cur    = tsSnap.val() || {};
  if (cur && cur.isFirstTurn && !cur.firstPeekDone && cur.playerId === viewerId){
    await update(tsRef, { firstPeekDone: true });
  }

  // â‘£ ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ã€ãƒãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
  if (peekRolePop){
    peekRolePop.classList.add('hidden');
  }

  // â‘¤ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å††ã‚’å†æç”»ï¼ˆè‡ªåˆ†ã®ãƒŸãƒ‹æ­£ä½“ã‚«ãƒ¼ãƒ‰åæ˜ ï¼‰
  if (latestPlayers.length){
    renderPlayerCircle(latestPlayers);
  }
}


/* æ‰‹æœ­ä½¿ç”¨ãƒãƒƒãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã«å‡ºã™ï¼ˆã€Œä½¿ã†ã€ã ã‘ï¼‰ */
function onMyCardClick(e){
  // â˜… ã™ã§ã«ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ãŒå ´ã«ã‚ã‚‹å ´åˆã¯ä½¿ãˆãªã„
  if (state.usedCards && state.usedCards.length > 0) {
    return;
  }
  // â˜… 2æšå¼•ã„ã¦1æšæ¸¡ã™ãƒ•ãƒ­ãƒ¼ä¸­ã‚‚ä»–ã®ã‚«ãƒ¼ãƒ‰ã¯ä½¿ãˆãªã„
  if (state.give2Flow && state.give2Flow.active){
    return;
  }
  // â˜… æ­£ä½“ã‚’è¦‹ã‚‹ãƒ•ãƒ­ãƒ¼ä¸­ã‚‚ä»–ã®ã‚«ãƒ¼ãƒ‰ã¯ä½¿ãˆãªã„
  if (state.peekRoleGlobal && state.peekRoleGlobal.active){
    return;
  }
  // â˜… ã™ã§ã«ã€Œä½¿ã†ã€å‡¦ç†ä¸­ãªã‚‰ã€æ–°ã—ã„å…¥åŠ›ã¯ç„¡è¦–
  if (isUseCardProcessing) {
    return;
  }

  const cardEl = e.currentTarget;
  const idx = Number(cardEl.dataset.index || '-1');
  const value = cardEl.dataset.value || '';
  if (idx < 0 || !value) return;

  // â˜… ã©ã®ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ã†ã‹ã‚’æ›´æ–°ï¼ˆãƒãƒƒãƒ—ãŒå‡ºã¦ã„ã¦ã‚‚ä¸Šæ›¸ãã™ã‚‹ï¼‰
  pendingUseCardIndex = idx;
  pendingUseCardValue = value;

  // â˜… ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´æ‰€ã«ãƒãƒƒãƒ—ã‚’å‡ºã™ï¼ˆæ—¢ã«è¡¨ç¤ºä¸­ãªã‚‰ä½ç½®ã ã‘ç§»å‹•ï¼‰
  const clientX = e.clientX;
  const clientY = e.clientY;
  showUseCardDialogAt(clientX, clientY);
}


btnUseCardYes.addEventListener('click', async (e)=>{
  e.stopPropagation();
  await confirmUseCardUse();
});

function closeUseCardDialog(){
  useCardDialog.classList.add('hidden');
  pendingUseCardIndex = null;
  pendingUseCardValue = null;
}

function showUseCardDialogAt(clientX, clientY){
  if (!useCardDialog) return;

  useCardDialog.classList.remove('hidden');
  useCardDialog.style.left = '0px';
  useCardDialog.style.top  = '0px';

  const rect = useCardDialog.getBoundingClientRect();
  const margin = 8;

  let x = clientX - rect.width / 2;
  let y = clientY - rect.height - margin;

  if (x < margin) x = margin;
  if (x + rect.width > window.innerWidth - margin) {
    x = window.innerWidth - rect.width - margin;
  }

  if (y < margin) {
    y = clientY + margin;
    if (y + rect.height > window.innerHeight - margin) {
      y = window.innerHeight - rect.height - margin;
    }
  }

  useCardDialog.style.left = x + 'px';
  useCardDialog.style.top  = y + 'px';
}

// â˜… ã‚«ãƒ¼ãƒ‰åŠ¹æœé©ç”¨ï¼ˆusedMeta ã‚‚æ¸¡ã™ï¼‰
async function applyCardEffect(cardId, ownerId, usedMeta){
  if (!state.roomCode) return;
  switch(cardId){
    case 'TURN_DRAW2':
      await effectTurnDraw2(ownerId, usedMeta);
      break;
    case 'TURN_DRAW2_KEEP_GIVE1':
      await effectTurnDraw2KeepGive1(ownerId, usedMeta);
      break;
    case 'TURN_SHOW_ROLE_HEAL1_EXILE':              // â˜… è¿½åŠ 
      await effectTurnShowRoleHeal1Exile(ownerId, usedMeta);
      break;
    case 'TURN_SELF_HEAL1_ALL_DRAW1':
      await effectTurnSelfHeal1AllDraw1(ownerId, usedMeta);
      break;
    /* â˜… è¿½åŠ ï¼šä»»æ„ã®1äººã‚’é¸ã³ã€æ­£ä½“ã‚’è¦‹ã‚‹ */
    case 'TURN_PEEK_ROLE':
      await effectTurnPeekRole(ownerId, usedMeta);
      break;
    case 'TURN_SHOW_ROLES_MUTUAL_EXILE':
      await effectTurnShowRolesMutualExile(ownerId, usedMeta);
      break;
    case 'TURN_SHUFFLE3_ROLES_EXILE':
      await effectTurnShuffle3RolesExile(ownerId, usedMeta);
      break;

    default:
      break;


  }
}

/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚«ãƒ¼ãƒ‰
   ä»»æ„ã®3äººã‚’é¸ã³ã€æ­£ä½“ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ« â†’ å†é…å¸ƒã€‚
   å€‹äººçš„å…¬é–‹ï¼ˆç‚¹ç·šæ ï¼‰ã¯ã€ã“ã®3äººã«é–¢ã™ã‚‹ã‚‚ã®ã‚’å…¨ã¦æ¶ˆã™ã€‚ */
async function effectTurnShuffle3RolesExile(ownerId, usedMeta){
  if(!state.roomCode) return;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  await update(roomRef, {
    shuffle3Global: {
      active: true,
      ownerId,
      usedMeta: usedMeta || null,
      createdAt: Date.now()
    }
  });
}


// â˜… TURN_PEEK_ROLE : ä»»æ„ã®1äººã‚’é¸ã³ã€æ­£ä½“ã‚’è¦‹ã‚‹
//   - å…¨å“¡ã®æ“ä½œã‚’ä¸€æ™‚åœæ­¢ï¼ˆdiceLocked = true ãªã©ï¼‰
//   - ä½¿ç”¨è€…ã®ç”»é¢ã«ã ã‘ã€Œæ­£ä½“ã‚’è¦‹ãŸã„äººã‚’é¸ã¶ã€ãƒãƒƒãƒ—è¡¨ç¤º
//   - ãƒãƒ¼ãƒ ã‚¿ã‚°ã‚¯ãƒªãƒƒã‚¯ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ±ºå®š â†’ å€‹äººçš„å…¬é–‹ â†’ 1ç§’å¾Œã«æ¨ã¦æœ­ã¸
async function effectTurnPeekRole(ownerId, usedMeta){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);

  await update(roomRef, {
    peekRoleGlobal: {
      active: true,
      ownerId,
 mode: 'PEEK', 
      usedMeta: usedMeta || null,
      createdAt: Date.now()
    }
  });
}

// â˜… æ–°ã‚«ãƒ¼ãƒ‰ï¼šä»»æ„ã®1äººã«æ­£ä½“ã‚’è¦‹ã›ã¦1å›å¾©ï¼ˆé™¤å¤–æœ­é€ã‚Šï¼‰
async function effectTurnShowRoleHeal1Exile(ownerId, usedMeta){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);

  await update(roomRef, {
    peekRoleGlobal: {
      active: true,
      ownerId,
      mode: 'SHOW_HEAL_EXILE',       // â˜… ãƒ¢ãƒ¼ãƒ‰ã§åŒºåˆ¥
      usedMeta: usedMeta || null,
      createdAt: Date.now()
    }
  });
}

async function effectTurnShowRolesMutualExile(ownerId, usedMeta){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);

  await update(roomRef, {
    peekRoleGlobal: {
      active: true,
      ownerId,
      mode: 'MUTUAL_EXILE',   // â˜… ãƒ¢ãƒ¼ãƒ‰ã§åŒºåˆ¥
      usedMeta: usedMeta || null,
      createdAt: Date.now()
    }
  });
}

async function handlePeekTargetSelect(targetPlayerId){
  if (!state.roomCode) return;
  if (!state.peekRoleGlobal || !state.peekRoleGlobal.active) return;

  const flow    = state.peekRoleGlobal;
  const ownerId = flow.ownerId;
  if (ownerId !== state.userId) return;  // è‡ªåˆ†ãŒä½¿ç”¨è€…ã®æ™‚ã ã‘
  if (targetPlayerId === ownerId) return; // è‡ªåˆ†ã¯é¸ã¹ãªã„

  const mode     = flow.mode || 'PEEK';
  const usedMeta = flow.usedMeta || null;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const updates = {};

  // å…±é€šï¼šã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ•ãƒ­ãƒ¼ã‚’çµ‚äº†ï¼ˆãƒ­ãƒƒã‚¯è§£é™¤ã¯è³¼èª­å´ã§å®Ÿè¡Œï¼‰
  updates[`peekRoleGlobal`] = null;

  if (mode === 'PEEK'){
    // â˜… æ—§ä»•æ§˜ï¼šè‡ªåˆ†ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ­£ä½“ã‚’è¦‹ã‚‹
    updates[`peekRoleView/${state.userId}`] = {
      mode: 'PEEK',
      roleOwnerId: targetPlayerId,
      usedMeta: usedMeta,
      viewerId: state.userId,
      createdAt: Date.now()
    };

  } else if (mode === 'SHOW_HEAL_EXILE'){
    // â˜… æ–°ä»•æ§˜ï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã€Œè‡ªåˆ†ï¼ˆä½¿ç”¨è€…ï¼‰ã®æ­£ä½“ã€ã‚’è¦‹ã‚‹
    updates[`peekRoleView/${targetPlayerId}`] = {
      mode: 'SHOW_HEAL_EXILE',
      roleOwnerId: ownerId,
      usedMeta: usedMeta,
      viewerId: targetPlayerId,
      createdAt: Date.now()
    };

  } else if (mode === 'MUTUAL_EXILE'){
    // â˜… æ­£ä½“ã‚’è¦‹ã›ã‚ã†ï¼šäº’ã„ã«ç›¸æ‰‹ã®æ­£ä½“ã‚’ã€Œå€‹äººçš„å…¬é–‹ã€
    updates[`peekRoleView/${ownerId}`] = {
      mode: 'MUTUAL_EXILE',
      roleOwnerId: targetPlayerId,  // è‡ªåˆ†ãŒè¦‹ã‚‹ã®ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ­£ä½“
      usedMeta: usedMeta,
      viewerId: ownerId,
      createdAt: Date.now()
    };
    updates[`peekRoleView/${targetPlayerId}`] = {
      mode: 'MUTUAL_EXILE',
      roleOwnerId: ownerId,        // ç›¸æ‰‹ãŒè¦‹ã‚‹ã®ã¯è‡ªåˆ†ã®æ­£ä½“
      usedMeta: usedMeta,
      viewerId: targetPlayerId,
      createdAt: Date.now()
    };
  }

  await update(roomRef, updates);

  // ãƒ­ãƒ¼ã‚«ãƒ« UI ã®ç‰‡ä»˜ã‘
  hidePeekRolePop();

  // â˜… åŠ¹æœã”ã¨ã«ã€Œä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã€ã®è¡Œãå…ˆã‚’å¤‰ãˆã‚‹
  if (mode === 'SHOW_HEAL_EXILE'){
    // â‘  æ­£ä½“ã‚’è¦‹ã›çµ‚ã‚ã£ãŸã‚ã¨ã€è‡ªåˆ†ãŒ1å›å¾©
    await healOneCubeOfOwner(ownerId);
    // â‘¡ 1ç§’å¾Œã€ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã‚’é™¤å¤–æœ­ã¸
    if (usedMeta){
      setTimeout(() => {
        autoMoveUsedCardToExile(usedMeta);
      }, 1000);
    }

  } else if (mode === 'MUTUAL_EXILE'){
    // â˜… æ­£ä½“ã‚’è¦‹ã›ã‚ã†ï¼š1ç§’å¾Œã€ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã‚’é™¤å¤–æœ­ã¸
    if (usedMeta){
      setTimeout(() => {
        autoMoveUsedCardToExile(usedMeta);
      }, 1000);
    }

  } else {
    // â˜… é€šå¸¸ã®ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ã€ã‚«ãƒ¼ãƒ‰ï¼š1ç§’å¾Œã«æ¨ã¦æœ­ã¸
    if (usedMeta){
      setTimeout(() => {
        autoMoveUsedCardToDiscard(usedMeta);
      }, 1000);
    }
  }
}



/* â˜… æ­£ä½“ã‚’è¦‹ã‚‹ï¼šå…¨ä½“ãƒ•ãƒ­ãƒ¼è³¼èª­ */
function subscribePeekRoleGlobal(){
  if(!state.roomCode) return;
  const pRef = ref(db, `rooms/${state.roomCode}/peekRoleGlobal`);
  onValue(pRef, snap => {
    const v = snap.val() || null;
    state.peekRoleGlobal = v;

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ãƒ€ã‚¤ã‚¹ã‚’ãƒ­ãƒƒã‚¯
    if (v && v.active){
      setDiceLocked(true);
      // ä½¿ç”¨è€…ã ã‘ãƒãƒƒãƒ—ã‚’è¡¨ç¤º
      if (v.ownerId === state.userId){
        showPeekRolePop();
      } else {
        hidePeekRolePop();
      }
    }else{
      // çµ‚äº† â†’ ãƒ­ãƒƒã‚¯è§£é™¤ï¼†ãƒãƒƒãƒ—æ¶ˆã—
      setDiceLocked(false);
      hidePeekRolePop();
    }
  });
}

/* â˜… æ­£ä½“ã‚’è¦‹ã‚‹ï¼šå€‹äººãƒ“ãƒ¥ãƒ¼ï¼ˆèª°ãŒèª°ã‚’å€‹äººçš„å…¬é–‹ã—ãŸã‹ï¼‰ã‚’è³¼èª­ */
function subscribePeekRoleView(){
  if(!state.roomCode) return;
  const vRef = ref(db, `rooms/${state.roomCode}/peekRoleView`);
  onValue(vRef, snap => {
    const data = snap.val() || {};
    state.peekRoleView = data;
    if(latestPlayers.length){
      renderPlayerCircle(latestPlayers);
    }
  });
}
// â˜… è¿½åŠ ï¼šèª°ãŒèª°ã«è¦—ã‹ã‚Œã¦ã„ã‚‹ã‹ã‚’ã€ŒtargetId â†’ [viewerId,...]ã€ã«ã¾ã¨ã‚ã‚‹
function buildPeekTargetsMap(){
  const map = {}; // { targetId: [viewerId1, viewerId2, ...] }

  const views = state.peekRoleView || {};
  Object.values(views).forEach(v => {
    if(!v || !v.targetId || !v.viewerId) return;
    if(!map[v.targetId]) map[v.targetId] = [];
    if(!map[v.targetId].includes(v.viewerId)){
      map[v.targetId].push(v.viewerId);
    }
  });
  return map;
}

/* â˜… ãƒãƒƒãƒ—è¡¨ç¤ºãƒ»éè¡¨ç¤º */
function showPeekRolePop(){
  if(!peekRolePop) return;

  const headerEl = peekRolePop.querySelector('.turn-select-header');
  if (headerEl){
    const mode = state.peekRoleGlobal && state.peekRoleGlobal.mode;
    if (mode === 'SHOW_HEAL_EXILE'){
      headerEl.textContent = 'æ­£ä½“ã‚’è¦‹ã›ãŸã„äººã‚’é¸ã¶';
    } else if (mode === 'MUTUAL_EXILE'){
      headerEl.textContent = 'æ­£ä½“ã‚’è¦‹ã›ã‚ã†äººã‚’é¸ã¶';
    } else {
      headerEl.textContent = 'æ­£ä½“ã‚’è¦‹ãŸã„äººã‚’é¸ã¶';
    }
  }

  peekRolePop.classList.remove('hidden');
}

/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼šé¸æŠçŠ¶æ…‹ã‚¯ãƒªã‚¢ */
function clearShuffle3Selection(){
  shuffle3SelectedIds = [];
  if(playerCircle){
    playerCircle
      .querySelectorAll('.player-tag.shuffle3-selected')
      .forEach(el => el.classList.remove('shuffle3-selected'));
  }
  if(shuffle3ConfirmPop){
    shuffle3ConfirmPop.classList.add('hidden');
  }
}

/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒˆã‚°ãƒ«é¸æŠ */
function toggleShuffle3Selection(playerId){
  if(!playerCircle) return;

  const idx = shuffle3SelectedIds.indexOf(playerId);
  const tagEls = playerCircle.querySelectorAll(
    `.player-tag[data-player-id="${playerId}"]`
  );

  if(idx >= 0){
    // é¸æŠè§£é™¤
    shuffle3SelectedIds.splice(idx, 1);
    tagEls.forEach(el => el.classList.remove('shuffle3-selected'));
  }else{
    // 3äººã¾ã§
    if(shuffle3SelectedIds.length >= 3) return;
    shuffle3SelectedIds.push(playerId);
    tagEls.forEach(el => el.classList.add('shuffle3-selected'));
  }

  if(shuffle3ConfirmPop){
    if(shuffle3SelectedIds.length === 3){
      shuffle3ConfirmPop.classList.remove('hidden');
    }else{
      shuffle3ConfirmPop.classList.add('hidden');
    }
  }
}

/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼šFirebaseè³¼èª­ */
function subscribeShuffle3Global(){
  if(!state.roomCode) return;
  const sRef = ref(db, `rooms/${state.roomCode}/shuffle3Global`);
  onValue(sRef, snap => {
    const v = snap.val() || null;
    state.shuffle3Global = v;

    if(v && v.active){
      // å…¨å“¡ã®ãƒ€ã‚¤ã‚¹ã‚’ãƒ­ãƒƒã‚¯
      setDiceLocked(true);

      // ä½¿ç”¨è€…ã ã‘ã«ã€Œ3äººé¸ã¹ã€ãƒãƒƒãƒ—ã‚’å‡ºã™ï¼ˆpeekRolePopã‚’æµç”¨ï¼‰
      if(v.ownerId === state.userId){
        if(peekRolePop){
          const headerEl = peekRolePop.querySelector('.turn-select-header');
          if(headerEl){
            headerEl.textContent = 'æ­£ä½“ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹3äººã‚’é¸ã¶';
          }
          peekRolePop.classList.remove('hidden');
        }
      }else{
        // ä»–ã®äººã¯èª¬æ˜ãƒãƒƒãƒ—éè¡¨ç¤ºï¼ˆãƒ­ãƒƒã‚¯ã ã‘ï¼‰
        hidePeekRolePop();
      }
    }else{
      // ãƒ•ãƒ­ãƒ¼çµ‚äº†
      setDiceLocked(false);
      clearShuffle3Selection();
      hidePeekRolePop();
    }
  });
}

/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼šç¢ºå®šå‡¦ç†ï¼ˆå®Ÿéš›ã«å½¹è·ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ï¼‰ */
async function confirmShuffle3Roles(){
  if(!state.roomCode) return;
  if(!state.shuffle3Global || !state.shuffle3Global.active) return;
  if(state.shuffle3Global.ownerId !== state.userId) return;
  if(shuffle3SelectedIds.length !== 3) return;

  const roomRef  = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const roles       = roomData.roles       || {};
  const tables      = roomData.tables      || {};
  const peekRoleView= roomData.peekRoleView|| {};

  const selectedIds = [...shuffle3SelectedIds];

  // playerId â†’ seatIndex
  const playerSeatMap = {};
  Object.entries(tables).forEach(([seatIndex, t])=>{
    if(t && t.playerId){
      playerSeatMap[t.playerId] = Number(seatIndex);
    }
  });

  // é¸ã°ã‚ŒãŸ3äººã®å…ƒã®å½¹è·
  const baseRoles = selectedIds.map(pid => roles[pid] || null);

  // 0,1,2 ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«
  const idxs = [0,1,2];
  for(let i = idxs.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
  }

  const newRoles = { ...roles };
  for(let i = 0; i < selectedIds.length; i++){
    const pid = selectedIds[i];
    const srcRole = baseRoles[idxs[i]];
    if(!srcRole) continue;

    const seatIndex =
      playerSeatMap[pid] ??
      srcRole.seatIndex ??
      null;

    newRoles[pid] = {
      ...srcRole,
      seatIndex
    };
  }

  // â˜… å€‹äººçš„å…¬é–‹ï¼ˆpeekRoleViewï¼‰ã®ã†ã¡ã€
  //    ã“ã®3äººã®æ­£ä½“ã‚’è¦‹ã›ã¦ã„ã‚‹ã‚‚ã®ã¯å…¨ã¦æ¶ˆã™
  const selectedSet = new Set(selectedIds);
  const newPeek = {};
  for(const [viewerId, info] of Object.entries(peekRoleView)){
    if(!info) continue;
    if(selectedSet.has(info.roleOwnerId)) continue; // 3äººã«é–¢ã™ã‚‹å€‹äººçš„å…¬é–‹ã¯ãƒªã‚»ãƒƒãƒˆ
    newPeek[viewerId] = info;
  }

  const usedMeta = state.shuffle3Global.usedMeta || null;

  await update(roomRef, {
    roles: newRoles,
    peekRoleView: newPeek,
    shuffle3Global: null
  });

  clearShuffle3Selection();
  if(shuffle3ConfirmPop){
    shuffle3ConfirmPop.classList.add('hidden');
  }
  hidePeekRolePop();

  // â˜… 1ç§’å¾Œã€ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’æ¨ã¦æœ­ã¸
  if(usedMeta){
    setTimeout(()=>{
autoMoveUsedCardToExile(usedMeta);
    }, 1000);
  }
}

/* â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼šç¢ºèªãƒãƒƒãƒ—ã®ãƒœã‚¿ãƒ³ */
if(btnShuffle3Reset){
  btnShuffle3Reset.onclick = () => {
    clearShuffle3Selection();
  };
}
if(btnShuffle3Confirm){
  btnShuffle3Confirm.onclick = async () => {
    await confirmShuffle3Roles();
  };
}


function hidePeekRolePop(){
  if(!peekRolePop) return;
  peekRolePop.classList.add('hidden');
}

// â˜… TURN_DRAW2_KEEP_GIVE1 : ã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãã€ã†ã¡1æšã¯èª°ã‹ã«æ¸¡ã™
async function effectTurnDraw2KeepGive1(ownerId, usedMeta){
  if (!state.roomCode) return;

  const roomRef  = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};
  const hands       = roomData.hands       || {};
  const usedCards   = roomData.usedCards   || [];
  const discardPile = roomData.discardPile || [];
  const exilePile   = roomData.exilePile   || [];  // â† è¿½åŠ 

  const handData = hands[ownerId] || { cards: [] };
  const currentCards = Array.isArray(handData.cards) ? [...handData.cards] : [];

  const MAX_HAND = 5;
  // ã“ã®ã‚«ãƒ¼ãƒ‰ã§æœ€çµ‚çš„ã« +1æšã«ãªã‚‹ã®ã§ã€ç¾åœ¨4æšã¾ã§ã¯OK
  if (currentCards.length >= MAX_HAND){
    // ã“ã‚Œä»¥ä¸Šã¯å¢—ã‚„ã›ãªã„ã®ã§ä½•ã‚‚ã—ãªã„ï¼ˆã‚«ãƒ¼ãƒ‰ã ã‘ç„¡é§„æ’ƒã¡ã«ãªã‚‹ä»•æ§˜ï¼‰
    return;
  }

  // ç¾åœ¨ã®å±±æœ­ã‚’è¨ˆç®—
  let deckRemain = [...CARD_POOL];
  const removeOne = (cid)=>{
    const idx = deckRemain.indexOf(cid);
    if(idx >= 0) deckRemain.splice(idx,1);
  };

  // å…¨å“¡ã®æ‰‹æœ­
  Object.values(hands).forEach(h=>{
    if(h && Array.isArray(h.cards)){
      h.cards.forEach(removeOne);
    }
  });

  // ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ï¼ˆè‡ªåˆ†ãŒä»Šä½¿ã£ãŸã‚«ãƒ¼ãƒ‰ã‚‚å«ã‚€ï¼‰
  if(Array.isArray(usedCards)){
    usedCards.forEach(u=>{
      if(u && u.value) removeOne(u.value);
    });
  }

  // æ¨ã¦æœ­ã‚‚ã¾ã å±±æœ­ã«ã¯æˆ»ã£ã¦ã„ãªã„æ‰±ã„
  if(Array.isArray(discardPile)){
    discardPile.forEach(d=>{
      if(d && d.value) removeOne(d.value);
    });
  }

// â˜… è¿½åŠ ï¼šé™¤å¤–æœ­ã¯äºŒåº¦ã¨å±±æœ­ã«æˆ»ã‚‰ãªã„æ‰±ã„
if(Array.isArray(exilePile)){
  exilePile.forEach(d=>{
    if(d && d.value) removeOne(d.value);
  });
}

  if(deckRemain.length < 1) return;

  // 2æšã²ããŸã„ãŒã€å±±æœ­ãŒ1æšã—ã‹ãªã„å ´åˆã¯1æšã ã‘ï¼ˆãã®å ´åˆã¯ 1æšæ‰‹æœ­ï¼‹1æšæ¸¡ã—â€¦ã¯æˆç«‹ã—ãªã„ã®ã§ã€ä»Šå›ã®å®Ÿè£…ã§ã¯ 2æšãã‚ã‚ãªã„æ™‚ã¯ä¸­æ­¢ï¼‰
  if(deckRemain.length < 2){
    return;
  }

  // ãƒ©ãƒ³ãƒ€ãƒ ã«2æšæŠœã
  const picked = [];
  for(let i=0;i<2;i++){
    if(!deckRemain.length) break;
    const idx = Math.floor(Math.random()*deckRemain.length);
    const [cid] = deckRemain.splice(idx,1);
    picked.push(cid);
  }
  if(picked.length < 2) return;

  const deckCountNow   = deckRemain.length + picked.length; // å¼•ãå‰ã®æšæ•°
  const deckCountAfter = deckRemain.length;                 // å¼•ã„ãŸå¾Œã®æšæ•°

  const newHand = currentCards.concat(picked);

  const updates = {};
  updates[`hands/${ownerId}/cards`] = newHand;
  updates[`give2Flow`] = {
    active: true,
    ownerId,
    cardIds: picked,
    usedMeta: usedMeta || null,
    createdAt: Date.now()
  };

  // å±±æœ­ãŒã—ãã„å€¤ä»¥ä¸‹ â†’ æ¨ã¦æœ­ã‚’å±±æœ­å´ã«æˆ»ã—ãŸæ‰±ã„ï¼†ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡
  if (deckCountAfter <= SHUFFLE_THRESHOLD &&
      Array.isArray(discardPile) && discardPile.length > 0){
    updates[`discardPile`] = [];
    updates[`shuffleInfo/lastShuffleAt`] = Date.now();
  }

  await update(roomRef, updates);
}


// â˜… ã€Œè‡ªåˆ†ãŒ1å›å¾©ã™ã‚‹ã€‚ãã®å¾Œã€å…¨å“¡ãŒã‚«ãƒ¼ãƒ‰ã‚’1æšã²ãã€
//   TURN_SELF_HEAL1_ALL_DRAW1 ç”¨ã®åŠ¹æœ
async function effectTurnSelfHeal1AllDraw1(ownerId, usedMeta){
  if (!state.roomCode) return;

  // 1ç§’å¾…ã£ã¦ã‹ã‚‰ã€Œè‡ªåˆ†ãŒ1å›å¾©ã€ï¼ˆï¼è‡ªåˆ†ã®å¸­ã®èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’1ã¤ã ã‘ãƒªã‚¶ãƒ¼ãƒ–ã¸ï¼‰
  await new Promise(resolve => setTimeout(resolve, 1000));

  const roomRef  = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tables      = roomData.tables      || {};
  const hands       = roomData.hands       || {};
  const usedCards   = roomData.usedCards   || [];
  const discardPile = roomData.discardPile || [];
  const cubes       = roomData.cubes       || {};
const exilePile   = roomData.exilePile   || [];  // â˜… è¿½åŠ 

  // â–¼ è‡ªåˆ†ã®å¸­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
  let mySeatIndex = null;
  for (const [seatIndex, t] of Object.entries(tables)) {
    if (t && t.playerId === ownerId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }

  // â–¼ å¸­ã”ã¨ã®èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–æ•°ï¼‹ã€Œå›å¾©ã§æˆ»ã™ã‚­ãƒ¥ãƒ¼ãƒ–ã€1å€‹ã‚’æ¢ã™
  const cubeCountBySeat = {};
  let healCubeId = null;

  for (const [cubeId, c] of Object.entries(cubes)) {
    if (!c || c.attachedSeat == null) continue;
    const s = Number(c.attachedSeat);
    if (!Number.isFinite(s)) continue;

    cubeCountBySeat[s] = (cubeCountBySeat[s] || 0) + 1;

    // è‡ªåˆ†ã®å¸­ã«ã¤ã„ã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’1å€‹ã ã‘å›å¾©å¯¾è±¡ã«ã™ã‚‹
    if (mySeatIndex != null && s === mySeatIndex && !healCubeId) {
      healCubeId = cubeId;
    }
  }

  // â–¼ ã€Œå›å¾©å¾Œã€ã®ã‚­ãƒ¥ãƒ¼ãƒ–æ•°ã«åæ˜ ï¼ˆè‡ªåˆ†ã®å¸­ã ã‘1å€‹æ¸›ã‚‰ã™ï¼‰
  if (healCubeId && mySeatIndex != null) {
    cubeCountBySeat[mySeatIndex] = Math.max(
      0,
      (cubeCountBySeat[mySeatIndex] || 1) - 1
    );
  }

  // â–¼ å¸­é †ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆä½œæˆ
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (
      t && t.playerId ? {
        seatIndex: Number(seatIndex),
        id: t.playerId,
        name: t.playerName || 'åç„¡ã—'
      } : null
    ))
    .filter(Boolean)
    .sort((a, b) => a.seatIndex - b.seatIndex);

  // â–¼ ã€Œå›å¾©å¾Œã€ã®çŠ¶æ…‹ã§ã€æ‰‹æœ­4æšä»¥ä¸‹ï¼†èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–2å€‹ä»¥ä¸‹ã®å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¯¾è±¡ã«ã™ã‚‹
  const targets = players.filter(p => {
    const handData = hands[p.id];
    const current  = (handData && Array.isArray(handData.cards)) ? handData.cards : [];
    if (current.length > 4) return false;   // æ‰€æŒã‚«ãƒ¼ãƒ‰ãŒ4æšä»¥ä¸‹
    const cnt = cubeCountBySeat[p.seatIndex] || 0;
    return cnt <= 2;                         // èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ãŒ2ã¤ä»¥ä¸‹
  });

  // â–¼ ç¾åœ¨ã®å±±æœ­æ®‹é‡ã‚’è¨ˆç®—ï¼ˆCARD_POOL ã‹ã‚‰æ‰‹æœ­ï¼‹ä½¿ç”¨ä¸­ï¼‹æ¨ã¦æœ­ã‚’å¼•ã„ãŸæ®‹ã‚Šï¼‰
  let deckRemain = [...CARD_POOL];
  const removeOne = (cid) => {
    const idx = deckRemain.indexOf(cid);
    if (idx >= 0) deckRemain.splice(idx, 1);
  };

  // å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­
  Object.values(hands).forEach(h => {
    if (h && Array.isArray(h.cards)) {
      h.cards.forEach(removeOne);
    }
  });

  // ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰
  if (Array.isArray(usedCards)) {
    usedCards.forEach(u => {
      if (u && u.value) removeOne(u.value);
    });
  }

  // æ¨ã¦æœ­ï¼ˆã¾ã å±±æœ­ã«æˆ»ã—ã¦ã„ãªã„åˆ†ï¼‰
  if (Array.isArray(discardPile)) {
    discardPile.forEach(d => {
      if (d && d.value) removeOne(d.value);
    });
  }



// â˜… è¿½åŠ ï¼šé™¤å¤–æœ­ã¯äºŒåº¦ã¨å±±æœ­ã«æˆ»ã‚‰ãªã„æ‰±ã„
if(Array.isArray(exilePile)){
  exilePile.forEach(d=>{
    if(d && d.value) removeOne(d.value);
  });
}
  const updates = {};
  const now = Date.now();

  // â–¼ å›å¾©ã§ãƒªã‚¶ãƒ¼ãƒ–ã«æˆ»ã™ã‚­ãƒ¥ãƒ¼ãƒ–ï¼ˆè¦‹ãŸç›®ã¨ã—ã¦å³ä¸Šã‚µãƒ¼ã‚¯ãƒ«ä¸­å¤®ã«æˆ»ã—ã¦ãŠãï¼‰
  if (healCubeId) {
    updates[`cubes/${healCubeId}/attachedSeat`] = null;
    updates[`cubes/${healCubeId}/updatedBy`]   = ownerId;
    updates[`cubes/${healCubeId}/updatedAt`]   = now;
    // å¿…è¦ã«å¿œã˜ã¦ä½ç½®ã‚‚ãƒªã‚»ãƒƒãƒˆï¼ˆ0,0 ã¯ã‚µãƒ¼ã‚¯ãƒ«ä¸­å¿ƒæ‰±ã„ï¼‰
    updates[`cubes/${healCubeId}/tx`] = 0;
    updates[`cubes/${healCubeId}/ty`] = 0;
  }

  // â–¼ å±±æœ­ or å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã‘ã‚Œã°ã€Œå›å¾©ã ã‘ã€ã§çµ‚äº†
  if (!deckRemain.length || !targets.length) {
    if (Object.keys(updates).length) {
      await update(roomRef, updates);
    }
    // ã€Œã“ã®å‡¦ç†ãŒçµ‚ã‚ã£ã¦ã€ä¸€ç§’å¾Œã€ã«ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã‚’æ¨ã¦æœ­ã¸
    setTimeout(() => {
      autoMoveUsedCardToDiscard(usedMeta);
    }, 1000);
    return;
  }

  // â–¼ å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«1æšãšã¤é…å¸ƒï¼ˆå¸­ç•ªå·ã®å°ã•ã„é †ï¼‰
  const updatedHands = {};
  for (const p of targets) {
    if (!deckRemain.length) break;

    const handData = hands[p.id];
    const current  = (handData && Array.isArray(handData.cards)) ? [...handData.cards] : [];
    if (current.length > 4) continue;  // å¿µã®ãŸã‚å†ãƒã‚§ãƒƒã‚¯

    const idx = Math.floor(Math.random() * deckRemain.length);
    const [cid] = deckRemain.splice(idx, 1);
    current.push(cid);
    updatedHands[p.id] = current;
  }

  const deckCountAfter = deckRemain.length;

  // â–¼ æ‰‹æœ­ã‚’æ›¸ãè¾¼ã¿
  for (const [pid, cards] of Object.entries(updatedHands)) {
    updates[`hands/${pid}/cards`] = cards;
  }

  // â–¼ å±±æœ­ãŒã—ãã„å€¤ä»¥ä¸‹ã«ãªã£ãŸã‚‰ã€æ¨ã¦æœ­ã‚’å±±æœ­å´ã«æˆ»ã—ãŸæ‰±ã„ï¼‹ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡
  if (deckCountAfter <= SHUFFLE_THRESHOLD &&
      Array.isArray(discardPile) && discardPile.length > 0) {
    updates[`discardPile`] = [];
    updates[`shuffleInfo/lastShuffleAt`] = now;
  }

  if (Object.keys(updates).length) {
    await update(roomRef, updates);
  }

  // â–¼ å…¨å“¡ã¸ã®é…å¸ƒå‡¦ç†ãŒçµ‚ã‚ã£ã¦ã‹ã‚‰ã€ã•ã‚‰ã«1ç§’å¾Œã«ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã‚’æ¨ã¦æœ­ã¸
  setTimeout(() => {
    autoMoveUsedCardToDiscard(usedMeta);
  }, 1000);
}





// â˜… å…±é€šï¼šæŒ‡å®šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¸­ã‹ã‚‰èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’1ã¤ãƒªã‚¶ãƒ¼ãƒ–ã«æˆ»ã™
async function healOneCubeOfOwner(ownerId){
  if (!state.roomCode) return;

  const roomRef  = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tables = roomData.tables || {};
  const cubes  = roomData.cubes  || {};

  // ãã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¸­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¢ã™
  let seatIndex = null;
  for (const [s, t] of Object.entries(tables)){
    if (t && t.playerId === ownerId){
      seatIndex = Number(s);
      break;
    }
  }
  if (seatIndex == null) return;

  // ãã®å¸­ã«ã¤ã„ã¦ã„ã‚‹èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’1ã¤ã ã‘æ¢ã™
  let healCubeId = null;
  for (const [cubeId, c] of Object.entries(cubes)){
    if (!c) continue;
    if (c.attachedSeat === seatIndex){
      healCubeId = cubeId;
      break;
    }
  }
  if (!healCubeId) return;

  const now = Date.now();
  await update(roomRef, {
    [`cubes/${healCubeId}/attachedSeat`]: null, // å¸­ã‹ã‚‰å¤–ã™ï¼ˆå³ä¸Šã‚µãƒ¼ã‚¯ãƒ«å´ã«æˆ»ã™ï¼‰
    [`cubes/${healCubeId}/tx`]: 0,
    [`cubes/${healCubeId}/ty`]: 0,
    [`cubes/${healCubeId}/updatedBy`]: ownerId,
    [`cubes/${healCubeId}/updatedAt`]: now
  });
}


// â˜… TURN_DRAW2: ã‚«ãƒ¼ãƒ‰ã‚’2æšã²ãï¼ˆãŸã ã—æœ€å¤§5æšï¼‰ï¼‹
//    å±±æœ­ãŒ42æšä»¥ä¸‹ã«ãªã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§æ¨ã¦æœ­ã‚’å±±æœ­ã«æˆ»ã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«
async function effectTurnDraw2(ownerId, usedMeta){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};
  const hands = roomData.hands || {};
  const usedCards = roomData.usedCards || [];
  const discardPile = roomData.discardPile || [];
  const exilePile   = roomData.exilePile   || [];  // â† è¿½åŠ 

  // è‡ªåˆ†ã®æ‰‹æœ­
  const handData = hands[ownerId] || { cards: [] };
  const currentCards = Array.isArray(handData.cards) ? [...handData.cards] : [];

  const MAX_HAND = 5;
  const canAdd = Math.min(2, Math.max(0, MAX_HAND - currentCards.length));
  if (canAdd <= 0) {
    // ã™ã§ã«5æš â†’ å¼•ã‹ãªã„
    return;
  }

  // â‘  ç¾åœ¨ã®å±±æœ­ï¼ˆã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã‹ã‚‰ã€Œå…¨å“¡ã®æ‰‹æœ­ï¼‹ä½¿ç”¨ä¸­ï¼‹æ¨ã¦æœ­ã€ã‚’å¼•ã„ãŸæ®‹ã‚Šï¼‰
  let deckRemain = [...CARD_POOL];
  const removeOne = (cid) => {
    const idx = deckRemain.indexOf(cid);
    if (idx >= 0) deckRemain.splice(idx, 1);
  };

  // å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­
  Object.values(hands).forEach(h => {
    if (h && Array.isArray(h.cards)) {
      h.cards.forEach(removeOne);
    }
  });

  // ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰
  if (Array.isArray(usedCards)) {
    usedCards.forEach(u => {
      if (u && u.value) removeOne(u.value);
    });
  }

  // æ¨ã¦æœ­ã‚‚ã€ã¾ã å±±æœ­ã«æˆ»ã—ã¦ã„ãªã„çŠ¶æ…‹ã§ã¯ã€Œå¼•ã‘ãªã„ã€ã®ã§é™¤å¤–
  if (Array.isArray(discardPile)) {
    discardPile.forEach(d => {
      if (d && d.value) removeOne(d.value);
    });
  }
// â˜… è¿½åŠ ï¼šé™¤å¤–æœ­ã¯äºŒåº¦ã¨å±±æœ­ã«æˆ»ã‚‰ãªã„æ‰±ã„
if(Array.isArray(exilePile)){
  exilePile.forEach(d=>{
    if(d && d.value) removeOne(d.value);
  });
}
  const deckCountNow = deckRemain.length;
  if (deckCountNow <= 0) {
    // ã„ã¡ãŠã†å®‰å…¨ç­–ï¼šå±±æœ­ãŒã‚¼ãƒ­ãªã‚‰å¼•ã‘ãªã„
    return;
  }

  // å®Ÿéš›ã«å¼•ãæšæ•°ï¼ˆå±±æœ­ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã¯ã‚ã‚‹ã ã‘ï¼‰
  const drawCount = Math.min(canAdd, deckCountNow);

  // â‘¡ å±±æœ­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã« drawCount æšã²ã
  const newCards = [];
  for (let i = 0; i < drawCount; i++) {
    if (!deckRemain.length) break;
    const idx = Math.floor(Math.random() * deckRemain.length);
    const [cid] = deckRemain.splice(idx, 1);
    newCards.push(cid);
  }

  if (!newCards.length) return;

  const updatedHand = currentCards.concat(newCards);
  const deckCountAfter = deckCountNow - newCards.length;

  // â‘¢ æ›´æ–°å†…å®¹ã‚’ã¾ã¨ã‚ã¦æ›¸ãè¾¼ã‚€
  const updates = {};
  updates[`hands/${ownerId}/cards`] = updatedHand;

  // â˜… å±±æœ­ãŒ42æšä»¥ä¸‹ã«ãªã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã€
  //    æ¨ã¦æœ­ã‚’å±±æœ­å´ã«æˆ»ã—ãŸæ‰±ã„ã«ã—ã¦ã€ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡ç”¨ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ç«‹ã¦ã‚‹
  if (deckCountAfter <= SHUFFLE_THRESHOLD && Array.isArray(discardPile) && discardPile.length > 0) {
    // DBä¸Šã§ã¯ã€Œæ¨ã¦æœ­ã‚’ç©ºã«ã™ã‚‹ã€ã ã‘ã§OK
    updates[`discardPile`] = [];
    updates[`shuffleInfo/lastShuffleAt`] = Date.now();
  }

  await update(roomRef, updates);
}

// â˜… èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ãŒ2å€‹ä»¥ä¸‹ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¨å“¡ã«1æšãšã¤é…ã‚‹
async function dealOneCardToLowCubePlayers(){
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const roomRef  = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tables      = roomData.tables      || {};
  const hands       = roomData.hands       || {};
  const usedCards   = roomData.usedCards   || [];
  const discardPile = roomData.discardPile || [];
  const cubes       = roomData.cubes       || {};
  const exilePile   = roomData.exilePile   || [];  // â† è¿½åŠ 

  // å¸­é †ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€è¦§
  const players = Object.entries(tables)
    .map(([seatIndex, t]) =>
      t && t.playerId ? {
        seatIndex: Number(seatIndex),
        id: t.playerId,
        name: t.playerName || 'åç„¡ã—'
      } : null
    )
    .filter(Boolean)
    .sort((a, b) => a.seatIndex - b.seatIndex);

  if (!players.length) return;

  // å„å¸­ã®ã€Œã‚¢ã‚¿ãƒƒãƒã•ã‚Œã¦ã„ã‚‹èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–æ•°ã€ã‚’æ•°ãˆã‚‹
  const cubeCountBySeat = {};
  Object.values(cubes).forEach(c => {
    if (!c || c.attachedSeat == null) return;
    const s = Number(c.attachedSeat);
    if (!Number.isFinite(s)) return;
    cubeCountBySeat[s] = (cubeCountBySeat[s] || 0) + 1;
  });

  // å¯¾è±¡ï¼šèµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ãŒ2å€‹ä»¥ä¸‹ã€ã‹ã¤æ‰‹æœ­ãŒ5æšæœªæº€
  const targets = players.filter(p => {
    const cnt = cubeCountBySeat[p.seatIndex] || 0;
    const handData = hands[p.id];
    const current = (handData && Array.isArray(handData.cards)) ? handData.cards : [];
    if (current.length >= 5) return false;
    return cnt <= 2;
  });

  if (!targets.length) return;

  // ç¾åœ¨ã®å±±æœ­ï¼ˆCARD_POOL ã‹ã‚‰æ‰‹æœ­ï¼‹ä½¿ç”¨ä¸­ï¼‹æ¨ã¦æœ­ã‚’å¼•ã„ãŸæ®‹ã‚Šï¼‰
  let deckRemain = [...CARD_POOL];
  const removeOne = (cid) => {
    const idx = deckRemain.indexOf(cid);
    if (idx >= 0) deckRemain.splice(idx, 1);
  };

  // å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­
  Object.values(hands).forEach(h => {
    if (h && Array.isArray(h.cards)){
      h.cards.forEach(removeOne);
    }
  });

  // ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰
  if (Array.isArray(usedCards)){
    usedCards.forEach(u => {
      if (u && u.value) removeOne(u.value);
    });
  }

  // æ¨ã¦æœ­ï¼ˆã¾ã å±±æœ­ã«æˆ»ã—ã¦ã„ãªã„åˆ†ï¼‰ã¯é™¤å¤–
  if (Array.isArray(discardPile)){
    discardPile.forEach(d => {
      if (d && d.value) removeOne(d.value);
    });
  }
// â˜… è¿½åŠ ï¼šé™¤å¤–æœ­ã¯äºŒåº¦ã¨å±±æœ­ã«æˆ»ã‚‰ãªã„æ‰±ã„
if(Array.isArray(exilePile)){
  exilePile.forEach(d=>{
    if(d && d.value) removeOne(d.value);
  });
}

  if (!deckRemain.length) return;

  // å®Ÿéš›ã«é…ã‚‹ï¼ˆå¸­ç•ªå·ã®å°ã•ã„é †ï¼‰
  const updatedHands = {};
  for (const p of targets){
    let handData = hands[p.id];
    let current  = (handData && Array.isArray(handData.cards)) ? [...handData.cards] : [];
    if (current.length >= 5) continue;
    if (!deckRemain.length) break;

    const idx = Math.floor(Math.random() * deckRemain.length);
    const [cid] = deckRemain.splice(idx, 1);
    current.push(cid);
    updatedHands[p.id] = current;
  }

  if (!Object.keys(updatedHands).length) return;

  const updates = {};
  for (const [pid, cards] of Object.entries(updatedHands)){
    updates[`hands/${pid}/cards`] = cards;
  }

  // å±±æœ­ãŒã—ãã„å€¤ä»¥ä¸‹ã«ãªã£ãŸã‚‰æ¨ã¦æœ­ã‚’å±±æœ­ã«æˆ»ã™æ‰±ã„ï¼†ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¢ãƒ‹ãƒ¡
  const deckCountAfter = deckRemain.length;
  if (deckCountAfter <= SHUFFLE_THRESHOLD && Array.isArray(discardPile) && discardPile.length > 0){
    updates[`discardPile`] = [];
    updates[`shuffleInfo/lastShuffleAt`] = Date.now();
  }

  await update(roomRef, updates);
}



// â˜… TURN_DRAW2 ç”¨ï¼šä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã‚’ 1 ç§’å¾Œã«è‡ªå‹•ã§æ¨ã¦æœ­ã¸é€ã‚‹
async function autoMoveUsedCardToDiscard(meta){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const usedRef = ref(db, `rooms/${state.roomCode}/usedCards`);
  const discRef = ref(db, `rooms/${state.roomCode}/discardPile`);

  try{
    // ç¾åœ¨ã® usedCards / discardPile ã‚’å–å¾—
    const [usedSnap, discSnap] = await Promise.all([
      get(usedRef),
      get(discRef)
    ]);

    let usedArr = usedSnap.val() || [];
    if (!Array.isArray(usedArr) || usedArr.length === 0) return;

    const last = usedArr[usedArr.length - 1];

    // â˜… ã€Œè‡ªåˆ†ãŒã•ã£ãä½¿ã£ãŸ TURN_DRAW2 ã‹ã©ã†ã‹ã€ãƒã‚§ãƒƒã‚¯
    if (!last ||
        last.value  !== meta.value  ||
        last.ownerId !== meta.ownerId ||
        last.usedAt !== meta.usedAt){
      // é€”ä¸­ã§åˆ¥ã®ã‚«ãƒ¼ãƒ‰ãŒä½¿ã‚ã‚Œã¦ã„ãŸã‚‰ä½•ã‚‚ã—ãªã„
      return;
    }

    let discArr = discSnap.val() || [];
    if (!Array.isArray(discArr)) discArr = [];

    // æ¨ã¦æœ­ã®ä¸€ç•ªä¸Šã«ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’ç©ã‚€
    discArr.push(last);

    // usedCards ã‚’ç©ºã«ã—ã¦ã€æ¨ã¦æœ­ã«åæ˜ 
    await update(roomRef, {
      discardPile: discArr,
      usedCards: []
    });
  }catch(err){
    console.error('autoMoveUsedCardToDiscard error', err);
  }
}

// â˜… ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ã‚’é™¤å¤–æœ­ã«é€ã‚‹ï¼ˆusedMeta ã§ä¸€è‡´ã™ã‚‹ã‚‚ã®ã‚’ç§»å‹•ï¼‰
async function autoMoveUsedCardToExile(usedMeta){
  if (!state.roomCode || !usedMeta) return;
  if (isMovingUsedCardToExile) return;     // äºŒé‡å®Ÿè¡Œé˜²æ­¢
  isMovingUsedCardToExile = true;

  try{
    const roomRef  = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};

    const usedCards = Array.isArray(roomData.usedCards) ? [...roomData.usedCards] : [];
    const exilePile = Array.isArray(roomData.exilePile) ? [...roomData.exilePile] : [];

    // ä»Šå›ã®ä½¿ç”¨ã‚«ãƒ¼ãƒ‰ã‚’ usedCards ã‹ã‚‰æ¢ã™
    const idx = usedCards.findIndex(c =>
      c &&
      c.value   === usedMeta.value &&
      c.ownerId === usedMeta.ownerId &&
      c.usedAt  === usedMeta.usedAt
    );
    if (idx === -1) return;

    const [card] = usedCards.splice(idx, 1);
    exilePile.push(card);   // é™¤å¤–æœ­ã®ä¸€ç•ªä¸Šã«ä¹—ã›ã‚‹

    await update(roomRef, {
      usedCards,
      exilePile
    });
  } finally{
    isMovingUsedCardToExile = false;
  }
}


// â˜… ã€Œä½¿ã†ã€ç¢ºå®šå‡¦ç†
async function confirmUseCardUse(){
  if(pendingUseCardIndex == null || pendingUseCardValue == null || !state.roomCode){
    closeUseCardDialog();
    return;
  }
  if(isUseCardProcessing) return;
  isUseCardProcessing = true;

  const myId   = state.userId;
  const cardId = pendingUseCardValue;

  // â˜… 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«å°‚ç”¨ã®äº‹å‰ãƒã‚§ãƒƒã‚¯
  if(cardId === 'TURN_SHUFFLE3_ROLES_EXILE'){
    // æ­£ä½“ã‚’å…¬é–‹ã—ã¦ã„ãªã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’æ•°ãˆã‚‹
    const unrevealedCount = latestPlayers.filter(p => {
      const openInfo = state.roleOpenMap && state.roleOpenMap[p.id];
      return !(openInfo && openInfo.opened); // opened ãŒ true ã§ãªã‘ã‚Œã°ã€Œæœªå…¬é–‹ã€
    }).length;

    if(unrevealedCount < 3){
      // æ‰‹æœ­ã®è©²å½“ã‚«ãƒ¼ãƒ‰DOMã‚’æ¢ã™ï¼ˆã‚¯ãƒ©ã‚¹åã‚„dataå±æ€§ã¯å®Ÿè£…ã«åˆã‚ã›ã¦èª¿æ•´ï¼‰
      const anchor = document.querySelector(`.hand-card[data-index="${pendingUseCardIndex}"]`) || null;

      showCardError(
        'æ­£ä½“ã‚’å…¬é–‹ã—ã¦ã„ãªã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ3äººä»¥ä¸Šã„ãªã„ãŸã‚ã€ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ä½¿ãˆã¾ã›ã‚“ã€‚',
        anchor
      );

      isUseCardProcessing = false;
      closeUseCardDialog();
      return;
    }
  }


  try{
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap    = await get(roomRef);
    const data    = snap.val() || {};
    const hands   = data.hands || {};

    const myHandData = hands[myId] || { cards: [] };
    const cards      = Array.isArray(myHandData.cards) ? [...myHandData.cards] : [];

    let idx = pendingUseCardIndex;
    if(idx < 0 || idx >= cards.length || cards[idx] !== cardId){
      // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãšã‚Œä¿é™ºï¼šåŒã˜IDã‚’æ¤œç´¢
      idx = cards.indexOf(cardId);
      if(idx === -1){
        isUseCardProcessing = false;
        closeUseCardDialog();
        return;
      }
    }

    const removed = cards.splice(idx, 1)[0];

    const usedArr = Array.isArray(data.usedCards) ? [...data.usedCards] : [];
    const usedMeta = {
      value:  removed,
      ownerId: myId,
      usedAt: Date.now()
    };
    usedArr.push(usedMeta);

    await update(roomRef, {
      [`hands/${myId}/cards`]: cards,
      usedCards: usedArr
    });

    closeUseCardDialog();
    isUseCardProcessing = false;

    // â˜… åŠ¹æœç™ºå‹•
    await applyCardEffect(removed, myId, usedMeta);

  }catch(err){
    console.error(err);
    isUseCardProcessing = false;
    closeUseCardDialog();
  }
}



async function onUsedCardDblClick(){
  if (!state.roomCode) return;
  if (!state.usedCards || !state.usedCards.length) return;

  if (isMovingUsedCardToDiscard) return;
  isMovingUsedCardToDiscard = true;

  const last = state.usedCards[state.usedCards.length - 1];

  state.usedCards = [];
  renderUsedCards();

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const discRef = ref(db, `rooms/${state.roomCode}/discardPile`);

  try{
    const discSnap = await get(discRef);
    let discArr = discSnap.val() || [];
    if (!Array.isArray(discArr)) discArr = [];
    discArr.push(last);

    await update(roomRef, {
      discardPile: discArr,
      usedCards: []
    });

  }catch(err){
    console.error('move to discardPile error', err);
    state.usedCards = [last];
    renderUsedCards();
  }finally{
    isMovingUsedCardToDiscard = false;
  }
}

function clampToInner(x,y){
  const dist = Math.hypot(x,y);
  if(dist > INNER_RADIUS){
    const k = INNER_RADIUS / dist;
    x *= k;
    y *= k;
  }
  return {x,y};
}
function isInsideOuterByPos(x,y){
  return Math.hypot(x,y) <= OUTER_RADIUS;
}
function isDieActive(die){
  const tx = parseFloat(die.dataset.tx || '0');
  const ty = parseFloat(die.dataset.ty || '0');
  return isInsideOuterByPos(tx,ty);
}
function setDiePosition(die,x,y){
  die.dataset.tx = String(x);
  die.dataset.ty = String(y);
  die.style.setProperty('--tx', x+'px');
  die.style.setProperty('--ty', y+'px');
}

function getMiniCardObstacles(){
  const obstacles = [];
  if (!diceArea) return obstacles;

  const diceRect = diceArea.getBoundingClientRect();
  const cx = diceRect.left + diceRect.width / 2;
  const cy = diceRect.top  + diceRect.height / 2;

  const miniHands = document.querySelectorAll('.player-tag .mini-hand');
  miniHands.forEach(hand => {
    const r = hand.getBoundingClientRect();
    const centerX = r.left + r.width  / 2;
    const centerY = r.top + r.height / 2;

    const x = centerX - cx;
    const y = centerY - cy;

    const radius = Math.hypot(r.width, r.height) / 2 + 10;
    obstacles.push({ x, y, radius });
  });

  return obstacles;
}

function updateDieFace(die, val){
  const patterns = {
    1:[3],
    2:[0,6],
    3:[0,3,6],
    4:[0,1,5,6],
    5:[0,1,3,5,6],
    6:[0,1,2,4,5,6]
  };

  const active = patterns[val] || [];
  const pips = die._pips || [];

  for (let i = 0; i < pips.length; i++) {
    const pip = pips[i];
    const on = active.includes(i);

    pip.style.opacity = on ? 1 : 0;
    pip.classList.remove('red');

    if (val === 1 && i === 3 && on) {
      pip.classList.add('red');
    }
  }
}

function syncDiceStatesToDB(){
  if(!state.roomCode || !diceArea) return;
  const diceEls = diceArea.querySelectorAll('.dice');
  if(!diceEls.length) return;

  const updates = {};
  const now = Date.now();
  diceEls.forEach(die => {
    const id = die.dataset.id;
    if(!id) return;
    const tx = parseFloat(die.dataset.tx || '0');
    const ty = parseFloat(die.dataset.ty || '0');
    const rot = parseFloat(die.dataset.rot || '0');
    const val = parseInt(die.dataset.value || '1',10) || 1;
    updates[id] = {
      tx, ty, rot, value: val,
      updatedBy: state.userId,
      updatedAt: now
    };
  });
  const diceRef = ref(db, `rooms/${state.roomCode}/dice`);
  update(diceRef, updates);
}

function resolveCollisions(anchorDie = null){
  if(!diceArea) return;

  const allDice = Array.from(diceArea.querySelectorAll('.dice'));
  const diceEls = allDice.filter(d => isDieActive(d));
  const n = diceEls.length;
  if(n<=1) return;

  const xs = new Array(n);
  const ys = new Array(n);
  let anchorIndex = -1;

  for(let i=0;i<n;i++){
    xs[i] = parseFloat(diceEls[i].dataset.tx || '0');
    ys[i] = parseFloat(diceEls[i].dataset.ty || '0');
    if(anchorDie && diceEls[i] === anchorDie){
      anchorIndex = i;
    }
  }

  const obstacles = getMiniCardObstacles();

  for(let iter=0; iter<8; iter++){
    let moved = false;

    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        let dx = xs[j]-xs[i];
        let dy = ys[j]-ys[i];
        let dist = Math.hypot(dx,dy);
        if(dist === 0){
          dx = (Math.random()-0.5)||0.01;
          dy = (Math.random()-0.5)||0.01;
          dist = Math.hypot(dx,dy);
        }
        if(dist < DICE_COLLIDE_DIST){
          const overlap = (DICE_COLLIDE_DIST - dist)/2;
          const nx = dx/dist;
          const ny = dy/dist;

          if(anchorIndex !== -1){
            if(i === anchorIndex){
              xs[j] += nx*overlap*2;
              ys[j] += ny*overlap*2;
              ({x:xs[j],y:ys[j]} = clampToInner(xs[j],ys[j]));
            }else if(j === anchorIndex){
              xs[i] -= nx*overlap*2;
              ys[i] -= ny*overlap*2;
              ({x:xs[i],y:ys[i]} = clampToInner(xs[i],ys[i]));
            }else{
              xs[i] -= nx*overlap;
              ys[i] -= ny*overlap;
              xs[j] += nx*overlap;
              ys[j] += ny*overlap;
              ({x:xs[i],y:ys[i]} = clampToInner(xs[i],ys[i]));
              ({x:xs[j],y:ys[j]} = clampToInner(xs[j],ys[j]));
            }
          }else{
            xs[i] -= nx*overlap;
            ys[i] -= ny*overlap;
            xs[j] += nx*overlap;
            ys[j] += ny*overlap;
            ({x:xs[i],y:ys[i]} = clampToInner(xs[i],ys[i]));
            ({x:xs[j],y:ys[j]} = clampToInner(xs[j],ys[j]));
          }
          moved = true;
        }
      }
    }

    for(let i=0;i<n;i++){
      let x = xs[i];
      let y = ys[i];

      obstacles.forEach(ob => {
        let dx = x - ob.x;
        let dy = y - ob.y;
        let dist = Math.hypot(dx,dy);
        if(dist === 0){
          dx = 1;
          dy = 0;
          dist = 1;
        }

        const minDist = ob.radius + DICE_COLLIDE_DIST / 2;
        if(dist < minDist){
          const overlap = (minDist - dist);
          const nx = dx / dist;
          const ny = dy / dist;
          x += nx * overlap;
          y += ny * overlap;
          ({x,y} = clampToInner(x,y));
          moved = true;
        }
      });

      xs[i] = x;
      ys[i] = y;
    }

    if(!moved) break;
  }

  for(let i=0;i<n;i++){
    if(anchorIndex !== -1 && i === anchorIndex) continue;
    setDiePosition(diceEls[i], xs[i], ys[i]);
  }
}

function rollDie(die){
  if(!die) return;
  if(die.classList.contains('rolling')) return;
  die.classList.add('rolling');

  const baseRot = parseFloat(die.dataset.rot || '0');
  const extraRot = 360*2 + Math.floor(Math.random()*360);
  const targetRot = baseRot + extraRot;
  die.dataset.rot = String(targetRot);
  die.style.setProperty('--rot', targetRot + 'deg');

  setTimeout(()=>{
    const val = Math.floor(Math.random()*6)+1;
    die.dataset.value = String(val);
    updateDieFace(die,val);
    die.classList.remove('rolling');

    if (isDieActive(die)) {
      resolveCollisions();
    }
    syncDiceStatesToDB();
  },500);
}

function showDiceAdjustPopup(die){
  if(!diceAdjustPop || !die) return;
  diceAdjustPop.dataset.targetDieId = die.dataset.id || '';

  const rect = die.getBoundingClientRect();
  const popWidth = 160;
  const popHeight = 44;

  let left = rect.left + rect.width / 2 - popWidth / 2;
  let top  = rect.top  - popHeight - 8;

  diceAdjustPop.style.left = left + 'px';
  diceAdjustPop.style.top  = top  + 'px';
  diceAdjustPop.classList.remove('hidden');
}

function hideDiceAdjustPopup(){
  if(!diceAdjustPop) return;
  diceAdjustPop.classList.add('hidden');
  diceAdjustPop.dataset.targetDieId = '';
}

if(diceAdjustPop){
  diceAdjustPop.addEventListener('click', (e) => {
    const btn = e.target.closest('button');
    if(!btn) return;

    const setVal = parseInt(btn.dataset.value || '1', 10);
    if(!Number.isFinite(setVal) || setVal < 1 || setVal > 6) return;

    const dieId = diceAdjustPop.dataset.targetDieId;
    if(!dieId || !diceArea) return;

    const die = diceArea.querySelector(`.dice[data-id="${dieId}"]`);
    if(!die) return;

    die.dataset.value = String(setVal);
    updateDieFace(die, setVal);
    syncDiceStatesToDB();

    hideDiceAdjustPopup();
  });

  document.addEventListener('click', (e) => {
    if(diceAdjustPop.classList.contains('hidden')) return;
    if(e.target.closest('#diceAdjustPop')) return;
    if(e.target.closest('.dice')) return;
    hideDiceAdjustPopup();
  });
}

function onDicePointerDown(e){
   maybeSetFirstTurnByDice();

 const die = e.currentTarget;
  if(diceLocked) return;
  if(die.classList.contains('rolling')) return;

  draggingDie = die;
  dragPointerId = e.pointerId;

  startTx = parseFloat(die.dataset.tx || '0');
  startTy = parseFloat(die.dataset.ty || '0');
  dragStartX = e.clientX;
  dragStartY = e.clientY;

  triggeredDiceThisDrag = new Set();
  allDiceRolledThisDrag = false;

  longPressTriggered = false;
  clearLongPressTimer();
  longPressTimer = setTimeout(() => {
    if(!draggingDie || draggingDie !== die) return;
    longPressTriggered = true;
    die.classList.remove('dragging');
    showDiceAdjustPopup(die);
  }, LONG_PRESS_MS);

  die.classList.add('dragging');
  die.setPointerCapture(dragPointerId);
}

function onDicePointerMove(e){
  if(!draggingDie || e.pointerId !== dragPointerId) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;

  if(!longPressTriggered && longPressTimer){
    if(Math.abs(dx) > LONG_PRESS_MOVE_TOL || Math.abs(dy) > LONG_PRESS_MOVE_TOL){
      clearLongPressTimer();
    }
  }

  if(longPressTriggered){
    return;
  }

  let x = startTx + dx;
  let y = startTy + dy;

  const insideOuter = isInsideOuterByPos(x,y);
  if (insideOuter) {
    ({x,y} = clampToInner(x,y));
  }
  setDiePosition(draggingDie,x,y);

  if (insideOuter) {
    resolveCollisions(draggingDie);
  }

  if (diceArea && triggeredDiceThisDrag && insideOuter && canTriggerContactRoll()) {
    const diceEls = diceArea.querySelectorAll('.dice');
    const myTx = x;
    const myTy = y;

    diceEls.forEach(other => {
      if (other === draggingDie) return;
      if (!isDieActive(other)) return;
      const id = other.dataset.id;
      if (!id || triggeredDiceThisDrag.has(id)) return;

      const ox = parseFloat(other.dataset.tx || '0');
      const oy = parseFloat(other.dataset.ty || '0');
      const dist = Math.hypot(ox - myTx, oy - myTy);

      if (dist < DICE_CONTACT_DIST) {
        triggeredDiceThisDrag.add(id);
        rollDie(other);
      }
    });

    if (!allDiceRolledThisDrag && triggeredDiceThisDrag.size >= 1) {
      allDiceRolledThisDrag = true;
      const diceEls2 = diceArea.querySelectorAll('.dice');
      diceEls2.forEach(d => {
        if (isDieActive(d)) {
          rollDie(d);
        }
      });
    }
  }

  syncDiceStatesToDB();
}

function onDicePointerUp(e){
  if(!draggingDie || e.pointerId !== dragPointerId) return;
  const die = draggingDie;

  clearLongPressTimer();
  const wasLong = longPressTriggered;
  longPressTriggered = false;

  die.classList.remove('dragging');
  try{ die.releasePointerCapture(dragPointerId); }catch{}

  draggingDie = null;
  dragPointerId = null;

  triggeredDiceThisDrag = null;
  allDiceRolledThisDrag = false;

  if(wasLong){
    syncDiceStatesToDB();
    return;
  }

  syncDiceStatesToDB();

  const tx = parseFloat(die.dataset.tx || '0');
  const ty = parseFloat(die.dataset.ty || '0');

  // å¤§ãã„å††ã®ä¸­ï¼ˆOUTER_RADIUS å†…å´ï¼‰ã«ã„ã‚‹ãƒ€ã‚¤ã‚¹ã ã‘ãƒ­ãƒ¼ãƒ«
  if (isInsideOuterByPos(tx, ty)) {
    rollDie(die);
  }
}

window.addEventListener('pointermove', onDicePointerMove);
window.addEventListener('pointerup', onDicePointerUp);
window.addEventListener('pointercancel', onDicePointerUp);

function ensureDiceArea(){
  if(diceArea) return;
  if(!playerCircle) return;

  diceArea = document.createElement('div');
  diceArea.id = 'diceArea';
  diceArea.className = 'dice-area';
  playerCircle.appendChild(diceArea);
}
/* â˜… æ­£ä½“æƒ…å ±ã®è³¼èª­ */
function subscribeRoles(){
  if(!state.roomCode) return;

  const rolesRef  = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderMyRoleCard();
    if(latestPlayers.length){
      renderPlayerCircle(latestPlayers);
    }
  });

  const centerRef = ref(db, `rooms/${state.roomCode}/centerRole`);
  onValue(centerRef, snap => {
    state.centerRole = snap.val() || null;
    renderCenterRoleCard();
  });
}

function subscribeRoleOpen(){
  if(!state.roomCode) return;

  const openRef = ref(db, `rooms/${state.roomCode}/rolesOpen`);
  onValue(openRef, snap => {
    const map = snap.val() || {};   // { playerId: { opened, openedAt } }
    state.roleOpenMap = map;

    const anyOpened = Object.values(map).some(v => v && v.opened);
    document.body.classList.toggle('roles-open', anyOpened);

    if(latestPlayers.length){
      renderPlayerCircle(latestPlayers);
    }
    renderCenterRoleCard();
  });
}

function subscribeDice(){
  if(!state.roomCode) return;
  const diceRef = ref(db, `rooms/${state.roomCode}/dice`);
  onValue(diceRef, snap => {
    const data = snap.val();
    if(!data) return;
    ensureDiceArea();
    renderDiceFromState(data);
  });
}

function renderDiceFromState(diceData){
  if(!diceArea) return;

  const existing = new Map();
  diceArea.querySelectorAll('.dice').forEach(die=>{
    existing.set(die.dataset.id, die);
  });

  Object.entries(diceData).forEach(([id,info])=>{
    if(!info) return;
    let die = existing.get(id);
    if(!die){
      die = document.createElement('div');
      die.className='dice';
      die.dataset.id = id;
      die.dataset.tx='0';
      die.dataset.ty='0';
      die.dataset.rot='0';

      const face = document.createElement('div');
      face.className='dice-face';
      const pips=[];
      for(let k=0;k<7;k++){
        const pip = document.createElement('div');
        pip.className='pip pos'+k;
        face.appendChild(pip);
        pips.push(pip);
      }
      die._pips = pips;
      die.appendChild(face);

      die.addEventListener('pointerdown', onDicePointerDown);
      if(diceLocked) die.classList.add('dice-locked');
      diceArea.appendChild(die);
    }
    existing.delete(id);

    const isDraggingMine = die.classList.contains('dragging') && info.updatedBy === state.userId;
    if(isDraggingMine) return;

    let tx = Number(info.tx)||0;
    let ty = Number(info.ty)||0;
    const rot = Number(info.rot)||0;
    const val = Number(info.value)||1;

    die.dataset.tx = String(tx);
    die.dataset.ty = String(ty);
    die.dataset.rot = String(rot);
    die.dataset.value = String(val);
    die.style.setProperty('--rot', rot+'deg');

    if (isInsideOuterByPos(tx,ty)) {
      ({x:tx,y:ty} = clampToInner(tx,ty));
      die.dataset.tx = String(tx);
      die.dataset.ty = String(ty);
    }

    setDiePosition(die, tx, ty);
    updateDieFace(die, val);
  });

  for(const die of existing.values()){
    die.remove();
  }
}

async function initDiceState(){
  if(!state.roomCode) return;
  const diceObj = {};
  for(let i=0;i<8;i++){
    const r = INNER_RADIUS * Math.sqrt(Math.random());
    const angle = Math.random()*2*Math.PI;
    const x = r*Math.cos(angle);
    const y = r*Math.sin(angle);
    const val = Math.floor(Math.random()*6)+1;
    diceObj[i] = {
      tx:x,
      ty:y,
      rot:0,
      value:val,
      updatedBy:state.userId,
      updatedAt:Date.now()
    };
  }
  await set(ref(db, `rooms/${state.roomCode}/dice`), diceObj);
}

function playTurnBanner(playerName){
  if(!turnBanner) return;
  if(!playerName) return;
  if(turnBannerRunning) return;
  turnBannerRunning = true;

  setDiceLocked(true);

  turnBanner.textContent = `ã€Œ${playerName}ã€ã®ã‚¿ãƒ¼ãƒ³`;
  turnBanner.classList.remove('hidden','turn-banner-center','turn-banner-right');

  void turnBanner.offsetWidth;
  const slideMs = 600;
  const holdMs  = 2000;
  const extraLockMs = 1000;

  /* â˜… ãƒãƒƒãƒ—é–‹å§‹æ™‚ç‚¹ã‹ã‚‰ã€æ¶ˆæ»…å¾Œ1ç§’ã¾ã§ãƒ­ãƒƒã‚¯ã™ã‚‹ */
  const totalLock = slideMs + holdMs + slideMs + extraLockMs;
  turnClickLockedUntil = Date.now() + totalLock;

  turnBanner.classList.add('turn-banner-center');

  setTimeout(() => {
    setTimeout(() => {
      turnBanner.classList.add('turn-banner-right');
      setTimeout(() => {
        turnBanner.classList.add('hidden');
        turnBanner.classList.remove('turn-banner-center','turn-banner-right');
        setDiceLocked(false);
        turnBannerRunning = false;
      }, slideMs);
    }, holdMs);
  }, slideMs);
}


function renderTurnSelectPop(){
  if(!turnSelectList) return;
  turnSelectList.innerHTML = '';
  if(!latestPlayers.length) return;

  latestPlayers.forEach(p=>{
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = `å¸­${p.seatIndex}: ${p.name}`;
    btn.onclick = async () => {
      if(!state.roomCode || !state.isHost) return;
      const tRef = ref(db, `rooms/${state.roomCode}/turnState`);
      await set(tRef, {
        seatIndex: p.seatIndex,
        playerId: p.id,
        playerName: p.name,
        startedAt: Date.now()
      });
      hideTurnSelectPop();
    };
    turnSelectList.appendChild(btn);
  });
}
function showTurnSelectPop(){
  if(!turnSelectPop) return;
  if(!state.isHost) return;
  if(!latestPlayers.length) return;
  renderTurnSelectPop();
  turnSelectPop.classList.remove('hidden');
}
function hideTurnSelectPop(){
  if(!turnSelectPop) return;
  turnSelectPop.classList.add('hidden');
}

document.addEventListener('click', (e)=>{
  if(!turnSelectPop || turnSelectPop.classList.contains('hidden')) return;
  if(e.target.closest('#turnSelectPop')) return;
  if(e.target === turnNextBtn || e.target.closest('#turnNextBtn')) return;
  hideTurnSelectPop();
});

hostSettingsBtn.addEventListener('click',()=>{
  if(!state.isHost) return;
  const isHidden = startPop.classList.contains('hidden');
  if(isHidden) startPop.classList.remove('hidden');
  else startPop.classList.add('hidden');
});
btnStartPopClose.addEventListener('click',()=> startPop.classList.add('hidden'));

// â˜… è¿½åŠ ï¼šã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹å…±é€šå‡¦ç†
async function resetGameAndStart(){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);

  // 1) å ´ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  //   - hands        : å…¨å“¡ã®æ‰‹æœ­ã‚¯ãƒªã‚¢
  //   - usedCards    : ä½¿ç”¨ä¸­ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªã‚¢
  //   - discardPile  : æ¨ã¦æœ­ã‚¯ãƒªã‚¢
  //   - shuffleInfo  : å±±æœ­ã‚·ãƒ£ãƒƒãƒ•ãƒ«æƒ…å ±ãƒªã‚»ãƒƒãƒˆ
  //   - roles / centerRole / rolesOpen : æ­£ä½“ã¨å…¬é–‹çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  //   - turnState    : ã‚¿ãƒ¼ãƒ³æƒ…å ±ãƒªã‚»ãƒƒãƒˆ
  //   - dice / cubes : ã‚µã‚¤ã‚³ãƒ­ã¨èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ä¸€æ—¦ã‚¯ãƒªã‚¢ï¼ˆå¾Œã§å†åˆæœŸåŒ–ï¼‰
  await update(roomRef, {
    hands: {},
    usedCards: [],
    discardPile: [],
  exilePile: [],   
chefRoles: null,
    shuffleInfo: { lastShuffleAt: 0 },
    roles: null,
    centerRole: null,
    rolesOpen: null,
    turnState: null,
    dice: null,
    cubes: null,

  });

  // 2) æ­£ä½“ã‚«ãƒ¼ãƒ‰ã‚’ä½œã‚Šç›´ã—ã¦é…ã‚‹ï¼ˆã‚·ãƒ£ãƒƒãƒ•ãƒ«å«ã‚€ï¼‰
  await initRoles();

  // 3) æ‰‹æœ­ã‚’é…ã‚Šç›´ã™ï¼ˆå±±æœ­ã‚‚å®Ÿè³ªãƒªã‚»ãƒƒãƒˆçŠ¶æ…‹ã‹ã‚‰å†é…å¸ƒï¼‰
  await dealInitialHands();

  // 4) ã‚µã‚¤ã‚³ãƒ­ï¼†èµ¤ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’åˆæœŸä½ç½®ã«å†é…ç½®
  await initDiceState();
  await initCubeState();

  // 5) ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚åˆ»ã‚’æ›´æ–°
  await update(roomRef, {
    gameStarted: Date.now()
  });
}


// â˜… ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ï¼šæ¯å›ã€Œãƒªã‚»ãƒƒãƒˆï¼‹å†é…å¸ƒã€ã—ã¦ã‹ã‚‰é–‹å§‹
btnGameStart.addEventListener('click', async ()=>{
  if(!state.isHost) return;
  await clearRoleRevealState();
  await resetRoleVisibilityOnStart();
  await resetGameAndStart();
  await assignChefAbilitiesForCurrentPlayers();

  // ãƒãƒƒãƒ—ã‚’é–‰ã˜ã‚‹
  startPop.classList.add('hidden');
});

/* â˜… è¿½åŠ ï¼šãƒ›ã‚¹ãƒˆã®ã€Œãƒªã‚»ãƒƒãƒˆã€ãƒœã‚¿ãƒ³ */
btnGameReset.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;
  await resetRoleVisibilityOnStart();

  const roomRef = ref(db, `rooms/${state.roomCode}`);

  // 1) ã‚¹ãƒ†ãƒ¼ãƒˆã‚’ã€Œéƒ¨å±‹ã ã‘æ®‹ã—ã¦å…¨éƒ¨ãƒªã‚»ãƒƒãƒˆã€ã™ã‚‹
  await update(roomRef, {
chefRoles: null,
    hands: {},
    usedCards: [],
    discardPile: [],
    shuffleInfo: { lastShuffleAt: 0 },
    roles: null,
    centerRole: null,
    rolesOpen: null,
    turnState: null,
    dice: null,
    cubes: null,
    maxPlayers: null,  // â˜… äººæ•°ã‚‚æœªé¸æŠã«æˆ»ã™
    tables: {},        // â˜… å…¨å“¡ã®å¸­ã‚’å¤–ã™
    gameStarted: null,
  });

  await clearRoleRevealState();


  // 2) ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆ
  state.seatedTable = null;
  latestPlayers = [];

  // ã‚µã‚¤ã‚³ãƒ­ãƒ»ã‚­ãƒ¥ãƒ¼ãƒ–ã‚¨ãƒªã‚¢ã‚’ä¸€æ—¦æ¶ˆã—ã¦ãŠã
  if (diceArea){
    diceArea.remove();
    diceArea = null;
  }
  if (cubeArea){
    cubeArea.remove();
    cubeArea = null;
  }

  // 3) ãƒ›ã‚¹ãƒˆã«ã¯ã€Œäººæ•°ã‚’é¸æŠã€ãƒãƒƒãƒ—ã‚’å‡ºã™
  await renderSeatTabs();
  seatPop.classList.remove('hidden');

  // ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒƒãƒ—ã¯é–‰ã˜ã‚‹
  startPop.classList.add('hidden');



});
// â˜… æ­£ä½“å…¬é–‹ãƒ»å€‹åˆ¥è¦—ãçŠ¶æ…‹ã‚’ã¾ã¨ã‚ã¦æ¶ˆã™ãƒ˜ãƒ«ãƒ‘ãƒ¼
async function clearRoleRevealState(){
  if (!state.roomCode) return;
  const baseRef = ref(db, `rooms/${state.roomCode}`);

  await update(baseRef, {
    // å½¹è·ãã®ã‚‚ã®
    roles: null,
    centerRole: null,

    // å…¬é–‹ã•ã‚ŒãŸæ­£ä½“
    rolesOpen: null,

    // å€‹äººçš„ã«è¦‹ãŸæ­£ä½“ï¼ˆã‚«ãƒ¼ãƒ‰åŠ¹æœãªã©ï¼‰
    peekRoleGlobal: null,
    peekRoleView: null,

    // 3äººã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®æ®‹éª¸ã‚‚æ¶ˆã™
    shuffle3Global: null
  });

  // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚ã‚¯ãƒªã‚¢
  state.roles = {};
  state.centerRole = null;
  state.roleOpenMap = {};
  state.peekRoleGlobal = null;
  state.peekRoleView = {};
  shuffle3SelectedIds = [];

  firstTurnPeekStarted = false;
  for (const k in firstPeekTargets){
    delete firstPeekTargets[k];
  }

  // ç”»é¢å†æç”»ï¼ˆãƒãƒ¼ãƒ ã‚¿ã‚°ã¾ã‚ã‚Šã®å…¬é–‹ã‚«ãƒ¼ãƒ‰ã‚„ğŸ‘€ã‚’æ¶ˆã™ï¼‰
  renderMyPanelsInOrder();
  if (latestPlayers.length){
    renderPlayerCircle(latestPlayers);
  }
}


/* â˜…â˜…â˜… ã“ã“ãŒä¿®æ­£ãƒã‚¤ãƒ³ãƒˆï¼šæ¯å› DB ã‹ã‚‰æœ€æ–° turnState ã¨ tables ã‚’èª­ã‚€ â˜…â˜…â˜… */
async function advanceTurnToNext(){
  if (!state.isHost) return;
  if (!state.roomCode) return;

  // 1) ä»Šã®ãƒ†ãƒ¼ãƒ–ãƒ«çŠ¶æ…‹ã‹ã‚‰ã€Œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã€ã‚’ DB ã‹ã‚‰ä½œã‚‹ï¼ˆlatestPlayers ã¯ä½¿ã‚ãªã„ï¼‰
  let players = [];
  try {
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    players = Object.entries(tables)
      .map(([seatIndex, t]) =>
        t && t.playerId ? {
          id: t.playerId,
          name: t.playerName || 'åç„¡ã—',
          seatIndex: Number(seatIndex)
        } : null
      )
      .filter(Boolean)
      .sort((a, b) => a.seatIndex - b.seatIndex);
  } catch (err) {
    console.error('read tables error', err);
    return;
  }

  if (!players.length) return;

  // 2) ã€Œæœ€å¾Œã«è¡¨ç¤ºã—ã¦ã„ãŸå¸­ã€ã‚’ DB ã® turnState ã‹ã‚‰èª­ã‚€
  let currentSeat = null;
  try {
    const turnSnap = await get(ref(db, `rooms/${state.roomCode}/turnState`));
    const turnVal = turnSnap.val();
    if (turnVal && typeof turnVal.seatIndex === 'number') {
      currentSeat = turnVal.seatIndex;
    }
  } catch (err) {
    console.error('read turnState error', err);
  }

  // 3) ãƒ†ãƒ¼ãƒ–ãƒ«é †ã§ã€Œæ¬¡ã®å¸­ã€ã‚’æ±ºã‚ã‚‹ï¼ˆå¿…ãš +1 / ç«¯ã¾ã§è¡Œã£ãŸã‚‰å…ˆé ­ï¼‰
  let nextSeatIndex;
  if (currentSeat == null) {
    // ã¾ã ä¸€åº¦ã‚‚è¡¨ç¤ºã—ã¦ã„ãªã„ â†’ ã„ã¡ã°ã‚“å°ã•ã„å¸­ç•ªå·ã‹ã‚‰
    nextSeatIndex = players[0].seatIndex;
  } else {
    const idx = players.findIndex(p => p.seatIndex === currentSeat);
    if (idx === -1) {
      // ç¾åœ¨ seat ãŒãƒªã‚¹ãƒˆã«ã„ãªã„ã¨ãï¼š
      // ã€ŒcurrentSeat ã‚ˆã‚Šå¤§ãã„æœ€åˆã®å¸­ã€â†’ ãªã‘ã‚Œã°å…ˆé ­
      const after = players.find(p => p.seatIndex > currentSeat);
      nextSeatIndex = after ? after.seatIndex : players[0].seatIndex;
    } else {
      // ãµã¤ã†ã®ã‚±ãƒ¼ã‚¹ï¼šé…åˆ—ä¸Šã§ +1ï¼ˆç«¯ã¾ã§è¡Œã£ãŸã‚‰å…ˆé ­ï¼‰
      const nextPlayer = players[(idx + 1) % players.length];
      nextSeatIndex = nextPlayer.seatIndex;
    }
  }

  const nextPlayer = players.find(p => p.seatIndex === nextSeatIndex);
  if (!nextPlayer) return;

  // 4) DB ã® turnState ã«ã€Œä»Šå›è¡¨ç¤ºã™ã‚‹å¸­ç•ªå·ã€ã‚’æ›¸ãè¾¼ã‚€
  const tRef = ref(db, `rooms/${state.roomCode}/turnState`);
  await set(tRef, {
    seatIndex: nextSeatIndex,
    playerId: nextPlayer.id,
    playerName: nextPlayer.name,
    startedAt: Date.now()
  });
}

/* â–·é•·æŠ¼ã—ã®å®Ÿè£… */
if(turnNextBtn){
  turnNextBtn.addEventListener('pointerdown', (e)=>{
    if(!state.isHost) return;
    turnBtnPointerId = e.pointerId;
    turnBtnDownX = e.clientX;
    turnBtnDownY = e.clientY;
    turnBtnLongPressTriggered = false;
    clearTurnBtnLongPressTimer();
    turnBtnLongPressTimer = setTimeout(()=>{
      turnBtnLongPressTriggered = true;
      suppressTurnClick = true;
      showTurnSelectPop();
    }, LONG_PRESS_MS);
    turnNextBtn.setPointerCapture(turnBtnPointerId);
  });

  turnNextBtn.addEventListener('pointermove', (e)=>{
    if(turnBtnPointerId == null || e.pointerId !== turnBtnPointerId) return;
    if(!turnBtnLongPressTimer) return;
    const dx = e.clientX - turnBtnDownX;
    const dy = e.clientY - turnBtnDownY;
    if(Math.abs(dx) > LONG_PRESS_MOVE_TOL || Math.abs(dy) > LONG_PRESS_MOVE_TOL){
      clearTurnBtnLongPressTimer();
    }
  });

  const endTurnBtnPointer = (e)=>{
    if(turnBtnPointerId == null || e.pointerId !== turnBtnPointerId) return;
    clearTurnBtnLongPressTimer();
    try{ turnNextBtn.releasePointerCapture(turnBtnPointerId); }catch{}
    turnBtnPointerId = null;
  };
  turnNextBtn.addEventListener('pointerup', endTurnBtnPointer);
  turnNextBtn.addEventListener('pointercancel', endTurnBtnPointer);

  turnNextBtn.addEventListener('click', async (e)=>{
  maybeSetFirstTurnByDice();

    if(!state.isHost) return;
    if(suppressTurnClick){
      suppressTurnClick = false;
      return;
    }

    /* â˜… è¿½åŠ ï¼šãƒ­ãƒƒã‚¯ä¸­ã¯ä½•ã‚‚ã—ãªã„ */
    const now = Date.now();
    if (now < turnClickLockedUntil) {
      return;
    }

    await advanceTurnToNext();
  });
}
/* â˜… è¿½åŠ ï¼šæ­£ä½“ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦é…ã‚‹ */
async function initRoles(){
  if(!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const seats = Object.entries(tables)
    .map(([seatIndex, t]) =>
      t && t.playerId ? {
        seatIndex: Number(seatIndex),
        playerId: t.playerId,
        name: t.playerName || 'åç„¡ã—'
      } : null
    )
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex - b.seatIndex);

  const n = seats.length;
  if(!n) return;

  // â˜… å…‰ã¨å½±ã®æ­£ä½“ã‚«ãƒ¼ãƒ‰ã‚’ä½œã‚‹
  let roleCards = [];
  if(n % 2 === 0){
    // å¶æ•°ï¼šå…‰ã¨å½±ãŒåŠã€…
    const half = n / 2;
    roleCards = Array(half).fill('LIGHT').concat(Array(half).fill('SHADOW'));
  }else{
    // å¥‡æ•°ï¼šå…‰ã¨å½±ã‚’åŒã˜æ•°ã ã‘ä½œã‚Šã€1æšä½™ã‚‰ã›ã‚‹ï¼ˆæ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰ã«ãªã‚‹ï¼‰
    const halfPlus = (n + 1) / 2;
    roleCards = Array(halfPlus).fill('LIGHT').concat(Array(halfPlus).fill('SHADOW'));
  }

  // ã‚·ãƒ£ãƒƒãƒ•ãƒ«
  for(let i = roleCards.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [roleCards[i], roleCards[j]] = [roleCards[j], roleCards[i]];
  }

  const rolesByPlayer = {};
  let centerRole = null;

  if(n % 2 === 0){
    // å¶æ•°ï¼šå…¨å“¡ã«1æšãšã¤é…ã‚‹ã ã‘
    seats.forEach((s,idx)=>{
      rolesByPlayer[s.playerId] = {
        seatIndex: s.seatIndex,
        type: roleCards[idx] // 'LIGHT' or 'SHADOW'
      };
    });
  }else{
    // å¥‡æ•°ï¼šNäººã«é…ã£ã¦ã€1æšä½™ã‚‰ã›ã‚‹ â†’ æ¬ ã‘æ­£ä½“ã‚«ãƒ¼ãƒ‰
    seats.forEach((s,idx)=>{
      rolesByPlayer[s.playerId] = {
        seatIndex: s.seatIndex,
        type: roleCards[idx]
      };
    });
    centerRole = roleCards[roleCards.length - 1];
  }

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  await update(roomRef, {
    roles: rolesByPlayer,
    centerRole: centerRole || null
  });
}

/* é–‹å§‹æ™‚ã®é…ã‚Šæ–¹ï¼šCARD_POOLã‹ã‚‰é‡è¤‡ãªã—ã§é…ã‚‹ */
async function dealInitialHands(){
  if(!state.roomCode) return;
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const deck = [...CARD_POOL];

  function drawCard(){
    if(deck.length === 0) return null;
    const idx = Math.floor(Math.random() * deck.length);
    const [cardId] = deck.splice(idx, 1);
    return cardId;
  }

  const hands = {};
  for(const seatIndex of Object.keys(tables)){
    const t = tables[seatIndex];
    if(!t || !t.playerId) continue;

    const cards = [];
    for(let i=0;i<5;i++){
      const c = drawCard();
      if(!c) break;
      cards.push(c);
    }
    hands[t.playerId] = { cards };
  }

  await set(ref(db, `rooms/${state.roomCode}/hands`), hands);
}

/* æ‰‹æœ­ãƒãƒƒãƒ—ï¼šå¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ */
document.addEventListener('click', (e)=>{
  if (!useCardDialog || useCardDialog.classList.contains('hidden')) return;
  if (e.target.closest('#useCardDialog')) return;
  if (e.target.closest('.my-card')) return;
  closeUseCardDialog();
});

/* å±±æœ­é…å¸ƒãƒãƒƒãƒ—ã‚’å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ */
document.addEventListener('click', (e)=>{
  if (!deckDealPop || deckDealPop.classList.contains('hidden')) return;
  if (e.target.closest('#deckDealPop')) return;
  if (e.target.closest('#deckStack')) return;
  hideDeckDealPop();
});

/* â˜…â˜…â˜… ã“ã“ã‹ã‚‰å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–å‡¦ç† â˜…â˜…â˜… */

function ensureCubeArea(){
  if(cubeArea) return;
  cubeArea = document.createElement('div');
  cubeArea.id = 'cubeArea';
  cubeArea.className = 'cube-circle';
  document.body.appendChild(cubeArea);
}

/* åŠå¾„ã§ã‚¯ãƒ©ãƒ³ãƒ—ã™ã‚‹æ±ç”¨é–¢æ•°ï¼ˆã‚­ãƒ¥ãƒ¼ãƒ–ç”¨ï¼‰ */
function clampToRadius(x,y,radius){
  const dist = Math.hypot(x,y);
  if(dist > radius){
    const k = radius/dist;
    x *= k;
    y *= k;
  }
  return {x,y};
}

function setCubePosition(el,x,y){
  el.dataset.tx = String(x);
  el.dataset.ty = String(y);
  el.style.setProperty('--tx', x + 'px');
  el.style.setProperty('--ty', y + 'px');
}

/* â˜… DB ã«ã€Œå¤–ãƒ‰ãƒ©ãƒƒã‚°ä¸­ãƒ•ãƒ©ã‚°ã€ã‚’ç«‹ã¦ãŸã‚Šæ¶ˆã—ãŸã‚Šã™ã‚‹ */
function setCubeDraggingFlag(cubeId, flag){
  if(!state.roomCode || !cubeId) return;
  const cubeRef = ref(db, `rooms/${state.roomCode}/cubes/${cubeId}`);
  update(cubeRef, {
    draggingOutBy: flag ? state.userId : null
  });
}

/* ã‚­ãƒ¥ãƒ¼ãƒ–çŠ¶æ…‹ã‚’DBã«åŒæœŸï¼ˆå³ä¸Šå††ã®ä¸­ã«ã‚ã‚‹ã‚‚ã®ã ã‘ï¼‰ */
function syncCubesToDB(){
  if(!state.roomCode || !cubeArea) return;
  const cubes = cubeArea.querySelectorAll('.cube-piece:not(.attached-hidden)');
  if(!cubes.length) return;
  const updates = {};
  const now = Date.now();
  cubes.forEach(c => {
    const id = c.dataset.id;
    if(!id) return;
    const tx = parseFloat(c.dataset.tx || '0');
    const ty = parseFloat(c.dataset.ty || '0');
    updates[id] = {
      tx, ty,
      updatedBy: state.userId,
      updatedAt: now
    };
  });
  const cubesRef = ref(db, `rooms/${state.roomCode}/cubes`);
  update(cubesRef, updates);
}

/* å††å†…ã®ã‚­ãƒ¥ãƒ¼ãƒ–åŒå£«ã®è¡çªè§£æ¶ˆï¼ˆå³ä¸Šå††ç”¨ï¼‰ */
function resolveCubeCollisions(anchorCube = null){
  if(!cubeArea) return;
  const all = Array.from(cubeArea.querySelectorAll('.cube-piece'));
  const cubes = all.filter(c => !c.classList.contains('attached-hidden'));
  const n = cubes.length;
  if(n <= 1) return;

  const xs = new Array(n);
  const ys = new Array(n);
  let anchorIndex = -1;

  for(let i=0;i<n;i++){
    xs[i] = parseFloat(cubes[i].dataset.tx || '0');
    ys[i] = parseFloat(cubes[i].dataset.ty || '0');
    if(anchorCube && cubes[i] === anchorCube){
      anchorIndex = i;
    }
  }

  for(let iter=0; iter<8; iter++){
    let moved = false;
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        let dx = xs[j] - xs[i];
        let dy = ys[j] - ys[i];
        let dist = Math.hypot(dx,dy);
        if(dist === 0){
          dx = (Math.random()-0.5)||0.01;
          dy = (Math.random()-0.5)||0.01;
          dist = Math.hypot(dx,dy);
        }
        if(dist < CUBE_COLLIDE_DIST){
          const overlap = (CUBE_COLLIDE_DIST - dist)/2;
          const nx = dx/dist;
          const ny = dy/dist;

          if(anchorIndex !== -1){
            if(i === anchorIndex){
              xs[j] += nx*overlap*2;
              ys[j] += ny*overlap*2;
              ({x:xs[j],y:ys[j]} = clampToRadius(xs[j],ys[j], CUBE_INNER_RADIUS));
            }else if(j === anchorIndex){
              xs[i] -= nx*overlap*2;
              ys[i] -= ny*overlap*2;
              ({x:xs[i],y:ys[i]} = clampToRadius(xs[i],ys[i], CUBE_INNER_RADIUS));
            }else{
              xs[i] -= nx*overlap;
              ys[i] -= ny*overlap;
              xs[j] += nx*overlap;
              ys[j] += ny*overlap;
              ({x:xs[i],y:ys[i]} = clampToRadius(xs[i],ys[i], CUBE_INNER_RADIUS));
              ({x:xs[j],y:ys[j]} = clampToRadius(xs[j],ys[j], CUBE_INNER_RADIUS));
            }
          }else{
            xs[i] -= nx*overlap;
            ys[i] -= ny*overlap;
            xs[j] += nx*overlap;
            ys[j] += ny*overlap;
            ({x:xs[i],y:ys[i]} = clampToRadius(xs[i],ys[i], CUBE_INNER_RADIUS));
            ({x:xs[j],y:ys[j]} = clampToRadius(xs[j],ys[j], CUBE_INNER_RADIUS));
          }
          moved = true;
        }
      }
    }
    if(!moved) break;
  }

  for(let i=0;i<n;i++){
    if(anchorIndex !== -1 && i === anchorIndex) continue;
    setCubePosition(cubes[i], xs[i], ys[i]);
  }
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ä¸­å¿ƒã®ã©ã‚Œã‹ã®å††ï¼ˆåŠå¾„35pxï¼‰ã«å…¥ã£ã¦ã„ã‚‹ã‹åˆ¤å®š */
function findSeatByPoint(clientX, clientY){
  const tags = document.querySelectorAll('.player-tag');
  let bestSeat = null;
  let bestDist = Infinity;
  const R = 35;

  tags.forEach(tag => {
    const seatIndex = Number(tag.dataset.seatIndex || '-1');
    if(seatIndex < 0) return;
    const rect = tag.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;
    const dist = Math.hypot(dx,dy);
    if(dist <= R && dist < bestDist){
      bestDist = dist;
      bestSeat = seatIndex;
    }
  });

  return bestSeat;
}

/* ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’æŒ‡å®šå¸­ã®ãƒãƒ¼ãƒ ã‚¿ã‚°ã«ã‚¢ã‚¿ãƒƒãƒ */
async function attachCubeToSeat(cubeEl, seatIndex){
  if(!state.roomCode) return;
  if(seatIndex == null) return;
  const cubeId = cubeEl.dataset.id;
  if(!cubeId) return;

  const cubeRef = ref(db, `rooms/${state.roomCode}/cubes/${cubeId}`);
  const snap = await get(cubeRef);
  const cur = snap.val() || {};
  cur.attachedSeat = seatIndex;
  cur.draggingOutBy = null;   // â˜… ç€åœ°ã—ãŸã®ã§å¤–ãƒ‰ãƒ©ãƒƒã‚°ãƒ•ãƒ©ã‚°è§£é™¤
  cur.updatedBy = state.userId;
  cur.updatedAt = Date.now();
  await set(cubeRef, cur);
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ã‹ã‚‰20pxä»¥ä¸Šãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚­ãƒ¥ãƒ¼ãƒ–ã‚’å††ã«æˆ»ã™ */
async function detachCubeFromSeat(cubeId){
  if(!state.roomCode || !cubeId) return;
  const cubesRef = ref(db, `rooms/${state.roomCode}/cubes`);
  const snap = await get(cubesRef);
  const cubes = snap.val() || {};
  const cube = cubes[cubeId];
  if(!cube) return;

  const usedPositions = [];
  Object.entries(cubes).forEach(([id,c])=>{
    if(!c || id === cubeId) return;
    if(c.attachedSeat) return;
    const x = Number(c.tx)||0;
    const y = Number(c.ty)||0;
    usedPositions.push({x,y});
  });

  function randomPos(){
    for(let attempt=0; attempt<50; attempt++){
      const r = CUBE_INNER_RADIUS * Math.sqrt(Math.random());
      const ang = Math.random()*2*Math.PI;
      let x = r*Math.cos(ang);
      let y = r*Math.sin(ang);
      let ok = true;
      for(const p of usedPositions){
        if(Math.hypot(p.x-x,p.y-y) < CUBE_COLLIDE_DIST){
          ok = false;
          break;
        }
      }
      if(ok){
        usedPositions.push({x,y});
        return {x,y};
      }
    }
    return {x:0,y:0};
  }

  const pos = randomPos();
  cube.tx = pos.x;
  cube.ty = pos.y;
  cube.attachedSeat = null;
  cube.updatedBy = state.userId;
  cube.updatedAt = Date.now();

  const updates = {};
  updates[cubeId] = cube;
  await update(cubesRef, updates);
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°å³å´ã«ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’æç”»ã™ã‚‹ï¼ˆside-left/side-rightå¯¾å¿œï¼‰ */
function renderAttachedCubesForAllPlayers(){
  if(!latestCubeData) return;
  const tags = document.querySelectorAll('.player-tag');
  if(!tags.length) return;

  tags.forEach(tag => {
    const seatIndex = Number(tag.dataset.seatIndex || '-1');
    if(seatIndex < 0) return;

    let row = tag.querySelector('.attached-cube-row');
    if(!row){
      row = document.createElement('div');
      row.className = 'attached-cube-row';
      row.dataset.seatIndex = String(seatIndex);
      tag.appendChild(row);
    }
    row.innerHTML = '';

    const cubesForSeat = Object.entries(latestCubeData)
      .filter(([id,info]) => info && info.attachedSeat === seatIndex)
      .sort((a,b) => (a[1].updatedAt || 0) - (b[1].updatedAt || 0));

    cubesForSeat.forEach(([id,info]) => {
      const cubeHolder = document.createElement('div');
      cubeHolder.className = 'attached-cube';
      cubeHolder.dataset.cubeId = id;
      cubeHolder.dataset.seatIndex = String(seatIndex);
      if(cubeTemplate){
        cubeHolder.appendChild(cubeTemplate.content.cloneNode(true));
      }
      cubeHolder.addEventListener('pointerdown', onAttachedCubePointerDown);
      row.appendChild(cubeHolder);
    });
  });
}

/* ãƒãƒ¼ãƒ ã‚¿ã‚°ã«ä¸¦ã‚“ã§ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã®ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç† */
function onAttachedCubePointerDown(e){
  const el = e.currentTarget;
  attachedDragCube = el;
  attachedDragPointerId = e.pointerId;
  attachedDragSeatIndex = Number(el.dataset.seatIndex || '-1');
  attachedDragCubeId = el.dataset.cubeId || null;
  attachedDragStartX = e.clientX;
  attachedDragStartY = e.clientY;
  el.classList.add('dragging');
  el.style.transition = 'none';
  el.style.transform = 'translate(0,0)';
  el.setPointerCapture(attachedDragPointerId);
}

function onAttachedCubePointerMove(e){
  if(!attachedDragCube || e.pointerId !== attachedDragPointerId) return;
  const dx = e.clientX - attachedDragStartX;
  const dy = e.clientY - attachedDragStartY;
  attachedDragCube.style.transform = `translate(${dx}px, ${dy}px)`;
}

// â˜… ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚ã«ã€Œå…¬é–‹æ­£ä½“ã€ã€Œå€‹äººçš„å…¬é–‹æ­£ä½“ã€ã‚’å…¨ã¦è§£é™¤ã™ã‚‹
async function resetRoleVisibilityOnStart(){
  if (!state.roomCode) return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);

  await update(roomRef, {
    // ã€Œæ­£ä½“ã‚’è¦‹ã‚‹ã€ã€Œæ­£ä½“ã‚’è¦‹ã›ã‚ã†ã€ãªã©ã®é€²è¡Œä¸­ãƒ•ãƒ­ãƒ¼ã‚’æ¶ˆã™
    peekRoleGlobal: null,
    // å€‹äººçš„å…¬é–‹çŠ¶æ…‹ã‚’å…¨éƒ¨æ¶ˆã™ï¼ˆç‚¹ç·šæ ã‚«ãƒ¼ãƒ‰ / ğŸ‘€ ã‚’æ¶ˆã™ï¼‰
    peekRoleView: null,
    // å…¬é–‹çŠ¶æ…‹ãƒ•ãƒ©ã‚°ã‚’å…¨éƒ¨æ¶ˆã™ï¼ˆå…¬é–‹æ­£ä½“ã‚’ãƒªã‚»ãƒƒãƒˆï¼‰
    rolesOpen: null
  });

  // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚‚å³ãƒªã‚»ãƒƒãƒˆï¼ˆè³¼èª­ã§ä¸Šæ›¸ãã•ã‚Œã‚‹ãŒã€è¦‹ãŸç›®ã‚’æ—©ãæˆ»ã™ãŸã‚ï¼‰
  state.peekRoleGlobal = null;
  state.peekRoleView   = {};
  state.roleOpenMap    = {};
}


async function onAttachedCubePointerUp(e){
  if(!attachedDragCube || e.pointerId !== attachedDragPointerId) return;
  const el = attachedDragCube;
  try{ el.releasePointerCapture(attachedDragPointerId);}catch{}
  el.classList.remove('dragging');
  el.style.transition = 'transform .15s ease-out';

  const dx = e.clientX - attachedDragStartX;
  const dy = e.clientY - attachedDragStartY;
  const dist = Math.hypot(dx,dy);

  el.style.transform = 'translate(0,0)';

  const cubeId = attachedDragCubeId;
  attachedDragCube = null;
  attachedDragPointerId = null;
  attachedDragCubeId = null;
  attachedDragSeatIndex = null;
  attachedDragStartX = 0;
  attachedDragStartY = 0;

  if(dist > 80 && cubeId){
    await detachCubeFromSeat(cubeId);
  }
}

window.addEventListener('pointermove', onAttachedCubePointerMove);
window.addEventListener('pointerup', onAttachedCubePointerUp);
window.addEventListener('pointercancel', onAttachedCubePointerUp);

/* ã‚­ãƒ¥ãƒ¼ãƒ–å††å†…ãƒ‰ãƒ©ãƒƒã‚° */
function onCubePointerDown(e){
  if(!cubeArea) return;
  const cube = e.currentTarget;
  draggingCube = cube;
  cubePointerId = e.pointerId;

  cubeStartTx = parseFloat(cube.dataset.tx || '0');
  cubeStartTy = parseFloat(cube.dataset.ty || '0');
  cubeStartX = e.clientX;
  cubeStartY = e.clientY;

  cubeDragWasOutside = false;  // â˜… å¤–ã«å‡ºãŸã‹ã©ã†ã‹ãƒªã‚»ãƒƒãƒˆ

  cube.classList.add('dragging');
  cube.setPointerCapture(cubePointerId);
}

function onCubePointerMove(e){
  if(!draggingCube || e.pointerId !== cubePointerId) return;
  const dx = e.clientX - cubeStartX;
  const dy = e.clientY - cubeStartY;

  let x = cubeStartTx + dx;
  let y = cubeStartTy + dy;

  setCubePosition(draggingCube, x, y);

  const inside = isInsideCubeRadius(x, y);

  if(inside){
    // å††ã®ä¸­ï¼†ã¾ã ã€Œå¤–ã«å‡ºãŸã“ã¨ãŒãªã„ã€é–“ã ã‘åŒæœŸãƒ»è¡çªè§£æ¶ˆ
    if(!cubeDragWasOutside){
      resolveCubeCollisions(draggingCube);
      syncCubesToDB();
    }
  }else{
    // åˆã‚ã¦å††ã®å¤–ã«å‡ºãŸç¬é–“ã«ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼†åŒæœŸåœæ­¢
    if(!cubeDragWasOutside){
      cubeDragWasOutside = true;
      const cubeId = draggingCube.dataset.id;
      if(cubeId) setCubeDraggingFlag(cubeId, true);
      // ä»¥å¾Œã¯ç€åœ°ã¾ã§ syncCubesToDB ã—ãªã„
    }
  }
}

async function onCubePointerUp(e){
  if(!draggingCube || e.pointerId !== cubePointerId) return;
  const cube = draggingCube;

  try{ cube.releasePointerCapture(cubePointerId); }catch{}
  cube.classList.remove('dragging');
  draggingCube = null;
  cubePointerId = null;

  let tx = parseFloat(cube.dataset.tx || '0');
  let ty = parseFloat(cube.dataset.ty || '0');
  const inside = isInsideCubeRadius(tx, ty);

  const seatIndex = findSeatByPoint(e.clientX, e.clientY);

  if(seatIndex != null){
    // ãƒãƒ¼ãƒ ã‚¿ã‚°ã«ç€åœ° â†’ ã‚¢ã‚¿ãƒƒãƒï¼ˆä¸­ã§ draggingOutBy ã‚‚è§£é™¤ï¼‰
    await attachCubeToSeat(cube, seatIndex);
  }else if(!inside){
    // å††ã®å¤–ï¼†ãƒãƒ¼ãƒ ã‚¿ã‚°ã§ã‚‚ãªã„ â†’ å††å†…ã«æˆ»ã—ã¦1å›ã ã‘åŒæœŸ
    const clamped = clampToRadius(tx, ty, CUBE_INNER_RADIUS);
    setCubePosition(cube, clamped.x, clamped.y);
    resolveCubeCollisions(cube);
    syncCubesToDB();
  }else{
    // ãšã£ã¨å††å†… or å††å†…ã§ãƒ‰ãƒ­ãƒƒãƒ— â†’ é€šå¸¸ã®åŒæœŸ
    resolveCubeCollisions(cube);
    syncCubesToDB();
  }

  // ä¸€åº¦ã§ã‚‚å¤–ã«å‡ºã¦ã„ãŸãªã‚‰ã€å¤–ãƒ‰ãƒ©ãƒƒã‚°ãƒ•ãƒ©ã‚°ã‚’æ¶ˆã™
  if(cubeDragWasOutside){
    const cubeId = cube.dataset.id;
    if(cubeId) setCubeDraggingFlag(cubeId, false);
    cubeDragWasOutside = false;
  }
}

window.addEventListener('pointermove', onCubePointerMove);
window.addEventListener('pointerup', onCubePointerUp);
window.addEventListener('pointercancel', onCubePointerUp);

function subscribeCubes(){
  if(!state.roomCode) return;
  const cubesRef = ref(db, `rooms/${state.roomCode}/cubes`);
  onValue(cubesRef, snap => {
    const data = snap.val() || {};
    latestCubeData = data;
    ensureCubeArea();
    renderCubesFromState(data);
    renderAttachedCubesForAllPlayers();
  });
}

/* å³ä¸Šå††ã®ã‚­ãƒ¥ãƒ¼ãƒ–æç”»ï¼ˆattachedSeat ãŒ null ã®ã‚‚ã®ã ã‘è¡¨ç¤ºã€‚
   draggingOutBy ãŒè‡ªåˆ†ä»¥å¤–ã®ã‚‚ã®ã¯ä¸å¯è¦–ï¼‰ */
function renderCubesFromState(cubeData){
  if(!cubeArea) return;

  const existing = new Map();
  cubeArea.querySelectorAll('.cube-piece').forEach(el => {
    existing.set(el.dataset.id, el);
  });

  Object.entries(cubeData).forEach(([id,info])=>{
    if(!info) return;
    let cube = existing.get(id);
    if(!cube){
      cube = document.createElement('div');
      cube.className = 'cube-piece';
      cube.dataset.id = id;
      cube.dataset.tx = '0';
      cube.dataset.ty = '0';
      if(cubeTemplate){
        const frag = cubeTemplate.content.cloneNode(true);
        cube.appendChild(frag);
      }
      cube.addEventListener('pointerdown', onCubePointerDown);
      cubeArea.appendChild(cube);
    }
    existing.delete(id);

    let tx = Number(info.tx) || 0;
    let ty = Number(info.ty) || 0;
    setCubePosition(cube, tx, ty);

    if(info.attachedSeat != null && info.attachedSeat !== undefined){
      cube.classList.add('attached-hidden');
      cube.style.display = 'none';
    }else{
      cube.classList.remove('attached-hidden');
      // å¤–ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ã€ã‹ã¤è‡ªåˆ†ä»¥å¤–ãŒè§¦ã£ã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã¯ä¸å¯è¦–
      if(info.draggingOutBy && info.draggingOutBy !== state.userId){
        cube.style.display = 'none';
      }else{
        cube.style.display = '';
      }
    }
  });

  for(const el of existing.values()){
    el.remove();
  }
}

/* å„å‚åŠ è€…ã«3å€‹ãšã¤ç«‹æ–¹ä½“ã‚’é…ç½® */
async function initCubeState(){
  if(!state.roomCode) return;
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const cubes = {};
  const usedPositions = [];

  function randomPos(){
    for(let attempt=0; attempt<100; attempt++){
      const r = CUBE_INNER_RADIUS * Math.sqrt(Math.random());
      const angle = Math.random()*2*Math.PI;
      let x = r*Math.cos(angle);
      let y = r*Math.sin(angle);

      let ok = true;
      for(const p of usedPositions){
        const dist = Math.hypot(p.x - x, p.y - y);
        if(dist < CUBE_COLLIDE_DIST){
          ok = false;
          break;
        }
      }
      if(ok){
        usedPositions.push({x,y});
        return {x,y};
      }
    }
    return {x:0,y:0};
  }

  for(const [seatIndex, t] of Object.entries(tables)){
    if(!t || !t.playerId) continue;
    for(let i=0;i<3;i++){
      const pos = randomPos();
      const id = `${seatIndex}_${i}`;
      cubes[id] = {
        tx: pos.x,
        ty: pos.y,
        ownerSeat: Number(seatIndex),
        attachedSeat: null,
        updatedBy: state.userId,
        updatedAt: Date.now()
      };
    }
  }

  await set(ref(db, `rooms/${state.roomCode}/cubes`), cubes);
}

/* â˜…â˜…â˜… å³ä¸Šã‚­ãƒ¥ãƒ¼ãƒ–å‡¦ç† ã“ã“ã¾ã§ â˜…â˜…â˜… */

/* å±±æœ­é…å¸ƒãƒãƒƒãƒ—ã®è¡¨ç¤º/éè¡¨ç¤º */
function showDeckDealPop(){
  if (!deckDealPop || !deckStackEl) return;

  deckDealPop.style.left = '0px';
  deckDealPop.style.top  = '0px';
  deckDealPop.classList.remove('hidden');

  const deckRect = deckStackEl.getBoundingClientRect();
  const popRect  = deckDealPop.getBoundingClientRect();

  let left = deckRect.left + (deckRect.width - popRect.width) / 2;
  let top  = deckRect.top  - popRect.height - 8;

  if (top < 8){
    top = deckRect.bottom + 8;
  }
  if (left < 8) left = 8;
  if (left + popRect.width > window.innerWidth - 8){
    left = window.innerWidth - popRect.width - 8;
  }

  deckDealPop.style.left = left + 'px';
  deckDealPop.style.top  = top  + 'px';
}

function hideDeckDealPop(){
  if (!deckDealPop) return;
  deckDealPop.classList.add('hidden');
}

/* å±±æœ­ é•·æŠ¼ã—é–‹å§‹ */
/* å±±æœ­ é•·æŠ¼ã—ï¼†ã‚¿ãƒƒãƒ—ç”¨ãƒãƒ³ãƒ‰ãƒ© */

function onDeckPointerDown(e){
  if(!state.roomCode) return;

  deckPointerId = e.pointerId;
  deckDownX = e.clientX;
  deckDownY = e.clientY;
  deckPressTriggered = false;

  clearDeckPressTimer();
  deckPressTimer = setTimeout(() => {
    deckPressTriggered = true;

    // â˜… é•·æŠ¼ã—ï¼šãƒ›ã‚¹ãƒˆã ã‘ã€Œé…ã‚‹ã€ãƒãƒƒãƒ—ã‚’è¡¨ç¤º
    if(!state.isHost || !deckDealPop || !deckStackEl) return;

    const rect = deckStackEl.getBoundingClientRect();
    const x = rect.left + rect.width  / 2;
    const y = rect.top  - 12;

    deckDealPop.style.left = `${x}px`;
    deckDealPop.style.top  = `${y}px`;
    deckDealPop.classList.remove('hidden');
  }, LONG_PRESS_MS);

  deckStackEl.setPointerCapture(deckPointerId);
}

function onDeckPointerMove(e){
  if(deckPointerId == null || e.pointerId !== deckPointerId) return;
  const dx = e.clientX - deckDownX;
  const dy = e.clientY - deckDownY;

  // å¤§ããå‹•ã„ãŸã‚‰é•·æŠ¼ã—ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆãƒ‰ãƒ©ãƒƒã‚°æ‰±ã„ï¼‰
  if(Math.abs(dx) > LONG_PRESS_MOVE_TOL || Math.abs(dy) > LONG_PRESS_MOVE_TOL){
    clearDeckPressTimer();
  }
}

async function onDeckPointerUp(e){
  if(deckPointerId == null || e.pointerId !== deckPointerId) return;

  clearDeckPressTimer();
  try{
    deckStackEl.releasePointerCapture(deckPointerId);
  }catch{}

  const wasLong = deckPressTriggered;
  const dx = e.clientX - deckDownX;
  const dy = e.clientY - deckDownY;
  const moved = (Math.abs(dx) > LONG_PRESS_MOVE_TOL || Math.abs(dy) > LONG_PRESS_MOVE_TOL);

  deckPointerId = null;
  deckPressTriggered = false;

  // é•·æŠ¼ã— or å¤§ããå‹•ã„ãŸãƒ‰ãƒ©ãƒƒã‚°ã¯ã€Œã‚¿ãƒƒãƒ—ã€ã¨ã—ã¦æ‰±ã‚ãªã„
  if(wasLong || moved) return;

  // â˜… çŸ­ã‚¿ãƒƒãƒ—ï¼šCHEF_BUREAUCRATèƒ½åŠ›ã«ã‚ˆã‚‹1ãƒ‰ãƒ­ãƒ¼ã‚’è©¦ã¿ã‚‹
  await handleDeckTapForDraw();
}

/* ã€Œé…ã‚‹ã€ãƒœã‚¿ãƒ³ */
if (btnDeckDeal){
  btnDeckDeal.addEventListener('click', async (e)=>{
    e.stopPropagation();
    await dealOneCardToLowCubePlayers();
    hideDeckDealPop();
  });
}

</script>

</body>
</html>


