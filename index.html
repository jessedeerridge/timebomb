<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>タイムボム</title>
<style>
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee;}
h1{margin:0;font-size:18px;}
.small{font-size:12px;opacity:.75;}
.join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px;}
.join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
.btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
.btn.primary{background:#111;color:#fff;border-color:#111;}
.btn.ghost{background:transparent;}
.hidden{display:none;}
#lobby{padding:20px;border-top:1px solid #eee;}
.copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}
.seat-pop{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);background:#00c9e8;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;}
.seat-pop.hidden{display:none;}
.seat-pop .row{display:flex;gap:8px;align-items:center;}
.seat-pop label{width:84px;font-size:13px;}
.seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
.tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
.tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
.tab.active{background:#111;color:#fff;border-color:#111;}
main.in-room{
  background-image:url('timebombback.jpg');
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
}
main{
  min-height:calc(100vh - 60px);
  background-image:url('mae.jpg');
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
}

/* ★ プレイヤー円配置用 */
.player-circle{
  position:relative;
  width:310px;
  height:310px;
  margin:20px auto 0;
  border-radius:50%;
  border:1px dashed #ddd;
  box-sizing:border-box;
}
.player-circle::before{
  content:'';
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  font-size:11px;
  opacity:.45;
  pointer-events:none;
}

/* ★ 12時のプレイヤーだけ上げる（tag全体＝ネーム＋カード群をまとめて上に） */
.player-tag{
  position:absolute;
  transform:translate(-50%,-50%) translateY(calc(var(--lift,0px) + var(--meLift,0px)));
  padding:4px 8px;
  border-radius:999px;
  background:#f8f8f8;
  border:1px solid #ddd;
  font-size:12px;
  white-space:nowrap;
  --lift:0px;
  --meLift:0px;
}
.player-tag.at-12{ --lift:-44px; }
.player-tag.me{
  background:#111;
  color:#fff;
  border-color:#111;
  --meLift:50px;
}

/* ★ ネームタグ内レイアウト */
.player-tag-main{
  display:flex;
  align-items:center;
  gap:4px;
}

/* ② Sカード所持者用：ネームタグの「右」に小さく表示 */
.player-tag-s-indicator{
  position:absolute;
  left:100%;
  top:50%;
  transform:translate(6px,-50%);
  width:26px;
  height:26px;
  border-radius:0;
  border:none;
  background-color:transparent;
  background-image:url('nipper.png');
  background-position:center;
  background-repeat:no-repeat;
  background-size:90%;
  box-shadow:none;
  overflow:visible;
  pointer-events:none;
}

/* 他プレイヤーのミニカード（ネームタグの下に横並び） */
.player-tag .mini-hand{
  position:absolute;
  left:50%;
  top:100%;
  transform:translate(-50%,4px);
  display:flex;
  gap:3px;
  pointer-events:auto;
}
.player-tag .mini-card{
  width:28px;
  height:42px;
  border-radius:6px;
  border:1px solid #bbb;
  background-color:#fff;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  box-shadow:0 2px 6px rgba(0,0,0,.15);
  transform:translateY(var(--ty,0px)) scale(1);
  transform-origin:center;
}
.player-tag .mini-card.is-back{ border-color:#bbb; }
.player-tag .mini-card.is-open{ border-color:#555; --ty:10px; }

/* ★ 自分の手札表示（大きめ横並び） */
.my-hand-wrapper{ margin-top:50px; text-align:center; }
.my-hand-title{ font-size:12px; opacity:.7; display:none; }
.my-hand{
  display:flex;
  justify-content:center;
  gap:8px;
  margin-top:6px;
  min-height:100px;
}
.my-card{
  width:60px;
  height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background-color:#fff;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  box-shadow:0 4px 12px rgba(0,0,0,.15);
}
.my-card.is-open{
  opacity:1;
  border-color:#555;
  box-shadow:0 4px 12px rgba(0,0,0,.25);
}
.my-card.is-closed{ opacity:.45; }

/* ① 5枚の手札の下に1枚だけ正体カード＋④Sカードを表示 */
.my-role-area{
  margin-top:8px;
  display:flex;
  justify-content:center;
  align-items:center;
  gap:8px;
  min-height:72px;
}
.my-role-card{
  width:48px;
  height:72px;
  border-radius:3px;
  border:1px solid #000;
  box-shadow:0 3px 8px rgba(0,0,0,.2);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
}
.my-role-card.good{ background-image:url('policerole.jpg'); }
.my-role-card.bad{ background-image:url('bombrole.jpg'); }

.my-s-card{
  width:65px;
  height:55px;
  border-radius:0;
  border:none;
  background-color:transparent;
  background-image:url('nipper.png');
  background-position:center;
  background-repeat:no-repeat;
  background-size:80%;
  box-shadow:none;
  cursor:grab;
  touch-action:none;
  user-select:none;
  pointer-events:auto;
}
.my-s-card.dragging{
  cursor:grabbing;
  filter:drop-shadow(0 8px 18px rgba(0,0,0,.35));
}
.my-s-card.placeholder{
  visibility:hidden;
  pointer-events:none;
  cursor:default;
  filter:none;
  background-image:none;
}

/* ★ 追い出し確認ダイアログ */
.dialog-backdrop{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.35);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:300;
}
.dialog-backdrop.hidden{ display:none; }
.dialog-box{
  background:#fff;
  border-radius:12px;
  padding:16px 18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  max-width:320px;
  width:calc(100% - 40px);
}
.dialog-box p{
  margin:0 0 12px;
  font-size:14px;
  line-height:1.6;
}
.dialog-buttons{
  display:flex;
  justify-content:flex-end;
  gap:8px;
}

/* ★ ホスト用 設定ボタン（右下固定） */
.host-settings-btn{
  position:fixed;
  right:16px;
  bottom:16px;
  width:44px;
  height:44px;
  border-radius:50%;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 8px 20px rgba(0,0,0,.18);
  display:none;
  align-items:center;
  justify-content:center;
  font-size:22px;
  cursor:pointer;
  z-index:230;
}
.host-settings-btn.visible{ display:flex; }

/* ★ スタートポップ（右下） */
.start-pop{
  position:fixed;
  right:16px;
  bottom:72px;
  background:#fff;
  border:1px solid #ddd;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.16);
  padding:10px 12px;
  z-index:240;
  min-width:240px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.start-pop.hidden{ display:none; }
.start-pop-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
}
.start-pop-title{ font-size:14px; font-weight:600; }
.start-pop-main{ font-size:13px; line-height:1.5; }
.start-pop-actions{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  margin-top:4px;
}

/* ★ ラウンド開始ポップ（画面中央を通って左→右へ流れる） */
.round-banner{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-150%, -50%);
  padding:8px 20px;
  background:#1f2937;
  color:#fff;
  border-radius:999px;
  font-size:14px;
  font-weight:700;
  box-shadow:0 12px 30px rgba(0,0,0,.25);
  z-index:260;
  white-space:nowrap;
  pointer-events:none;
  opacity:0;
}
.round-banner.show{ animation: roundSlide 1.8s cubic-bezier(.22,.84,.44,1) forwards; }
@keyframes roundSlide{
  0%{ transform:translate(-150%, -50%); opacity:0; }
  10%{ opacity:1; }
  50%{ transform:translate(-50%, -50%); opacity:1; }
  100%{ transform:translate(150%, -50%); opacity:0; }
}

/* 詳細情報消す用 */
.player-circle{ border:none; }
#roomInfoLobby, #lobby h2, #lobby p { display:none; }
#lobby.entered{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height: calc(100vh - 60px);
}

/* ★ 公開カード回収アニメーション用レイヤー */
.round-collect-layer{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:255;
}
.round-collect-card{
  position:absolute;
  border-radius:6px;
  border:1px solid rgba(0,0,0,.18);
  background-color:#fff;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  box-shadow:none;
  opacity:1;
  will-change:transform;
  transform-origin:center center; /* ★ 縮小しながら回収するときの基準 */
}

/* =========================
   ★ 中央「2デッキ用」スロット列
   ========================= */
.center-decks{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  display:flex;
  gap:24px;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  z-index:254;
}

/* 左右スロット（サイズは固定） */
.deck-slot{
  position:relative;
  width:28px;
  height:42px;
}

/* ★ 右スロットも使用（2回目シャッフルで裏向き山札） */
.deck-slot.right{
  transform:rotate(-2deg);
}

/* =========================
   ★ 山札（表向き＝左）
   ========================= */
.action-deck{
  position:absolute;
  left:0;
  top:0;
  width:28px;
  height:42px;
  display:none;
  pointer-events:none;
}
/* ★ 念のため：右デッキも左と完全同一サイズを強制 */
#deckRowRight.action-deck{ width:28px; height:42px; }
#deckRow.action-deck{ width:28px; height:42px; }

.action-deck .card{
  position:absolute;
  inset:0;
  border-radius:6px;
  border:1px solid rgba(0,0,0,.18);
  background-color:#fff;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  box-shadow:none;
}
.action-deck .card.c1{ transform:translate(0px, 0px); opacity:1; }
.action-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
.action-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
.action-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
.action-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
.action-deck .count{
  position:absolute;
  right:-8px; top:-8px;
  font-size:11px;
  font-weight:900;
  padding:2px 6px;
  border-radius:999px;
  background:rgba(255,255,255,.92);
  border:1px solid rgba(0,0,0,.18);
  color:#111;
  line-height:1.1;
  display:none;
}

/* =========================
   ★ 右デッキのシャッフル演出（小デッキ用）
   ========================= */
.right-deck-shuffle{
  --shuffle-card-w:28px;
  --shuffle-card-h:42px;
  --shuffle-offset-x:2px;
  --shuffle-offset-y:2px;
  --shuffle-out-x:18px;
  --shuffle-tilt-base:5deg;
  --shuffle-tilt-more:5deg;
  --shuffle-dur-out:220ms;
  --shuffle-dur-in:220ms;
  --shuffle-pause:20ms;
  position:fixed;
  width:var(--shuffle-card-w);
  height:var(--shuffle-card-h);
  transform:translate(-50%,-50%);
  pointer-events:none;
  z-index:257;
}
.right-deck-shuffle-card{
  position:absolute;
  inset:0;
  border-radius:6px;
  border:1px solid rgba(0,0,0,.18);
  background-color:#fff;
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  box-shadow:none;
  transform-origin:center;
  will-change:transform;
}
.right-deck-shuffle-card.back{
  transform: translate(var(--shuffle-offset-x), var(--shuffle-offset-y)) rotate(var(--shuffle-tilt-base));
  z-index:1;
}
.right-deck-shuffle-card.front{
  transform: translate(0,0) rotate(var(--shuffle-tilt-base));
  z-index:2;
}
.right-deck-shuffle-card.movingOut{
  transition: transform var(--shuffle-dur-out) ease-in-out;
  transform: translate(var(--shuffle-out-x), 0) rotate(calc(var(--shuffle-tilt-base) + var(--shuffle-tilt-more)));
}
.right-deck-shuffle-card.movingIn{
  transition: transform var(--shuffle-dur-in) ease-in-out;
  transform: translate(var(--shuffle-offset-x), var(--shuffle-offset-y)) rotate(var(--shuffle-tilt-base));
}

/* ★ 中央の人数分丸チップ */
.round-chip-row{
  position:absolute;
  left:50%;
  top:calc(50% - 75px);
  transform:translateX(-50%);
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:4px;
  pointer-events:none;
  z-index:256;
}
.round-chip-row-inner{ display:flex; gap:4px; }
.round-chip{
  width:24px;
  height:24px;
  border-radius:50%;
  border:none;
  box-shadow:0 3px 6px rgba(0,0,0,.35);
  overflow:hidden;
  background-color:#0b1928;
}
.round-chip.back{
  background:url('failtip.jpg') center no-repeat;
  background-size:135%;
  filter:contrast(1.25) saturate(1.25);
}
.round-chip.front{
  background:url('successtip.jpg') center no-repeat;
  background-size:135%;
  filter:contrast(1.3) saturate(1.3) brightness(1.05);
}

/* ▼ 自分の手札の左に出す「縮小版 正体カード」 */
.my-role-mini-card{
  width:40px;
  height:60px;
  border-radius:3px;
  border:1px solid #000;
  box-shadow:0 3px 8px rgba(0,0,0,.2);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
  margin-right:4px;
}

/* ▼ 他プレイヤーの mini-hand 用の正体カード */
.player-tag .mini-role-card{
  width:28px;
  height:42px;
  border-color:#000;
}

/* ★ 1（boomcard）の拡大＆揺れアニメ用オーバーレイ */
.boom-one-overlay{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%) scale(0);
  width:180px;
  height:270px;
  background-image:url('boomcard.jpg');
  background-position:center;
  background-repeat:no-repeat;
  background-size:contain;
  z-index:270;
  pointer-events:none;
  opacity:0;
}
.boom-one-overlay.show{ animation: boomOnePop 3s cubic-bezier(.22,.84,.44,1) forwards; }
@keyframes boomOnePop{
  0%{ transform:translate(-50%,-50%) scale(0); opacity:0; }
  20%{ transform:translate(-50%,-50%) scale(1.2) rotate(-8deg); opacity:1; }
  40%{ transform:translate(-50%,-50%) scale(1.0) rotate(6deg); }
  60%{ transform:translate(-50%,-50%) scale(1.05) rotate(-4deg); }
  80%{ transform:translate(-50%,-50%) scale(1.0) rotate(3deg); }
  100%{ transform:translate(-50%,-50%) scale(1.0) rotate(0deg); opacity:0; }
}

/* ★ 丸チップが全部表になったときの「キラッ」アニメ用 大きい丸チップ */
.big-round-chip-overlay{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%) scale(0.7);
  width:190px;
  height:190px;
  border-radius:50%;
  background:
    radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), rgba(255,255,255,0) 55%),
    url('successtip.jpg') center no-repeat;
  background-size:120%, 85%;
  box-shadow:0 0 0 rgba(0,0,0,0);
  opacity:0;
  z-index:280;
  pointer-events:none;
  filter:contrast(1.15) saturate(1.25);
}
.big-round-chip-overlay.show{ animation: bigRoundChipFlash 3.4s cubic-bezier(.22,.84,.44,1) forwards; }
@keyframes bigRoundChipFlash{
  0%{ transform:translate(-50%,-50%) scale(0.7); opacity:0; box-shadow:0 0 0 rgba(0,0,0,0); filter:contrast(1.1) saturate(1.2) brightness(0.9); }
  25%{ transform:translate(-50%,-52%) scale(1.15); opacity:1; box-shadow:0 14px 40px rgba(0,0,0,.45); filter:contrast(1.2) saturate(1.25) brightness(1.2); }
  40%{ transform:translate(-50%,-52%) scale(1.22); box-shadow:0 18px 70px rgba(255,255,255,.85); filter:contrast(1.3) saturate(1.3) brightness(1.65); }
  70%{ transform:translate(-50%,-50%) scale(1.05); box-shadow:0 10px 26px rgba(0,0,0,.4); filter:contrast(1.18) saturate(1.2) brightness(1.1); }
  100%{ transform:translate(-50%,-50%) scale(1.0); opacity:0; box-shadow:0 0 0 rgba(0,0,0,0); filter:contrast(1.0) saturate(1.0) brightness(1.0); }
}
.big-round-chip-overlay::after{
  content:'';
  position:absolute;
  inset:-40%;
  background:linear-gradient(
    120deg,
    rgba(255,255,255,0) 0%,
    rgba(255,255,255,0) 40%,
    rgba(255,255,255,.9) 50%,
    rgba(255,255,255,0) 60%,
    rgba(255,255,255,0) 100%
  );
  transform:translateX(-120%) rotate(8deg);
  opacity:0;
  pointer-events:none;
}
.big-round-chip-overlay.show::after{ animation: chipSparkle 0.9s ease-out 0.15s forwards; }
@keyframes chipSparkle{
  0%{ transform:translateX(-120%) rotate(8deg); opacity:0; }
  25%{ opacity:1; }
  60%{ transform:translateX(120%) rotate(8deg); opacity:1; }
  100%{ opacity:0; }
}

/* 他プレイヤーの裏カード：大小パルス */
@keyframes miniPulse{
  0%,100%{ transform:translateY(var(--ty,0px)) scale(1); }
  50%{ transform:translateY(var(--ty,0px)) scale(1.18); }
}
.player-tag .mini-card.pulse{ animation: miniPulse .9s ease-in-out infinite; }
body.pulse-stop .player-tag .mini-card.pulse{ animation:none; }

/* ニッパーが接触しているカード：薄枠ヒント */
.player-tag .mini-card.hint{
  border-color:rgba(209,213,219,.95);
  box-shadow:0 0 0 2px rgba(209,213,219,.7), 0 2px 6px rgba(0,0,0,.15);
}

/* ドラッグ用ニッパー（カード左） */
.nipper-drag{
  width:26px;
  height:26px;
  position:absolute;
  left:-16px;
  top:50%;
  transform:translate(-50%,-50%);
  background-image:url('nipper.png');
  background-position:center;
  background-repeat:no-repeat;
  background-size:90%;
  border:none;
  border-radius:0;
  box-shadow:none;
  cursor:grab;
  touch-action:none;
  user-select:none;
  pointer-events:auto;
}
.nipper-drag.dragging{
  cursor:grabbing;
  filter:drop-shadow(0 8px 18px rgba(0,0,0,.35));
}
</style>
</head>
<body>

<header>
  <h1>タイムボム</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<main>
<div class="join-box" id="joinBox">
  <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
  <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
  <button class="btn primary" id="btnJoin">入室</button>
</div>

<div id="lobby" class="hidden">
  <h2>ロビー</h2>
  <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
  <p>ここにテーブルや情報が表示されます。</p>

  <div id="playerCircle" class="player-circle"></div>

  <!-- ★ 中央に2デッキ分の基準位置（左＝表、右＝裏） -->
  <div id="centerDecks" class="center-decks">
    <div id="deckSlotLeft" class="deck-slot">
      <div id="deckRow" class="action-deck"></div>
    </div>
    <div id="deckSlotRight" class="deck-slot right">
      <div id="deckRowRight" class="action-deck"></div>
    </div>
  </div>

  <div id="roundChipRow" class="round-chip-row"></div>

  <div class="my-hand-wrapper">
    <div class="my-hand-title">自分のカード</div>
    <div id="myHand" class="my-hand"></div>
    <div id="myRoleArea" class="my-role-area hidden"></div>
  </div>

</div>
</main>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ゲームスタート</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    準備ができたら「スタート」を押してください。<br>
    押すと全プレイヤーに正体カードとSカードが配られ、カードが5枚ずつ配られます。
  </div>
  <div class="start-pop-actions">
    <button id="btnTableReset" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="roundBanner" class="round-banner">1ラウンド</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* =========================
   ★ 安全なUUID（httpsでなくても落ちない）
   ========================= */
function newUUID(){
  try{
    if (crypto?.randomUUID) return crypto.randomUUID();
  }catch{}
  return 'id-' + Math.random().toString(16).slice(2) + '-' + Date.now().toString(16);
}

// ▼ Firebase 設定
const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

// ★ userId をタブ単位で固定（タブごとに別ID）
const savedUserId = sessionStorage.getItem('bbUserId') || newUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  roles: {},
  sOwner: null,
  round: 0,

  // ★ 中央山札（表向き）…左スロットに描画
  centerDeckCards: [],
  centerStackLevel: 0,

  // ★ 右側山札（裏向き）…2回目シャッフル用（アニメ中のみ）
  rightDeckCount: 0,

  fullOpenMode: false,
  roundChipsFrontCount: 0,

  // ★ アニメ同期用（roomごとに sessionStorage で管理）
  lastAnimEventId: null,
  joinedAt: 0
};

// ★ アニメーション中の二重実行防止
let isCollectAnimating = false;
let handsDirtyWhileAnimating = false;
let lastAllChipsFront = false;
let roundCollectTimerId = null;
let stopRoundCollectForSuccess = false;
let stopRoundCollectForBoom = false;
let cachedPlayerCenters = new Map();
let cachedMyHandCenter = null;

// ★ 追加：アニメイベント取りこぼし防止（FIFOキュー）
let pendingAnimEvents = [];

// ★ allToCenter の「手札更新が来ない」保険タイマー
let recoverVisibilityTimer = null;

// ★ 追加：配り中（2回目シャッフルの「束→順番配布」）
let isDealing = false;
let dealtPids = new Set();
let dealingSafetyTimer = null;

const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const myRoleArea = document.getElementById('myRoleArea');

const deckRow = document.getElementById('deckRow');
const deckRowRight = document.getElementById('deckRowRight');
const roundChipRow = document.getElementById('roundChipRow');

const kickDialog = document.getElementById('kickDialog');
const kickDialogBox = document.getElementById('kickDialogBox');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnTableReset = document.getElementById('btnTableReset');

const roundBanner = document.getElementById('roundBanner');

let pendingSeatIndexToSteal = null;
let pendingPlayerNameToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

/* =========================
   ★ 小ユーティリティ
   ========================= */
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

function cssMsFrom(el, name, fallback = 0){
  if (!el) return fallback;
  const v = getComputedStyle(el).getPropertyValue(name).trim();
  if (!v) return fallback;
  if (v.endsWith('ms')) {
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : fallback;
  }
  if (v.endsWith('s')) {
    const n = parseFloat(v);
    return Number.isFinite(n) ? n * 1000 : fallback;
  }
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : fallback;
}

async function waitUntil(fn, timeoutMs = 900){
  const start = performance.now();
  return new Promise(resolve => {
    const tick = () => {
      if (fn()) return resolve(true);
      if (performance.now() - start >= timeoutMs) return resolve(false);
      requestAnimationFrame(tick);
    };
    tick();
  });
}

// ★ seed付き乱数（deal束のズレを全員一致させる用）
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= (h >>> 16);
    return h >>> 0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function makeSeededRng(seedStr){
  const seed = xmur3(seedStr || 'seed')();
  return mulberry32(seed);
}

function queueAnimEvent(ev){
  pendingAnimEvents.push(ev);
}
function tryPlayPendingAnimEvent(){
  if (isCollectAnimating) return;
  while (pendingAnimEvents.length){
    const ev = pendingAnimEvents.shift();
    if (!ev) continue;
    if (ev.phase === 'openToDeck') { playAnimOpenToDeck(ev); return; }
    if (ev.phase === 'allToRightDeck') { playAnimAllToRightDeck(ev); return; }
    if (ev.phase === 'rightDeckShuffle') { playAnimRightDeckShuffle(ev); return; }
    if (ev.phase === 'dealBundles') { playAnimDealBundles(ev); return; }
  }
}

/* =========================
   ★ 山札UI（参考実装）
   ========================= */
function updateDeckStackUI(deckEl, count){
  if(!deckEl) return;
  const stackN =
    count >= 10 ? 5 :
    count >= 8  ? 4 :
    count >= 5  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = deckEl.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

function ensureDeckBuilt(deckEl){
  if (!deckEl) return;
  if (deckEl.dataset.built === '1') return;

  deckEl.innerHTML = '';
  for (let i=1;i<=5;i++){
    const c = document.createElement('div');
    c.className = `card c${i}`;
    deckEl.appendChild(c);
  }
  const cnt = document.createElement('div');
  cnt.className = 'count';
  deckEl.appendChild(cnt);

  deckEl.dataset.built = '1';
}

function updateLeftDeckUI(){
  if (!deckRow) return;
  ensureDeckBuilt(deckRow);

  const deck = Array.isArray(state.centerDeckCards) ? state.centerDeckCards : [];
  const count = deck.length;

  if (count <= 0){
    deckRow.style.display = 'none';
    return;
  }
  deckRow.style.display = 'block';

  const cntEl = deckRow.querySelector('.count');
  if (cntEl){
    cntEl.textContent = String(count);
    cntEl.style.display = 'block';
  }

  updateDeckStackUI(deckRow, count);

  const stackN =
    count >= 10 ? 5 :
    count >= 8  ? 4 :
    count >= 5  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  for (let i=1;i<=5;i++){
    const el = deckRow.querySelector(`.card.c${i}`);
    if (!el) continue;

    if (i > stackN){
      el.style.backgroundImage = '';
      el.dataset.cardValue = '';
      continue;
    }

    const srcIndex = Math.max(0, count - stackN + (i - 1));
    const v = deck[srcIndex];
    setCardFrontImage(el, v);
  }
}

function updateRightDeckUI(count){
  if (!deckRowRight) return;
  ensureDeckBuilt(deckRowRight);

  const c = Math.max(0, Number(count) || 0);
  state.rightDeckCount = c;

  if (c <= 0){
    deckRowRight.style.display = 'none';
    return;
  }
  deckRowRight.style.display = 'block';

  const cntEl = deckRowRight.querySelector('.count');
  if (cntEl){
    cntEl.textContent = String(c);
    cntEl.style.display = 'block';
  }

  updateDeckStackUI(deckRowRight, c);

  const stackN =
    c >= 10 ? 5 :
    c >= 8  ? 4 :
    c >= 5  ? 3 :
    c >= 2  ? 2 :
    c >= 1  ? 1 : 0;

  for (let i=1;i<=5;i++){
    const el = deckRowRight.querySelector(`.card.c${i}`);
    if (!el) continue;

    if (i > stackN){
      el.style.backgroundImage = '';
      el.dataset.cardValue = '';
      continue;
    }
    setCardBackImage(el);
  }
}

/* ★ 山札の「重なる位置」を取る（左スロット） */
function getDeckTargetCenterLeft(){
  ensureDeckBuilt(deckRow);
  const slot = document.getElementById('deckSlotLeft') || deckRow?.parentElement || deckRow;
  if (!slot) return { cx: window.innerWidth/2, cy: window.innerHeight/2 };

  const prevDisplay = slot.style.display;
  const prevVis = slot.style.visibility;

  if (getComputedStyle(slot).display === 'none') slot.style.display = 'block';
  slot.style.visibility = 'hidden';

  const r = slot.getBoundingClientRect();

  slot.style.visibility = prevVis || '';
  slot.style.display = prevDisplay || '';

  return { cx: r.left + r.width/2, cy: r.top + r.height/2 };
}

/* ★ 右スロット中心（2回目シャッフルの回収先＆配る元） */
function getDeckTargetCenterRight(){
  ensureDeckBuilt(deckRowRight);
  const slot = document.getElementById('deckSlotRight') || deckRowRight?.parentElement || deckRowRight;
  if (!slot) return { cx: window.innerWidth/2, cy: window.innerHeight/2 };

  const prevDisplay = slot.style.display;
  const prevVis = slot.style.visibility;

  if (getComputedStyle(slot).display === 'none') slot.style.display = 'block';
  slot.style.visibility = 'hidden';

  const r = slot.getBoundingClientRect();

  slot.style.visibility = prevVis || '';
  slot.style.display = prevDisplay || '';

  return { cx: r.left + r.width/2, cy: r.top + r.height/2 };
}

/* =========================
   ★ 追加：値の保持（即時山札反映に必要）
   ========================= */
function parseValueFromBgImage(el){
  const bg = (el && el.style && el.style.backgroundImage) ? el.style.backgroundImage : '';
  if (bg.includes('boomcard.jpg')) return 1;
  if (bg.includes('successcard.jpg')) return 2;
  if (bg.includes('shiin.jpg')) return 3;
  return null;
}
function getCardValueFromElement(el){
  const v = Number(el?.dataset?.cardValue);
  if (Number.isFinite(v) && v > 0) return v;
  const f = parseValueFromBgImage(el);
  return (typeof f === 'number') ? f : null;
}

/* =========================
   ★ 追加：ニッパー（手番）ドラッグ制御
   ========================= */
const nipperDrag = {
  el: null,
  pointerId: null,
  offsetX: 0,
  offsetY: 0,
  originParent: null,
  originNext: null,
  placeholderEl: null,
  targetEl: null,
  targetOwner: null,
  targetIndex: null
};

function isMyTurn(){
  if (state.fullOpenMode) return false;
  if (isCollectAnimating) return false;
  return (state.sOwner && state.sOwner === state.userId);
}

function clearMiniCardHints(){
  document.querySelectorAll('.mini-card.hint').forEach(el => el.classList.remove('hint'));
}

function cancelActiveNipperDrag(){
  if (!nipperDrag.el) {
    if (nipperDrag.placeholderEl && nipperDrag.placeholderEl.isConnected){
      nipperDrag.placeholderEl.remove();
    }
    nipperDrag.placeholderEl = null;
    return;
  }

  document.body.classList.remove('pulse-stop');
  clearMiniCardHints();

  const el = nipperDrag.el;
  el.classList.remove('dragging');
  el.style.position = '';
  el.style.left = '';
  el.style.top = '';
  el.style.transform = '';
  el.style.zIndex = '';

  if (nipperDrag.placeholderEl && nipperDrag.placeholderEl.isConnected){
    nipperDrag.placeholderEl.parentNode.insertBefore(el, nipperDrag.placeholderEl);
    nipperDrag.placeholderEl.remove();
  } else if (nipperDrag.originParent && nipperDrag.originParent.isConnected){
    if (nipperDrag.originNext && nipperDrag.originNext.isConnected){
      nipperDrag.originParent.insertBefore(el, nipperDrag.originNext);
    } else {
      nipperDrag.originParent.appendChild(el);
    }
  } else {
    el.remove();
  }

  nipperDrag.el = null;
  nipperDrag.pointerId = null;
  nipperDrag.originParent = null;
  nipperDrag.originNext = null;
  nipperDrag.placeholderEl = null;
  nipperDrag.targetEl = null;
  nipperDrag.targetOwner = null;
  nipperDrag.targetIndex = null;
}

function findCardAtPoint(x, y){
  const cards = document.querySelectorAll('.mini-card.is-back.pulse');
  for (const c of cards){
    const r = c.getBoundingClientRect();
    if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom){
      return c;
    }
  }
  return null;
}

function updateNipperHover(){
  if (!nipperDrag.el) return;
  const r = nipperDrag.el.getBoundingClientRect();

  const tipX = r.right - r.width * 0.15;
  const tipY = r.top   + r.height * 0.20;

  const card = findCardAtPoint(tipX, tipY);

  if (card){
    document.body.classList.add('pulse-stop');
    if (nipperDrag.targetEl !== card){
      clearMiniCardHints();
      card.classList.add('hint');
      nipperDrag.targetEl = card;
      nipperDrag.targetOwner = card.dataset.ownerId || null;
      nipperDrag.targetIndex = Number(card.dataset.cardIndex);
    }
  } else {
    document.body.classList.remove('pulse-stop');
    if (nipperDrag.targetEl){
      clearMiniCardHints();
      nipperDrag.targetEl = null;
      nipperDrag.targetOwner = null;
      nipperDrag.targetIndex = null;
    }
  }
}

function onNipperDragMove(e){
  if (!nipperDrag.el) return;
  if (e.pointerId !== nipperDrag.pointerId) return;
  e.preventDefault();

  const x = e.clientX - nipperDrag.offsetX;
  const y = e.clientY - nipperDrag.offsetY;

  nipperDrag.el.style.left = x + 'px';
  nipperDrag.el.style.top  = y + 'px';

  updateNipperHover();
}

async function onNipperDragEnd(e){
  if (!nipperDrag.el) return;
  if (e.pointerId !== nipperDrag.pointerId) return;
  e.preventDefault();

  const el = nipperDrag.el;

  try { el.releasePointerCapture(e.pointerId); } catch {}
  el.removeEventListener('pointermove', onNipperDragMove);
  el.removeEventListener('pointerup', onNipperDragEnd);
  el.removeEventListener('pointercancel', onNipperDragEnd);

  document.body.classList.remove('pulse-stop');
  clearMiniCardHints();

  const ownerId = nipperDrag.targetOwner;
  const idx = nipperDrag.targetIndex;

  cancelActiveNipperDrag();

  if (ownerId && Number.isFinite(idx) && isMyTurn()){
    await onMiniCardClick(ownerId, idx);
  }
}

function onNipperDragStart(e){
  if (!isMyTurn()) return;
  if (nipperDrag.el) return;
  e.preventDefault();
  e.stopPropagation();

  const el = e.currentTarget;
  const rect = el.getBoundingClientRect();

  nipperDrag.el = el;
  nipperDrag.pointerId = e.pointerId;
  nipperDrag.offsetX = e.clientX - rect.left;
  nipperDrag.offsetY = e.clientY - rect.top;
  nipperDrag.originParent = el.parentNode;
  nipperDrag.originNext = el.nextSibling;
  nipperDrag.targetEl = null;
  nipperDrag.targetOwner = null;
  nipperDrag.targetIndex = null;

  if (nipperDrag.originParent && nipperDrag.originParent.isConnected){
    const ph = document.createElement('div');
    ph.className = 'my-s-card placeholder';
    nipperDrag.placeholderEl = ph;

    if (nipperDrag.originNext && nipperDrag.originNext.isConnected){
      nipperDrag.originParent.insertBefore(ph, nipperDrag.originNext);
    } else {
      nipperDrag.originParent.appendChild(ph);
    }
  }

  el.classList.add('dragging');

  el.style.position = 'fixed';
  el.style.left = rect.left + 'px';
  el.style.top  = rect.top  + 'px';
  el.style.transform = 'none';
  el.style.zIndex = '9999';
  document.body.appendChild(el);

  el.setPointerCapture(e.pointerId);
  el.addEventListener('pointermove', onNipperDragMove, { passive:false });
  el.addEventListener('pointerup', onNipperDragEnd, { passive:false });
  el.addEventListener('pointercancel', onNipperDragEnd, { passive:false });

  updateNipperHover();
}

/* =========================
   既存ロジック
   ========================= */
function renderRoundChips(playerCount, faceUpCount){
  if (!roundChipRow) return;

  roundChipRow.innerHTML = '';

  if (!playerCount || playerCount <= 0){
    roundChipRow.style.display = 'none';
    return;
  }
  roundChipRow.style.display = 'flex';

  let frontLeft = Math.max(0, Math.min(faceUpCount || 0, playerCount));
  let remaining = playerCount;

  const rows = [];
  if (playerCount <= 5){
    rows.push(playerCount);
  } else if (playerCount === 6){
    rows.push(3,3);
  } else if (playerCount === 7){
    rows.push(4,3);
  } else if (playerCount === 8){
    rows.push(4,4);
  } else {
    rows.push(playerCount);
  }

  rows.forEach(size => {
    const rowSize = Math.min(size, remaining);
    if (rowSize <= 0) return;

    const rowEl = document.createElement('div');
    rowEl.className = 'round-chip-row-inner';

    for(let i=0;i<rowSize;i++){
      const chip = document.createElement('div');
      const isFront = (frontLeft > 0);
      chip.className = 'round-chip ' + (isFront ? 'front' : 'back');
      chip.textContent = '';

      if (isFront) frontLeft--;
      remaining--;

      rowEl.appendChild(chip);
    }
    roundChipRow.appendChild(rowEl);
  });
}

function updateRoundChips(){
  if (!roundChipRow) return;

  const playerCount = latestPlayers.length || 0;
  if (!playerCount){
    roundChipRow.innerHTML = '';
    roundChipRow.style.display = 'none';
    lastAllChipsFront = false;
    return;
  }

  const frontCount = state.roundChipsFrontCount || 0;
  renderRoundChips(playerCount, frontCount);

  const isAllFront = (frontCount >= playerCount && playerCount > 0);

  if (isAllFront && !lastAllChipsFront){
    stopRoundCollectForSuccess = true;

    if (roundCollectTimerId){
      clearTimeout(roundCollectTimerId);
      roundCollectTimerId = null;
    }

    setTimeout(() => {
      showBigRoundChipAnimation();
    }, 1000);
  }

  lastAllChipsFront = isAllFront;
}

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }

  if (mySeatIndex !== null) {
    state.seatedTable = mySeatIndex;
  }
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = `ルーム: ${state.roomCode}, 名前: ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}

function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
}

function showRoundBanner(text){
  if(!roundBanner) return;
  roundBanner.textContent = text;
  roundBanner.classList.remove('show');
  void roundBanner.offsetWidth;
  roundBanner.classList.add('show');
}
if (roundBanner){
  roundBanner.addEventListener('animationend', () => {
    roundBanner.classList.remove('show');
  });
}

function showBigRoundChipAnimation(){
  let el = document.getElementById('bigRoundChipOverlay');
  if (!el){
    el = document.createElement('div');
    el.id = 'bigRoundChipOverlay';
    el.className = 'big-round-chip-overlay';
    document.body.appendChild(el);
    el.addEventListener('animationend', () => {
      el.classList.remove('show');
    });
  }

  el.classList.remove('show');
  void el.offsetWidth;
  el.classList.add('show');

  if (state.isHost && state.roomCode){
    setTimeout(() => {
      if (state.fullOpenMode) return;
      update(ref(db, `rooms/${state.roomCode}`), { fullOpenMode: true });
    }, 2000);
  }
}

function showBoomOneAnimation(){
  let el = document.getElementById('boomOneOverlay');
  if (!el){
    el = document.createElement('div');
    el.id = 'boomOneOverlay';
    el.className = 'boom-one-overlay';
    document.body.appendChild(el);
    el.addEventListener('animationend', () => {
      el.classList.remove('show');
    });
  }
  el.classList.remove('show');
  void el.offsetWidth;
  el.classList.add('show');
}

function subscribeHostState(){
  if (!state.roomCode) return;
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
  });
}

function subscribeRound(){
  if (!state.roomCode) return;
  const roundRef = ref(db, `rooms/${state.roomCode}/round`);
  onValue(roundRef, snap => {
    const v = snap.val();
    const newRound = (typeof v === 'number') ? v : 0;

    if (newRound !== state.round){
      isCollectAnimating = false;
      handsDirtyWhileAnimating = false;
      pendingAnimEvents = [];
      isDealing = false;
      dealtPids = new Set();
      if (dealingSafetyTimer) clearTimeout(dealingSafetyTimer);
      dealingSafetyTimer = null;

      document.querySelectorAll('.collected').forEach(el => {
        el.classList.remove('collected');
        el.style.visibility = '';
        el.style.opacity = '';
      });
      const oldLayer = document.getElementById('roundCollectLayer');
      if (oldLayer && oldLayer.parentNode) oldLayer.parentNode.removeChild(oldLayer);

      // 右デッキ表示も念のため消す
      updateRightDeckUI(0);
    }

    state.round = newRound;
    if (state.round > 0){
      showRoundBanner(`${state.round}ラウンド`);
    }
  });
}

function detectAndActivateFullOpenMode(hands){
  if (state.fullOpenMode) return;

  let hasOpenOne = false;

  Object.values(hands || {}).forEach(hand => {
    if (hasOpenOne) return;
    if (!hand || !Array.isArray(hand.cards)) return;

    const cards = hand.cards;
    const openArr = hand.open || [];

    for (let i = 0; i < cards.length; i++){
      if (openArr[i] && cards[i] === 1){
        hasOpenOne = true;
        break;
      }
    }
  });

  if (!hasOpenOne) return;

  stopRoundCollectForBoom = true;

  if (roundCollectTimerId){
    clearTimeout(roundCollectTimerId);
    roundCollectTimerId = null;
  }
  isCollectAnimating = false;
  handsDirtyWhileAnimating = false;
  pendingAnimEvents = [];

  showBoomOneAnimation();

  if (state.isHost && state.roomCode){
    setTimeout(() => {
      if (state.fullOpenMode) return;
      update(ref(db, `rooms/${state.roomCode}`), { fullOpenMode: true });
    }, 500);
  }
}

function subscribeHands(){
  if (!state.roomCode) return;
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    const newHands = snap.val() || {};
    state.hands = newHands;

    detectAndActivateFullOpenMode(newHands);

    if (isCollectAnimating) {
      handsDirtyWhileAnimating = true;
    } else {
      renderHands();
    }
    updateCachedCenters();
    checkOpenCardsAndCollect();
    updateRoundChips();

    // ★ DOM更新後に保留イベントを再生
    tryPlayPendingAnimEvent();
  });
}

function subscribeFullOpenMode(){
  if (!state.roomCode) return;
  const fullRef = ref(db, `rooms/${state.roomCode}/fullOpenMode`);
  onValue(fullRef, snap => {
    state.fullOpenMode = !!snap.val();
    renderHands();
  });
}

function subscribeRoundChipsCounter(){
  if (!state.roomCode) return;
  const cntRef = ref(db, `rooms/${state.roomCode}/roundChipsFrontCount`);
  onValue(cntRef, snap => {
    const v = snap.val();
    state.roundChipsFrontCount = (typeof v === 'number') ? v : 0;

    if (state.roundChipsFrontCount === 0){
      stopRoundCollectForSuccess = false;
      lastAllChipsFront = false;
    }
    updateRoundChips();
  });
}

function setCardFrontImage(el, value){
  let img = '';
  const v = Number(value);
  if (v === 1) img = 'boomcard.jpg';
  else if (v === 2) img = 'successcard.jpg';
  else if (v === 3) img = 'shiin.jpg';

  if (el) el.dataset.cardValue = Number.isFinite(v) ? String(v) : '';

  if (img){
    el.style.backgroundImage = `url('${img}')`;
    el.style.backgroundSize = 'cover';
    el.style.backgroundPosition = 'center';
    el.style.backgroundRepeat = 'no-repeat';
  } else {
    el.style.backgroundImage = '';
  }
  el.textContent = '';
}

function setCardBackImage(el){
  el.style.backgroundImage = `url('green.jpg')`;
  el.style.backgroundSize = 'cover';
  el.style.backgroundPosition = 'center';
  el.style.backgroundRepeat = 'no-repeat';
  el.textContent = '';
  if (el) el.dataset.cardValue = '';
}

function renderMyHand(){
  myHandEl.innerHTML = '';
  const myId = state.userId;
  const handData = state.hands[myId];
  if (!handData || !Array.isArray(handData.cards)) return;

  const cards = handData.cards;
  const openArr = (handData.open && handData.open.slice()) || new Array(cards.length).fill(false);

  cards.forEach((val, idx) => {
    const card = document.createElement('div');
    card.className = 'my-card';
    setCardFrontImage(card, val);

    if (openArr[idx]) card.classList.add('is-open');
    else card.classList.add('is-closed');

    if (isDealing && !dealtPids.has(myId)){
      card.style.visibility = 'hidden';
    }

    myHandEl.appendChild(card);
  });
}

function renderMyRoleArea(){
  if (!myRoleArea) return;
  myRoleArea.innerHTML = '';

  const myId = state.userId;
  const roleInfo = state.roles[myId];

  if (!roleInfo || !roleInfo.role) {
    myRoleArea.classList.add('hidden');
    return;
  }
  myRoleArea.classList.remove('hidden');

  if (state.sOwner === myId){
    const sCard = document.createElement('div');
    sCard.className = 'my-s-card';
    sCard.title = 'ドラッグしてカードに重ねる';

    sCard.addEventListener('pointerdown', onNipperDragStart, { passive:false });
    sCard.addEventListener('click', (ev)=>{ ev.stopPropagation(); }, { passive:true });

    myRoleArea.appendChild(sCard);
  }

  const roleCard = document.createElement('div');
  let cls = 'my-role-card';

  if (roleInfo.role === 'O') cls += ' good';
  else if (roleInfo.role === 'X') cls += ' bad';
  else roleCard.textContent = '?';

  roleCard.className = cls;
  myRoleArea.appendChild(roleCard);
}

function renderHands(){
  // ★ 念のため残骸掃除
  document.querySelectorAll('.collected').forEach(el => {
    el.classList.remove('collected');
    el.style.visibility = '';
    el.style.opacity = '';
  });

  renderMyHand();
  if (latestPlayers.length){
    renderPlayerCircle(latestPlayers);
  }
  updateCachedCenters();
}

/* =========================================================
   ★ アニメ同期：DBイベントを発火（ホストのみ）
   ========================================================= */
function collectOpenedCardsFromHandsSnapshot(hands){
  const collected = [];
  const sources = [];
  Object.entries(hands || {}).forEach(([ownerId, hand]) => {
    if (!hand || !Array.isArray(hand.cards)) return;
    const cards = hand.cards || [];
    const openArr = hand.open || [];
    for (let i=0;i<cards.length;i++){
      if (openArr[i]) {
        const v = Number(cards[i]);
        collected.push(v);
        sources.push({ ownerId, cardIndex: i, value: v });
      }
    }
  });
  return { collected, sources };
}

async function hostEmitAnimEvent(phase, extra = {}){
  if (!state.isHost || !state.roomCode) return;
  const id = newUUID();
  const ev = {
    id,
    phase,
    round: state.round || 0,
    createdAt: Date.now(),
    ...extra
  };
  await update(ref(db, `rooms/${state.roomCode}`), { animEvent: ev });
}

/* ★ ここが重要：リロード直後に「古い animEvent」を再生しない＋room別にlastを保持 */
function subscribeAnimEvent(){
  if (!state.roomCode) return;
  const animRef = ref(db, `rooms/${state.roomCode}/animEvent`);
  const lastKey = `tbLastAnimEventId_${state.roomCode}`;

  onValue(animRef, snap => {
    const ev = snap.val();
    if (!ev || !ev.id || !ev.phase) return;

    // ★ join前に作られたイベントは無視
    if (state.joinedAt && ev.createdAt && ev.createdAt < (state.joinedAt - 800)) {
      return;
    }

    if (state.lastAnimEventId === ev.id) return;

    state.lastAnimEventId = ev.id;
    sessionStorage.setItem(lastKey, ev.id);

    if (isCollectAnimating){
      queueAnimEvent(ev);
      return;
    }

    if (ev.phase === 'openToDeck'){
      playAnimOpenToDeck(ev);
    } else if (ev.phase === 'allToRightDeck'){
      playAnimAllToRightDeck(ev);
    } else if (ev.phase === 'rightDeckShuffle'){
      playAnimRightDeckShuffle(ev);
    } else if (ev.phase === 'dealBundles'){
      playAnimDealBundles(ev);
    }
  });
}

/* =========================================================
   ★ 1回目（公開カード回収）判定
   ========================================================= */
function checkOpenCardsAndCollect(){
  if (isCollectAnimating) return;
  if (state.fullOpenMode) return;
  if (stopRoundCollectForBoom) return;

  const hands = state.hands || {};
  const playerIds = Object.keys(hands).filter(pid => {
    const h = hands[pid];
    return h && Array.isArray(h.cards) && h.cards.length > 0;
  });

  const playerCount = playerIds.length;
  if (!playerCount) return;

  // 成功条件（2が全員分）
  let openTwoCount = 0;
  playerIds.forEach(pid => {
    const hand = hands[pid];
    const cards   = hand.cards || [];
    const openArr = hand.open  || [];
    for (let i = 0; i < cards.length; i++){
      if (openArr[i] && Number(cards[i]) === 2){
        openTwoCount++;
      }
    }
  });
  if (openTwoCount >= playerCount){
    stopRoundCollectForSuccess = true;
    if (roundCollectTimerId){
      clearTimeout(roundCollectTimerId);
      roundCollectTimerId = null;
    }
    return;
  }

  // 公開数（「公開が人数分」になったら1回目回収へ）
  let openCount = 0;
  playerIds.forEach(pid => {
    const hand = hands[pid];
    const openArr = hand.open || [];
    openArr.forEach(f => { if (f) openCount++; });
  });

  if (openCount >= playerCount && playerCount > 0){
    if (!state.isHost) return;

    if (roundCollectTimerId){
      clearTimeout(roundCollectTimerId);
      roundCollectTimerId = null;
    }

    roundCollectTimerId = setTimeout(async () => {
      roundCollectTimerId = null;
      if (stopRoundCollectForSuccess) return;
      if (stopRoundCollectForBoom) return;
      if (state.fullOpenMode) return;
      if (isCollectAnimating) return;

      const baseDeck = Array.isArray(state.centerDeckCards) ? state.centerDeckCards.slice() : [];
      const { collected, sources } = collectOpenedCardsFromHandsSnapshot(state.hands);
      if (!collected.length) return;

      await hostEmitAnimEvent('openToDeck', {
        duration: 1100,
        baseDeck,
        collected,
        sources
      });

    }, 650);
  }
}

/* =========================================================
   ★ 1回目（公開カード回収）アニメ：DBイベントで全員同期
   ========================================================= */
function getFallbackStartCenter(ownerId){
  if (ownerId === state.userId){
    const r = myHandEl?.getBoundingClientRect();
    if (r && r.width && r.height){
      return { cx: r.left + r.width/2, cy: r.top + r.height/2 };
    }
    if (cachedMyHandCenter){
      return { cx: cachedMyHandCenter.cx, cy: cachedMyHandCenter.cy };
    }
    return { cx: window.innerWidth/2, cy: window.innerHeight*0.75 };
  }
  const tag = document.querySelector(`.player-tag[data-player-id="${ownerId}"]`);
  if (tag){
    const r = tag.getBoundingClientRect();
    return { cx: r.left + r.width/2, cy: r.top + r.height/2 };
  }
  const cached = cachedPlayerCenters.get(ownerId);
  if (cached){
    return { cx: cached.cx, cy: cached.cy };
  }
  return { cx: window.innerWidth/2, cy: window.innerHeight/2 };
}

function findSourceElement(ownerId, cardIndex){
  if (ownerId === state.userId){
    const el = myHandEl?.children?.[cardIndex];
    return el || null;
  }
  return document.querySelector(`.mini-card[data-owner-id="${ownerId}"][data-card-index="${cardIndex}"]`);
}

async function gatherOpenToDeckSources(ev){
  const sources = Array.isArray(ev.sources) ? ev.sources : [];
  if (!sources.length){
    const els = [...document.querySelectorAll('.my-card.is-open, .mini-card.is-open')];
    return els.map(el => {
      const r = el.getBoundingClientRect();
      return {
        el,
        value: getCardValueFromElement(el),
        fromCX: r.left + r.width/2,
        fromCY: r.top + r.height/2
      };
    }).filter(x => x.value);
  }

  await waitUntil(() => {
    return sources.some(s => !!findSourceElement(s.ownerId, s.cardIndex));
  }, 900);

  return sources.map(s => {
    const el = findSourceElement(s.ownerId, s.cardIndex);
    if (el){
      const r = el.getBoundingClientRect();
      return { el, value: Number(s.value), fromCX: r.left + r.width/2, fromCY: r.top + r.height/2 };
    }
    const fb = getFallbackStartCenter(s.ownerId);
    return { el: null, value: Number(s.value), fromCX: fb.cx, fromCY: fb.cy };
  }).filter(x => Number.isFinite(x.value) && x.value > 0);
}

async function playAnimOpenToDeck(ev){
  if (stopRoundCollectForSuccess) return;
  if (stopRoundCollectForBoom) return;
  if (state.fullOpenMode) return;

  if (isCollectAnimating){
    queueAnimEvent(ev);
    return;
  }

  const DURATION = Number(ev.duration) || 1100;
  const baseDeck = Array.isArray(ev.baseDeck) ? ev.baseDeck : (Array.isArray(state.centerDeckCards) ? state.centerDeckCards.slice() : []);
  const collectedFromEvent = Array.isArray(ev.collected) ? ev.collected.slice() : [];

  isCollectAnimating = true;
  handsDirtyWhileAnimating = false;

  renderHands();
  await waitUntil(() => {
    updateCachedCenters();
    return document.querySelectorAll('.my-card, .mini-card').length > 0
      || cachedMyHandCenter
      || cachedPlayerCenters.size > 0;
  }, 700);

  const oldLayer = document.getElementById('roundCollectLayer');
  if (oldLayer && oldLayer.parentNode){
    oldLayer.parentNode.removeChild(oldLayer);
  }

  const layer = document.createElement('div');
  layer.id = 'roundCollectLayer';
  layer.className = 'round-collect-layer';
  document.body.appendChild(layer);

  const { cx: targetCX, cy: targetCY } = getDeckTargetCenterLeft();

  const CLONE_W = 28;
  const CLONE_H = 42;

  const items = await gatherOpenToDeckSources(ev);

  const clones = [];
  items.forEach((it) => {
    const { el, value, fromCX, fromCY } = it;

    const clone = document.createElement('div');
    clone.className = 'round-collect-card';
    clone.style.position = 'fixed';
    clone.style.left = (fromCX - CLONE_W / 2) + 'px';
    clone.style.top  = (fromCY - CLONE_H / 2) + 'px';
    clone.style.width  = CLONE_W + 'px';
    clone.style.height = CLONE_H + 'px';
    clone.style.margin = '0';
    clone.style.transform = 'translate(0,0)';
    clone.style.opacity = '1';
    clone.style.transition = `transform ${DURATION}ms cubic-bezier(.18,.88,.28,1)`;
    clone.style.pointerEvents = 'none';

    setCardFrontImage(clone, value);

    layer.appendChild(clone);
    clones.push({ clone, fromCX, fromCY });

    if (el){
      el.classList.add('collected');
      el.style.visibility = 'hidden';
    }
  });

  requestAnimationFrame(() => {
    clones.forEach(({ clone, fromCX, fromCY }) => {
      const dx = targetCX - fromCX;
      const dy = targetCY - fromCY;
      clone.style.transform = `translate(${dx}px, ${dy}px)`;
    });
  });

  await sleep(DURATION);
  if (collectedFromEvent.length){
    const newDeckLocal = baseDeck.concat(collectedFromEvent);
    state.centerDeckCards = newDeckLocal;
    state.centerStackLevel = newDeckLocal.length;
    updateLeftDeckUI();
  }

  await sleep(40);

  const layerNow = document.getElementById('roundCollectLayer');
  if (layerNow && layerNow.parentNode) layerNow.parentNode.removeChild(layerNow);

  if (state.roomCode && state.isHost){
    const result = await finalizeOpenCardsOnlyToDB(baseDeck);

    // ★ 2回目シャッフル：裏向きで右デッキへ回収 → 束で順番配布（ここで一括スケジュール）
    setTimeout(() => {
      hostScheduleSecondShuffle(result.newHands || {});
    }, 180);
  }

  isCollectAnimating = false;

  if (handsDirtyWhileAnimating){
    handsDirtyWhileAnimating = false;
    renderHands();
  }

  tryPlayPendingAnimEvent();
}

async function finalizeOpenCardsOnlyToDB(prevDeckOverride){
  const hands = state.hands || {};
  const newHands = {};
  const collectedCards = [];

  Object.entries(hands).forEach(([pid, hand]) => {
    if (!hand || !Array.isArray(hand.cards)) {
      newHands[pid] = hand;
      return;
    }
    const cards   = hand.cards;
    const openArr = hand.open || [];

    const keptCards = [];
    const keptOpen  = [];

    for (let i = 0; i < cards.length; i++){
      if (!openArr[i]) {
        keptCards.push(cards[i]);
        keptOpen.push(false);
      } else {
        collectedCards.push(cards[i]);
      }
    }
    newHands[pid] = { cards: keptCards, open: keptOpen };
  });

  const baseDeck = Array.isArray(prevDeckOverride) ? prevDeckOverride : (Array.isArray(state.centerDeckCards) ? state.centerDeckCards : []);
  const newDeck = baseDeck.concat(collectedCards);
  const newLevel = newDeck.length;

  await update(ref(db), {
    [`rooms/${state.roomCode}/hands`]: newHands,
    [`rooms/${state.roomCode}/centerDeck`]: newDeck,
    [`rooms/${state.roomCode}/centerStackLevel`]: newLevel
  });

  return { newHands, newDeck, collectedCards };
}

/* =========================================================
   ★ 2回目（全回収→右デッキ→束で順番配布）ホスト側スケジュール
   ========================================================= */
async function hostScheduleSecondShuffle(handsAfterOpenRemoved){
  if (!state.isHost || !state.roomCode) return;
  if (state.fullOpenMode || stopRoundCollectForBoom) return;

  const roomBase = `rooms/${state.roomCode}`;

  // 着席順
  const tablesSnap = await get(ref(db, `${roomBase}/tables`));
  const tables = tablesSnap.val() || {};
  const seatedIds = Object.entries(tables)
    .map(([seat, t]) => (t && t.playerId ? { id: t.playerId, seat: Number(seat) } : null))
    .filter(Boolean)
    .sort((a,b) => a.seat - b.seat)
    .map(o => o.id);

  if (!seatedIds.length) return;

  // 残りカード（全員の手札をまとめる）
  const allCards = [];
  seatedIds.forEach(pid => {
    const h = handsAfterOpenRemoved?.[pid];
    const cs = (h && Array.isArray(h.cards)) ? h.cards.slice() : [];
    allCards.push(...cs);
  });

  // 0枚でも整合のためhandsを空で更新
  if (!allCards.length){
    const emptyHands = {};
    seatedIds.forEach(pid => emptyHands[pid] = { cards: [], open: [] });
    await update(ref(db), { [`${roomBase}/hands`]: emptyHands, [`${roomBase}/roundChipsFrontCount`]: 0, [`${roomBase}/fullOpenMode`]: false });
    const nextRound = (state.round || 0) + 1;
    await update(ref(db, `${roomBase}`), { round: nextRound, animEvent: null });
    return;
  }

  // 配布枚数（均等＋余りを前から）
  const playerCount = seatedIds.length;
  const baseCount = Math.floor(allCards.length / playerCount);
  let remainder = allCards.length % playerCount;

  const dealPlan = [];

  seatedIds.forEach(pid => {
    const take = baseCount + (remainder > 0 ? 1 : 0);
    if (remainder > 0) remainder--;

    dealPlan.push({ pid, count: take });
  });

  // ① 裏向き回収→右デッキ
  const COLLECT_DUR = 1050;
  const SHUFFLE_DUR = 1380;
  const SHUFFLE_CYCLES = 3;
  await hostEmitAnimEvent('allToRightDeck', {
    duration: COLLECT_DUR,
    deckCount: allCards.length,
    dealPlan
  });

  // ② 右デッキでシャッフル演出
  setTimeout(async () => {
    await hostEmitAnimEvent('rightDeckShuffle', {
      duration: SHUFFLE_DUR,
      deckCount: allCards.length,
      cycles: SHUFFLE_CYCLES
    });
  }, COLLECT_DUR + 120);

  // ③ handsを更新（配る前に“配布先の手札枚数”を確定させる）
  setTimeout(async () => {
    shuffleInPlace(allCards);

    const newHands = {};
    let idx = 0;

    dealPlan.forEach(p => {
      const take = Math.max(0, Number(p.count) || 0);
      const cards = allCards.slice(idx, idx + take);
      idx += take;
      newHands[p.pid] = { cards, open: new Array(cards.length).fill(false) };
    });

    await update(ref(db), {
      [`${roomBase}/hands`]: newHands,
      [`${roomBase}/roundChipsFrontCount`]: 0,
      [`${roomBase}/fullOpenMode`]: false
    });

    // ④ 束で順番配布（右デッキから）
    const DEAL_PER_PLAYER = 420;
    const DEAL_GAP = 150;

    await hostEmitAnimEvent('dealBundles', {
      durationPerPlayer: DEAL_PER_PLAYER,
      gap: DEAL_GAP,
      deckCount: allCards.length,
      dealPlan
    });

    // ⑤ 次ラウンドへ（配り終わりに round++）
    const totalDealMs = dealPlan.reduce((sum, p) => {
      const take = Math.max(0, Number(p.count) || 0);
      if (!take) return sum;
      return sum + DEAL_PER_PLAYER + DEAL_GAP;
    }, 0) + 220;

    setTimeout(async () => {
      const nextRound = (state.round || 0) + 1;
      await update(ref(db, `${roomBase}`), {
        round: nextRound,
        animEvent: null
      });
    }, totalDealMs);

  }, COLLECT_DUR + SHUFFLE_DUR + 260);
}

/* =========================================================
   ★ 2回目の右デッキシャッフル（小デッキ演出）
   ========================================================= */
async function playAnimRightDeckShuffle(ev){
  if (state.fullOpenMode || stopRoundCollectForBoom) {
    return;
  }
  if (isCollectAnimating){
    queueAnimEvent(ev);
    return;
  }

  const deckCount = Math.max(0, Number(ev.deckCount) || state.rightDeckCount || 0);
  if (deckCount <= 0) return;

  const cycles = Math.max(1, Number(ev.cycles) || 3);

  const oldLayer = document.getElementById('rightDeckShuffleLayer');
  if (oldLayer && oldLayer.parentNode){
    oldLayer.parentNode.removeChild(oldLayer);
  }

  isCollectAnimating = true;
  updateRightDeckUI(deckCount);

  const { cx, cy } = getDeckTargetCenterRight();

  const layer = document.createElement('div');
  layer.id = 'rightDeckShuffleLayer';
  layer.className = 'right-deck-shuffle';
  layer.style.left = `${cx}px`;
  layer.style.top = `${cy}px`;

  const back = document.createElement('div');
  back.className = 'right-deck-shuffle-card back';
  setCardBackImage(back);

  const front = document.createElement('div');
  front.className = 'right-deck-shuffle-card front';
  setCardBackImage(front);

  layer.appendChild(back);
  layer.appendChild(front);
  document.body.appendChild(layer);

  let frontEl = front;
  let backEl = back;

  const durOut = cssMsFrom(layer, '--shuffle-dur-out', 220);
  const durIn = cssMsFrom(layer, '--shuffle-dur-in', 220);
  const pause = cssMsFrom(layer, '--shuffle-pause', 20);

  const swapLayers = () => {
    frontEl.classList.remove('front');
    frontEl.classList.add('back');

    backEl.classList.remove('back');
    backEl.classList.add('front');

    const tmp = frontEl;
    frontEl = backEl;
    backEl = tmp;
  };

  for (let i = 0; i < cycles; i++){
    frontEl.classList.remove('movingIn');
    void frontEl.offsetWidth;
    frontEl.classList.add('movingOut');
    await sleep(durOut);

    frontEl.classList.remove('movingOut');
    swapLayers();

    backEl.classList.remove('movingOut');
    void backEl.offsetWidth;
    backEl.classList.add('movingIn');
    await sleep(durIn);

    backEl.classList.remove('movingIn');
    await sleep(pause);
  }

  if (layer && layer.parentNode){
    layer.parentNode.removeChild(layer);
  }

  isCollectAnimating = false;
  tryPlayPendingAnimEvent();
}

/* =========================================================
   ★ 2回目アニメ(1)：全回収→右デッキ（裏向きのまま）
   ★ 修正点：
   ★  - 右の回収デッキ（到着サイズ）を左と同じ 28x42 に統一
   ★  - 自分の大きい手札（60x90）は回収中に縮小してデッキサイズに揃える
   ========================================================= */
async function playAnimAllToRightDeck(ev){
  if (state.fullOpenMode || stopRoundCollectForBoom) {
    isCollectAnimating = false;
    handsDirtyWhileAnimating = false;
    return;
  }
  if (isCollectAnimating){
    queueAnimEvent(ev);
    return;
  }

  const DURATION = Number(ev.duration) || 1050;
  const deckCount = Math.max(0, Number(ev.deckCount) || 0);

  // layer掃除
  const oldLayer = document.getElementById('roundCollectLayer');
  if (oldLayer && oldLayer.parentNode){
    oldLayer.parentNode.removeChild(oldLayer);
  }

  isCollectAnimating = true;

  renderHands();
  await waitUntil(() => {
    return document.querySelectorAll('.my-card, .mini-card').length > 0
      || cachedMyHandCenter
      || cachedPlayerCenters.size > 0;
  }, 600);

  const layer = document.createElement('div');
  layer.id = 'roundCollectLayer';
  layer.className = 'round-collect-layer';
  document.body.appendChild(layer);

  // 右デッキを先に表示（サイズはCSSで28x42固定）
  updateRightDeckUI(deckCount);

  const { cx: targetCX, cy: targetCY } = getDeckTargetCenterRight();

  // 対象：今見えている手札カード（表/裏どっちでも“裏で回収”に統一）
  const src = [...document.querySelectorAll('.my-card, .mini-card')];
  const candidates = src
    .map(el => ({ el, rect: el.getBoundingClientRect() }))
    .filter(o => o.rect && o.rect.width && o.rect.height);

  // phantom（人数×枚数だけ裏カードを発生）
  const makePhantomFromCounts = () => {
    const plan = Array.isArray(ev.dealPlan) ? ev.dealPlan : [];
    const ph = [];
    plan.forEach(p => {
      const pid = p?.pid;
      const cnt = Math.max(0, Number(p?.count) || 0);
      if (!pid || !cnt) return;
      const start = getFallbackStartCenter(pid);
      for (let i=0;i<cnt;i++){
        const d = document.createElement('div');
        d.className = 'round-collect-card';
        d.style.position = 'fixed';
        d.style.left = (start.cx - 14) + 'px';
        d.style.top  = (start.cy - 21) + 'px';
        d.style.width = '28px';
        d.style.height = '42px';
        d.style.margin = '0';
        d.style.transform = 'translate(0,0) scale(1)';
        d.style.opacity = '1';
        d.style.transition = `transform ${DURATION}ms cubic-bezier(.18,.88,.28,1)`;
        setCardBackImage(d);
        layer.appendChild(d);
        ph.push({ clone: d, fromCX: start.cx, fromCY: start.cy, idx: i, scale: 1 });
      }
    });
    return ph;
  };

  let clones = [];
  if (!candidates.length){
    clones = makePhantomFromCounts();
  } else {
    candidates.forEach((o, idx) => {
      const rect = o.rect;

      // ★ 到着時サイズ（左デッキと同じ）
      const TARGET_W = 28;
      const TARGET_H = 42;

      // ★ 元の表示サイズ → デッキサイズへ縮小（自分のカードが特に小さくなる）
      const sx = TARGET_W / Math.max(1, rect.width);
      const sy = TARGET_H / Math.max(1, rect.height);
      const scale = Math.min(sx, sy);

      const clone = document.createElement('div');
      clone.className = 'round-collect-card';
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top  = rect.top  + 'px';
      // ★ 見た目の“出発点”は元のサイズのまま
      clone.style.width  = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.margin = '0';
      clone.style.transform = 'translate(0,0) scale(1)';
      clone.style.opacity = '1';
      clone.style.transition = `transform ${DURATION}ms cubic-bezier(.18,.88,.28,1)`;
      setCardBackImage(clone);
      layer.appendChild(clone);

      // 元は見えなく（display:noneにしない）
      o.el.style.opacity = '0';

      const fromCX = rect.left + rect.width/2;
      const fromCY = rect.top + rect.height/2;

      clones.push({ clone, fromCX, fromCY, idx, scale });
    });

    // 早めにvisibility hidden（次でDB更新→新しい手札が来るまで“残像”防止）
    setTimeout(() => {
      document.querySelectorAll('.my-card, .mini-card').forEach(card => {
        card.style.visibility = 'hidden';
        card.style.opacity = '';
        card.classList.remove('collected');
      });
    }, Math.min(260, DURATION * 0.25));
  }

  requestAnimationFrame(() => {
    clones.forEach(({ clone, fromCX, fromCY, idx, scale }) => {
      const offset = ((idx ?? 0) - (clones.length - 1) / 2) * 1.4;
      const dx = targetCX - fromCX + offset;
      const dy = targetCY - fromCY;
      // ★ 移動しながら縮小して「右デッキ(28x42)」に揃える
      clone.style.transform = `translate(${dx}px, ${dy}px) scale(${Number.isFinite(scale) ? scale : 1})`;
    });
  });

  // 保険：もしhands更新が来ない場合は復帰
  if (recoverVisibilityTimer) clearTimeout(recoverVisibilityTimer);
  recoverVisibilityTimer = setTimeout(() => {
    if (isCollectAnimating) return;
    document.querySelectorAll('.my-card, .mini-card').forEach(card => {
      if (card.style.visibility === 'hidden') card.style.visibility = '';
    });
  }, DURATION + 1400);

  await sleep(DURATION + 40);

  const layerNow = document.getElementById('roundCollectLayer');
  if (layerNow && layerNow.parentNode) layerNow.parentNode.removeChild(layerNow);

  // ★ 右デッキ表示はこのまま（次のdealBundlesで減っていく）
  isCollectAnimating = false;
  tryPlayPendingAnimEvent();
}

/* =========================================================
   ★ 2回目アニメ(2)：右デッキから「束感」→順番配布
   ========================================================= */
function hideAllHandsVisibility(){
  // 自分
  myHandEl?.querySelectorAll('.my-card').forEach(el => el.style.visibility = 'hidden');
  // 他人（data-owner-id が付くミニカード）
  document.querySelectorAll('.mini-card[data-owner-id]').forEach(el => el.style.visibility = 'hidden');
}

function revealHandForPid(pid){
  if (!pid) return;
  if (pid === state.userId){
    myHandEl?.querySelectorAll('.my-card').forEach(el => el.style.visibility = '');
  } else {
    document.querySelectorAll(`.mini-card[data-owner-id="${pid}"]`).forEach(el => el.style.visibility = '');
  }
}

async function playAnimDealBundles(ev){
  if (state.fullOpenMode || stopRoundCollectForBoom) {
    isCollectAnimating = false;
    handsDirtyWhileAnimating = false;
    return;
  }
  if (isCollectAnimating){
    queueAnimEvent(ev);
    return;
  }

  const plan = Array.isArray(ev.dealPlan) ? ev.dealPlan : [];
  const deckCount0 = Math.max(0, Number(ev.deckCount) || 0);
  const PER = Math.max(220, Number(ev.durationPerPlayer) || 420);
  const GAP = Math.max(0, Number(ev.gap) || 150);

  // layer掃除
  const oldLayer = document.getElementById('roundCollectLayer');
  if (oldLayer && oldLayer.parentNode){
    oldLayer.parentNode.removeChild(oldLayer);
  }

  isCollectAnimating = true;
  isDealing = true;
  dealtPids = new Set();

  // 右デッキを確実に表示（28x42固定）
  updateRightDeckUI(deckCount0);

  // hands がDB更新された直後に来るが、isCollectAnimating中は描画が止まるので強制描画
  renderHands();
  await waitUntil(() => {
    return (myHandEl?.children?.length || 0) >= 0 && document.querySelectorAll('.player-tag').length >= 0;
  }, 700);

  // いったん全員の手札を隠して、配られた人から順に出す
  hideAllHandsVisibility();

  // 安全タイマー（何かあっても固まらない）
  if (dealingSafetyTimer) clearTimeout(dealingSafetyTimer);
  dealingSafetyTimer = setTimeout(() => {
    isDealing = false;
    dealtPids = new Set();
    isCollectAnimating = false;
    updateRightDeckUI(0);
    document.querySelectorAll('.my-card, .mini-card[data-owner-id]').forEach(el => el.style.visibility = '');
  }, plan.length * (PER + GAP) + 4000);

  const layer = document.createElement('div');
  layer.id = 'roundCollectLayer';
  layer.className = 'round-collect-layer';
  document.body.appendChild(layer);

  const rng = makeSeededRng(String(ev.id || ev.createdAt || 'deal'));

  let remain = deckCount0;

  for (let i=0; i<plan.length; i++){
    const pid = plan[i]?.pid;
    const take = Math.max(0, Number(plan[i]?.count) || 0);
    if (!pid || !take) continue;

    const { cx: fromCX, cy: fromCY } = getDeckTargetCenterRight();

    // 配布先中心（自分＝手札中心、他人＝タグ中心）
    const target = getFallbackStartCenter(pid);
    const toCX = target.cx;
    const toCY = target.cy;

    // 束（take枚ぶんの“束感”）：見た目は最大6枚で表現（多いときも厚みだけ）
    const shown = Math.min(6, take);
    const stack = [];
    for (let k=0; k<shown; k++){
      const c = document.createElement('div');
      c.className = 'round-collect-card';
      c.style.position = 'fixed';
      c.style.width = '28px';
      c.style.height = '42px';
      c.style.margin = '0';

      const ox = (k * 0.9) + (rng() * 0.6);
      const oy = (-k * 0.9) + (rng() * 0.6);
      const rot = (rng() * 2 - 1) * 2.0;

      c.style.left = (fromCX - 14 + ox) + 'px';
      c.style.top  = (fromCY - 21 + oy) + 'px';
      c.style.transform = `translate(0,0) rotate(${rot}deg)`;
      c.style.opacity = '1';
      c.style.transition = `transform ${PER}ms cubic-bezier(.18,.88,.28,1)`;
      setCardBackImage(c);
      layer.appendChild(c);

      stack.push({ el: c, ox, oy, rot });
    }

    // 少し間を置いてから移動（束が“持ち上がる”感じ）
    await sleep(60);

    requestAnimationFrame(() => {
      stack.forEach((s, idx2) => {
        const jitterX = (rng() * 2 - 1) * 3;
        const jitterY = (rng() * 2 - 1) * 3;
        const dx = (toCX - fromCX) + jitterX;
        const dy = (toCY - fromCY) + jitterY;
        // 移動中も束のズレを保つ
        s.el.style.transform = `translate(${dx}px, ${dy}px) rotate(${s.rot}deg) translate(${s.ox}px, ${s.oy}px)`;
      });
    });

    await sleep(PER + 10);

    // 束を消す
    stack.forEach(s => {
      if (s.el && s.el.parentNode) s.el.parentNode.removeChild(s.el);
    });

    // 右デッキ残数を減らす
    remain = Math.max(0, remain - take);
    updateRightDeckUI(remain);

    // その人の手札を表示
    dealtPids.add(pid);

    // DOMがまだ揃ってない時があるので軽く待つ
    await waitUntil(() => {
      if (pid === state.userId){
        return (myHandEl?.children?.length || 0) >= take;
      }
      return document.querySelectorAll(`.mini-card[data-owner-id="${pid}"]`).length >= take;
    }, 700);

    revealHandForPid(pid);

    await sleep(GAP);
  }

  // 終了処理
  const layerNow = document.getElementById('roundCollectLayer');
  if (layerNow && layerNow.parentNode) layerNow.parentNode.removeChild(layerNow);

  updateRightDeckUI(0);

  isDealing = false;
  dealtPids = new Set();

  if (dealingSafetyTimer) clearTimeout(dealingSafetyTimer);
  dealingSafetyTimer = null;

  isCollectAnimating = false;

  if (handsDirtyWhileAnimating){
    handsDirtyWhileAnimating = false;
    renderHands();
  }

  tryPlayPendingAnimEvent();
}

function subscribeCenter(){
  if (!state.roomCode) return;

  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderMyRoleArea();
  });

  const sOwnerRef = ref(db, `rooms/${state.roomCode}/sOwner`);
  onValue(sOwnerRef, snap => {
    state.sOwner = snap.val() || null;
    cancelActiveNipperDrag();
    renderMyRoleArea();
    if (latestPlayers.length){
      renderPlayerCircle(latestPlayers);
    }
  });

  const centerDeckRef = ref(db, `rooms/${state.roomCode}/centerDeck`);
  onValue(centerDeckRef, snap => {
    const deckCards = snap.val() || [];
    state.centerDeckCards = Array.isArray(deckCards) ? deckCards : [];
    updateLeftDeckUI();
  });

  const stackLevelRef = ref(db, `rooms/${state.roomCode}/centerStackLevel`);
  onValue(stackLevelRef, snap => {
    const lv = snap.val();
    state.centerStackLevel = typeof lv === 'number' ? lv : 0;
    updateLeftDeckUI();
  });
}

// URL room
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl){ inputCode.value = roomFromUrl; }

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  // ★ join時刻（この時刻より古い animEvent は無視）
  state.joinedAt = Date.now();
  state.lastAnimEventId = sessionStorage.getItem(`tbLastAnimEventId_${state.roomCode}`) || null;

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');
  document.querySelector('main')?.classList.add('in-room');

  await restoreSeatFromDB();

  if (state.seatedTable === null) {
    await renderSeatTabs();
    seatPop.classList.remove('hidden');
  } else {
    seatPop.classList.add('hidden');
  }

  subscribePlayers();
  subscribeHostState();
  subscribeRound();
  subscribeHands();
  subscribeCenter();
  subscribeFullOpenMode();
  subscribeRoundChipsCounter();
  subscribeAnimEvent();

  ensureDeckBuilt(deckRow);
  ensureDeckBuilt(deckRowRight);
  updateLeftDeckUI();
  updateRightDeckUI(0);
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'コピー完了';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};

    const maxPlayers = roomData.maxPlayers || 8;

    if(state.isHost && !roomData.maxPlayers){
      seatLabel.textContent = '人数を選択';

      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });

          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, {
            playerId: state.userId,
            playerName: state.userName
          });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };

        seatTabs.appendChild(tab);
      }

    } else {
      seatLabel.textContent = '席を選択';

      const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
      const tables = tablesSnap.val() || {};

      for(let i=1; i<=maxPlayers; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        const t = tables[i];
        if(t && t.playerId){
          tab.classList.add('disabled');
        }

        tab.onclick = async () => {
          if(tab.classList.contains('disabled')) return;

          const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
          await set(tRef, {
            playerId: state.userId,
            playerName: state.userName
          });
          tab.classList.add('disabled');

          state.seatedTable = i;
          seatPop.classList.add('hidden');
        };

        seatTabs.appendChild(tab);
      }
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
      await renderSeatTabs();
      seatPop.classList.remove('hidden');
    }
    if (!seatPop.classList.contains('hidden')) {
      await renderSeatTabs();
    }

    renderPlayerCircle(players);
    updateRoundChips();
  });
}

/* ★ Sカード所持者の手番操作（公開＆ターン移動） */
async function onMiniCardClick(ownerId, cardIndex){
  if (!state.roomCode) return;
  if (isCollectAnimating) return;

  const hand = state.hands[ownerId];
  if (!hand || !Array.isArray(hand.cards)) return;

  const cards = hand.cards;
  const openArr = (hand.open && hand.open.slice()) || new Array(cards.length).fill(false);

  if (openArr[cardIndex]) return;

  if (!state.fullOpenMode){
    if (!state.sOwner || state.userId !== state.sOwner) return;
    if (ownerId === state.userId) return;

    openArr[cardIndex] = true;

    const updates = {};
    updates[`rooms/${state.roomCode}/hands/${ownerId}/open`] = openArr;
    updates[`rooms/${state.roomCode}/sOwner`] = ownerId;

    if (cards[cardIndex] === 2 || cards[cardIndex] === '2'){
      const newCount = (state.roundChipsFrontCount || 0) + 1;
      state.roundChipsFrontCount = newCount;
      updates[`rooms/${state.roomCode}/roundChipsFrontCount`] = newCount;
    }

    await update(ref(db), updates);
    return;
  }

  if (ownerId === state.userId) return;

  openArr[cardIndex] = true;

  const updates = {};
  updates[`rooms/${state.roomCode}/hands/${ownerId}/open`] = openArr;

  if (cards[cardIndex] === 2 || cards[cardIndex] === '2'){
    const newCount = (state.roundChipsFrontCount || 0) + 1;
    state.roundChipsFrontCount = newCount;
    updates[`rooms/${state.roomCode}/roundChipsFrontCount`] = newCount;
  }

  await update(ref(db), updates);
}

/* ★ ネームタグを円周上に等分配置 */
function renderPlayerCircle(players){
  cancelActiveNipperDrag();

  document.body.classList.remove('pulse-stop');
  clearMiniCardHints();

  playerCircle.innerHTML = '';
  if (!players.length) return;

  const n = players.length;
  const radius = 45;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;

  const meIndex = players.findIndex(p => p.id === state.userId);
  const myTurn = isMyTurn();

  const pos = players.map((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;
    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);
    return { p, idx, k, angle, x, y };
  });

  let topIdx = 0;
  for (let i = 1; i < pos.length; i++){
    if (pos[i].y < pos[topIdx].y) topIdx = i;
  }

  const enableTopRowSpread = (n === 5 || n === 7);
  const SPREAD = (n === 5) ? 8 : 10;
  const EPS = 0.18;

  let topRowSet = null;
  if (enableTopRowSpread){
    const minY = Math.min(...pos.map(o => o.y));
    const topRow = pos.filter(o => Math.abs(o.y - minY) <= EPS);

    if (topRow.length > 2){
      topRow.sort((a,b)=>Math.abs(a.y-minY)-Math.abs(b.y-minY));
      topRow.splice(2);
    }
    topRowSet = new Set(topRow.map(o => o.idx));
  }

  pos.forEach((o, idx) => {
    const p = o.p;

    let xAdj = o.x;
    if (enableTopRowSpread && topRowSet && topRowSet.has(o.idx)){
      xAdj += (o.x < 50 ? -SPREAD : +SPREAD);
    }

    const tag = document.createElement('div');

    const isLiftCount = (n === 6 || n === 8);
    const isTopLift = (isLiftCount && idx === topIdx);

    tag.className =
      'player-tag'
      + (p.id === state.userId ? ' me' : '')
      + (isTopLift ? ' at-12' : '');

    tag.style.left = `${xAdj}%`;
    tag.style.top  = `${o.y}%`;

    tag.dataset.playerId = p.id;

    const main = document.createElement('div');
    main.className = 'player-tag-main';

    const nameSpan = document.createElement('span');
    nameSpan.textContent = p.name;
    main.appendChild(nameSpan);

    tag.appendChild(main);

    if (state.sOwner === p.id && p.id !== state.userId){
      const sInd = document.createElement('div');
      sInd.className = 'player-tag-s-indicator';
      tag.appendChild(sInd);
    }

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingPlayerNameToSteal = p.name;
      pendingSeatPlayerIdToSteal = p.id;

      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const handData = state.hands[p.id];
    if (p.id !== state.userId && handData && Array.isArray(handData.cards) && handData.cards.length){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const cards = handData.cards || [];
      const openFlags = handData.open || [];

      if (state.fullOpenMode && state.roles && state.roles[p.id] && state.roles[p.id].role){
        const roleMini = document.createElement('div');
        roleMini.className = 'mini-card mini-role-card';
        const r = state.roles[p.id].role;
        if (r === 'O') roleMini.style.backgroundImage = "url('policerole.jpg')";
        else if (r === 'X') roleMini.style.backgroundImage = "url('bombrole.jpg')";
        else roleMini.textContent = '?';
        miniHand.appendChild(roleMini);
      }

      cards.forEach((v, idx2) => {
        const card = document.createElement('div');
        card.className = 'mini-card';

        const isOpen = !!openFlags[idx2];

        card.dataset.ownerId = p.id;
        card.dataset.cardIndex = String(idx2);

        if (isOpen){
          card.classList.add('is-open');
          setCardFrontImage(card, v);
        } else {
          card.classList.add('is-back');
          setCardBackImage(card);

          if (myTurn){
            card.classList.add('pulse');
          }
        }

        if (isDealing && !dealtPids.has(p.id)){
          card.style.visibility = 'hidden';
        }

        if (state.fullOpenMode && !isOpen && p.id !== state.userId){
          card.style.cursor = 'pointer';
          card.addEventListener('click', (ev) => {
            ev.stopPropagation();
            onMiniCardClick(p.id, idx2);
          });
        } else {
          card.style.cursor = 'default';
        }

        miniHand.appendChild(card);
      });

      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  });
  updateCachedCenters();
}

function updateCachedCenters(){
  if (myHandEl){
    const r = myHandEl.getBoundingClientRect();
    if (r && r.width && r.height){
      cachedMyHandCenter = { cx: r.left + r.width/2, cy: r.top + r.height/2 };
    }
  }
  document.querySelectorAll('.player-tag[data-player-id]').forEach(tag => {
    const r = tag.getBoundingClientRect();
    if (!r || !r.width || !r.height) return;
    cachedPlayerCenters.set(tag.dataset.playerId, { cx: r.left + r.width/2, cy: r.top + r.height/2 });
  });
}

/* ★ 追い出しポップ */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingPlayerNameToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingPlayerNameToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const kickedId  = pendingSeatPlayerIdToSteal;
  const newId     = state.userId;
  const roomBase  = `rooms/${state.roomCode}`;

  const [roomSnap, handsSnap, rolesSnap, sOwnerSnap] = await Promise.all([
    get(ref(db, roomBase)),
    get(ref(db, `${roomBase}/hands`)),
    get(ref(db, `${roomBase}/roles`)),
    get(ref(db, `${roomBase}/sOwner`))
  ]);

  const roomData  = roomSnap.val()  || {};
  const hands     = handsSnap.val() || {};
  const roles     = rolesSnap.val() || {};
  const sOwnerVal = sOwnerSnap.val();

  const updates = {};

  updates[`${roomBase}/tables/${seatIndex}`] = {
    playerId: newId,
    playerName: state.userName || '名無し'
  };

  if (kickedId && hands[kickedId]) {
    updates[`${roomBase}/hands/${newId}`] = hands[kickedId];
    updates[`${roomBase}/hands/${kickedId}`] = null;
  }

  if (kickedId && roles[kickedId]) {
    updates[`${roomBase}/roles/${newId}`] = roles[kickedId];
    updates[`${roomBase}/roles/${kickedId}`] = null;
  }

  if (kickedId && sOwnerVal === kickedId) {
    updates[`${roomBase}/sOwner`] = newId;
  }

  if (kickedId && roomData.hostId === kickedId) {
    updates[`${roomBase}/hostId`] = newId;
  }

  await update(ref(db), updates);

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingPlayerNameToSteal = null;
  pendingSeatPlayerIdToSteal = null;
  seatPop.classList.add('hidden');
});

/* ===== 以下、配札/リセット/スタート等 ===== */

function buildRoleDeckByPlayerCount(playerCount){
  let deck = [];
  switch(playerCount){
    case 3: deck = ['O','O','X','X']; break;
    case 4: deck = ['O','O','O','X','X']; break;
    case 5: deck = ['O','O','O','X','X']; break;
    case 6: deck = ['O','O','O','O','X','X']; break;
    case 7: deck = ['O','O','O','O','X','X','X']; break;
    case 8: deck = ['O','O','O','O','O','X','X','X']; break;
    default:
      const good = Math.max(1, Math.ceil(playerCount / 2));
      const bad  = Math.max(0, playerCount - good);
      deck = new Array(good).fill('O').concat(new Array(bad).fill('X'));
  }
  return deck;
}

function shuffleInPlace(arr){
  for(let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

async function dealInitialHands(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const players = [];
  for (const [seatIndex, t] of Object.entries(tables)){
    if (t && t.playerId){
      players.push({
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      });
    }
  }

  const playerCount = players.length;
  if (!playerCount) return;

  const deck = [];
  deck.push(1);
  for (let i = 0; i < playerCount; i++) deck.push(2);

  const count3 = playerCount * 5 - (1 + playerCount);
  for (let i = 0; i < count3; i++) deck.push(3);

  shuffleInPlace(deck);

  const hands = {};
  let deckIndex = 0;

  players.forEach(p => {
    const cards = [];
    for (let i = 0; i < 5; i++){
      cards.push(deck[deckIndex++]);
    }
    hands[p.id] = { cards, open: new Array(cards.length).fill(false) };
  });

  const roleDeck = buildRoleDeckByPlayerCount(playerCount);
  shuffleInPlace(roleDeck);

  const roles = {};
  players.forEach((p, idx) => {
    roles[p.id] = { role: roleDeck[idx] };
  });

  const randIndex = Math.floor(Math.random() * playerCount);
  const sOwner = players[randIndex].id;

  const updates = {};
  updates[`rooms/${state.roomCode}/hands`] = hands;
  updates[`rooms/${state.roomCode}/roles`] = roles;
  updates[`rooms/${state.roomCode}/sOwner`] = sOwner;

  await update(ref(db), updates);
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  const isHidden = startPop.classList.contains('hidden');
  if (isHidden) startPop.classList.remove('hidden');
  else startPop.classList.add('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnTableReset.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  isCollectAnimating = false;
  handsDirtyWhileAnimating = false;
  pendingAnimEvents = [];
  isDealing = false;
  dealtPids = new Set();

  stopRoundCollectForSuccess = false;
  if (roundCollectTimerId){
    clearTimeout(roundCollectTimerId);
    roundCollectTimerId = null;
  }
  stopRoundCollectForBoom = false;

  state.hands = {};
  state.roles = {};
  state.sOwner = null;
  state.centerDeckCards = [];
  state.centerStackLevel = 0;
  state.rightDeckCount = 0;
  state.round = 0;
  state.fullOpenMode = false;
  state.seatedTable = null;
  latestPlayers = [];
  state.roundChipsFrontCount = 0;
  lastAllChipsFront = false;

  myHandEl.innerHTML = '';
  myRoleArea.innerHTML = '';
  myRoleArea.classList.add('hidden');
  playerCircle.innerHTML = '';

  state.centerDeckCards = [];
  updateLeftDeckUI();
  updateRightDeckUI(0);

  if (roundChipRow){
    roundChipRow.innerHTML = '';
    roundChipRow.style.display = 'none';
  }

  const updates = {};
  updates[`rooms/${state.roomCode}/hands`] = null;
  updates[`rooms/${state.roomCode}/roles`] = null;
  updates[`rooms/${state.roomCode}/sOwner`] = null;
  updates[`rooms/${state.roomCode}/centerDeck`] = [];
  updates[`rooms/${state.roomCode}/centerStackLevel`] = 0;
  updates[`rooms/${state.roomCode}/round`] = 0;
  updates[`rooms/${state.roomCode}/fullOpenMode`] = false;
  updates[`rooms/${state.roomCode}/roundChipsFrontCount`] = 0;
  updates[`rooms/${state.roomCode}/tables`] = null;
  updates[`rooms/${state.roomCode}/maxPlayers`] = null;
  updates[`rooms/${state.roomCode}/animEvent`] = null;

  await update(ref(db), updates);

  startPop.classList.add('hidden');
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;

  isCollectAnimating = false;
  pendingAnimEvents = [];
  isDealing = false;
  dealtPids = new Set();

  stopRoundCollectForSuccess = false;
  if (roundCollectTimerId){
    clearTimeout(roundCollectTimerId);
    roundCollectTimerId = null;
  }
  stopRoundCollectForBoom = false;

  state.round = 1;

  state.centerStackLevel = 0;
  state.centerDeckCards = [];
  state.rightDeckCount = 0;

  state.fullOpenMode = false;
  state.roundChipsFrontCount = 0;
  lastAllChipsFront = false;

  await dealInitialHands();

  await update(ref(db, `rooms/${state.roomCode}`), {
    round: state.round,
    centerDeck: [],
    centerStackLevel: 0,
    fullOpenMode: false,
    roundChipsFrontCount: 0,
    animEvent: null
  });

  updateLeftDeckUI();
  updateRightDeckUI(0);

  startPop.classList.add('hidden');
});
</script>

</body>
</html>
